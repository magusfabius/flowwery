(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.onflowSdk = {}));
})(this, (function (exports) { 'use strict';

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _typeof$1(obj) {
    "@babel/helpers - typeof";

    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof$1(obj);
  }

  var regeneratorRuntime$1 = {exports: {}};

  var _typeof = {exports: {}};

  (function (module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";

      return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
    }

    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_typeof);

  (function (module) {
    var _typeof$1 = _typeof.exports["default"];

    function _regeneratorRuntime() {
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

      module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports = {},
          Op = Object.prototype,
          hasOwn = Op.hasOwnProperty,
          $Symbol = "function" == typeof Symbol ? Symbol : {},
          iteratorSymbol = $Symbol.iterator || "@@iterator",
          asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
          toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value: value,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), obj[key];
      }

      try {
        define({}, "");
      } catch (err) {
        define = function define(obj, key, value) {
          return obj[key] = value;
        };
      }

      function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
            generator = Object.create(protoGenerator.prototype),
            context = new Context(tryLocsList || []);
        return generator._invoke = function (innerFn, self, context) {
          var state = "suspendedStart";
          return function (method, arg) {
            if ("executing" === state) throw new Error("Generator is already running");

            if ("completed" === state) {
              if ("throw" === method) throw arg;
              return doneResult();
            }

            for (context.method = method, context.arg = arg;;) {
              var delegate = context.delegate;

              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);

                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }

              if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
                if ("suspendedStart" === state) throw state = "completed", context.arg;
                context.dispatchException(context.arg);
              } else "return" === context.method && context.abrupt("return", context.arg);
              state = "executing";
              var record = tryCatch(innerFn, self, context);

              if ("normal" === record.type) {
                if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                return {
                  value: record.arg,
                  done: context.done
                };
              }

              "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
            }
          };
        }(innerFn, self, context), generator;
      }

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      exports.wrap = wrap;
      var ContinueSentinel = {};

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {}

      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf,
          NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if ("throw" !== record.type) {
            var result = record.arg,
                value = result.value;
            return value && "object" == _typeof$1(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function (unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function (error) {
              return invoke("throw", error, resolve, reject);
            });
          }

          reject(record.arg);
        }

        var previousPromise;

        this._invoke = function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
      }

      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (undefined === method) {
          if (context.delegate = null, "throw" === context.method) {
            if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
            context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }

      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
      }

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next) return iterable;

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              for (; ++i < iterable.length;) {
                if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              }

              return next.value = undefined, next.done = !0, next;
            };

            return next.next = next;
          }
        }

        return {
          next: doneResult
        };
      }

      function doneResult() {
        return {
          value: undefined,
          done: !0
        };
      }

      return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports.mark = function (genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports.awrap = function (arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
        return this;
      }), define(Gp, "toString", function () {
        return "[object Generator]";
      }), exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        return keys.reverse(), function next() {
          for (; keys.length;) {
            var key = keys.pop();
            if (key in object) return next.value = key, next.done = !1, next;
          }

          return next.done = !0, next;
        };
      }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
          }
        },
        stop: function stop() {
          this.done = !0;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type) throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) throw exception;
          var context = this;

          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i],
                record = entry.completion;
            if ("root" === entry.tryLoc) return handle("end");

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"),
                  hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              } else {
                if (!hasFinally) throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type) throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          }

          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
      }, exports;
    }

    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(regeneratorRuntime$1);

  var runtime = regeneratorRuntime$1.exports();
  var regenerator = runtime; // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if ((typeof globalThis === "undefined" ? "undefined" : _typeof$1(globalThis)) === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function F() {};

        return {
          s: F,
          n: function n() {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function e(_e) {
            throw _e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function s() {
        it = it.call(o);
      },
      n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function e(_e2) {
        didErr = true;
        err = _e2;
      },
      f: function f() {
        try {
          if (!normalCompletion && it["return"] != null) it["return"]();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var promise;
  var queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask // reuse resolved promise, and allocate it lazily
  : function (cb) {
    return (promise || (promise = Promise.resolve())).then(cb)["catch"](function (err) {
      return setTimeout(function () {
        throw err;
      }, 0);
    });
  };

  var mailbox = function mailbox() {
    var queue = [];
    var next;
    return {
      deliver: function deliver(msg) {
        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  queue.push(msg);

                  if (next) {
                    next(queue.shift());
                    next = undefined;
                  }

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      receive: function receive() {
        return new Promise(function innerReceive(resolve) {
          var msg = queue.shift();
          if (msg) return resolve(msg);
          next = resolve;
        });
      }
    };
  };

  var INIT = "INIT";
  var SUBSCRIBE = "SUBSCRIBE";
  var UNSUBSCRIBE = "UNSUBSCRIBE";
  var UPDATED$1 = "UPDATED";
  var EXIT = "EXIT";
  var TERMINATE = "TERMINATE";
  var root = (typeof self === "undefined" ? "undefined" : _typeof$1(self)) === "object" && self.self === self && self || (typeof global === "undefined" ? "undefined" : _typeof$1(global)) === "object" && global.global === global && global || (typeof window === "undefined" ? "undefined" : _typeof$1(window)) === "object" && window.window === window && window;
  root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
  var pid = 0;
  var DEFAULT_TIMEOUT = 5000;

  var _send = function send(addr, tag, data) {
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    return new Promise(function (reply, reject) {
      var expectReply = opts.expectReply || false;
      var timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;

      if (expectReply && timeout) {
        setTimeout(function () {
          return reject(new Error("Timeout: ".concat(timeout, "ms passed without a response.")));
        }, timeout);
      }

      var payload = {
        to: addr,
        from: opts.from,
        tag: tag,
        data: data,
        timeout: timeout,
        reply: reply,
        reject: reject
      };

      try {
        root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);
        if (!expectReply) reply(true);
      } catch (error) {
        console.error("FCL.Actor -- Could Not Deliver Message", payload, root.FCL_REGISTRY[addr], error);
      }
    });
  };

  var kill = function kill(addr) {
    delete root.FCL_REGISTRY[addr];
  };

  var fromHandlers = function fromHandlers() {
    var handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ctx) {
        var letter;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(typeof handlers[INIT] === "function")) {
                  _context.next = 3;
                  break;
                }

                _context.next = 3;
                return handlers[INIT](ctx);

              case 3:
                _context.next = 6;
                return ctx.receive();

              case 6:
                letter = _context.sent;
                _context.prev = 7;

                if (!(letter.tag === EXIT)) {
                  _context.next = 13;
                  break;
                }

                if (!(typeof handlers[TERMINATE] === "function")) {
                  _context.next = 12;
                  break;
                }

                _context.next = 12;
                return handlers[TERMINATE](ctx, letter, letter.data || {});

              case 12:
                return _context.abrupt("break", 25);

              case 13:
                _context.next = 15;
                return handlers[letter.tag](ctx, letter, letter.data || {});

              case 15:
                _context.next = 20;
                break;

              case 17:
                _context.prev = 17;
                _context.t0 = _context["catch"](7);
                console.error("".concat(ctx.self(), " Error"), letter, _context.t0);

              case 20:
                _context.prev = 20;
                return _context.abrupt("continue", 3);

              case 23:
                _context.next = 3;
                break;

              case 25:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[7, 17, 20, 23]]);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
  };

  var spawn = function spawn(fn) {
    var addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (addr == null) addr = ++pid;
    if (root.FCL_REGISTRY[addr] != null) return addr;
    root.FCL_REGISTRY[addr] = {
      addr: addr,
      mailbox: mailbox(),
      subs: new Set(),
      kvs: {},
      error: null
    };
    var ctx = {
      self: function self() {
        return addr;
      },
      receive: function receive() {
        return root.FCL_REGISTRY[addr].mailbox.receive();
      },
      send: function send(to, tag, data) {
        var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        opts.from = addr;
        return _send(to, tag, data, opts);
      },
      sendSelf: function sendSelf(tag, data, opts) {
        if (root.FCL_REGISTRY[addr]) _send(addr, tag, data, opts);
      },
      broadcast: function broadcast(tag, data) {
        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        opts.from = addr;

        var _iterator = _createForOfIteratorHelper(root.FCL_REGISTRY[addr].subs),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var to = _step.value;

            _send(to, tag, data, opts);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      subscribe: function subscribe(sub) {
        return sub != null && root.FCL_REGISTRY[addr].subs.add(sub);
      },
      unsubscribe: function unsubscribe(sub) {
        return sub != null && root.FCL_REGISTRY[addr].subs["delete"](sub);
      },
      subscriberCount: function subscriberCount() {
        return root.FCL_REGISTRY[addr].subs.size;
      },
      hasSubs: function hasSubs() {
        return !!root.FCL_REGISTRY[addr].subs.size;
      },
      put: function put(key, value) {
        if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;
      },
      get: function get(key, fallback) {
        var value = root.FCL_REGISTRY[addr].kvs[key];
        return value == null ? fallback : value;
      },
      "delete": function _delete(key) {
        delete root.FCL_REGISTRY[addr].kvs[key];
      },
      update: function update(key, fn) {
        if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);
      },
      keys: function keys() {
        return Object.keys(root.FCL_REGISTRY[addr].kvs);
      },
      all: function all() {
        return root.FCL_REGISTRY[addr].kvs;
      },
      where: function where(pattern) {
        return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce(function (acc, key) {
          return pattern.test(key) ? _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, key, root.FCL_REGISTRY[addr].kvs[key])) : acc;
        }, {});
      },
      merge: function merge() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Object.keys(data).forEach(function (key) {
          return root.FCL_REGISTRY[addr].kvs[key] = data[key];
        });
      },
      fatalError: function fatalError(error) {
        root.FCL_REGISTRY[addr].error = error;

        var _iterator2 = _createForOfIteratorHelper(root.FCL_REGISTRY[addr].subs),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var to = _step2.value;

            _send(to, UPDATED$1);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    };
    if (_typeof$1(fn) === "object") fn = fromHandlers(fn);
    queueMicrotask_1( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return fn(ctx);

            case 2:
              kill(addr);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    return addr;
  }; // Returns an unsubscribe function
  // A SUBSCRIBE handler will need to be created to handle the subscription event
  //
  //  [SUBSCRIBE]: (ctx, letter) => {
  //    ctx.subscribe(letter.from)
  //    ctx.send(letter.from, UPDATED, ctx.all())
  //  }
  //


  function subscriber(address, spawnFn, callback) {
    spawnFn(address);
    var EXIT = "@EXIT";
    var self = spawn( /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ctx) {
        var letter, error;
        return regenerator.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                ctx.send(address, SUBSCRIBE);

              case 1:
                _context3.next = 4;
                return ctx.receive();

              case 4:
                letter = _context3.sent;
                error = root.FCL_REGISTRY[address].error;

                if (!(letter.tag === EXIT)) {
                  _context3.next = 9;
                  break;
                }

                ctx.send(address, UNSUBSCRIBE);
                return _context3.abrupt("return");

              case 9:
                if (!error) {
                  _context3.next = 13;
                  break;
                }

                callback(null, error);
                ctx.send(address, UNSUBSCRIBE);
                return _context3.abrupt("return");

              case 13:
                callback(letter.data, null);
                _context3.next = 1;
                break;

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function (_x2) {
        return _ref3.apply(this, arguments);
      };
    }());
    return function () {
      return _send(self, EXIT);
    };
  } // Returns a promise that returns a result

  var _HANDLERS;

  var NAME = "config";
  var PUT = "PUT_CONFIG";
  var GET = "GET_CONFIG";
  var GET_ALL = "GET_ALL_CONFIG";
  var UPDATE = "UPDATE_CONFIG";
  var DELETE = "DELETE_CONFIG";
  var CLEAR = "CLEAR_CONFIG";
  var WHERE = "WHERE_CONFIG";
  var UPDATED = "CONFIG/UPDATED";

  var identity$2 = function identity(v) {
    return v;
  };

  var HANDLERS = (_HANDLERS = {}, _defineProperty(_HANDLERS, PUT, function (ctx, _letter, _ref) {
    var key = _ref.key,
        value = _ref.value;
    if (key == null) throw new Error("Missing 'key' for config/put.");
    ctx.put(key, value);
    ctx.broadcast(UPDATED, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS, GET, function (ctx, letter, _ref2) {
    var key = _ref2.key,
        fallback = _ref2.fallback;
    if (key == null) throw new Error("Missing 'key' for config/get");
    letter.reply(ctx.get(key, fallback));
  }), _defineProperty(_HANDLERS, GET_ALL, function (ctx, letter) {
    letter.reply(_objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS, UPDATE, function (ctx, letter, _ref3) {
    var key = _ref3.key,
        fn = _ref3.fn;
    if (key == null) throw new Error("Missing 'key' for config/update");
    ctx.update(key, fn || identity$2);
    ctx.broadcast(UPDATED, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS, DELETE, function (ctx, letter, _ref4) {
    var key = _ref4.key;
    if (key == null) throw new Error("Missing 'key' for config/delete");
    ctx["delete"](key);
    ctx.broadcast(UPDATED, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS, CLEAR, function (ctx, letter) {
    var keys = Object.keys(ctx.all());

    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
      var key = _keys[_i];
      ctx["delete"](key);
    }

    ctx.broadcast(UPDATED, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS, WHERE, function (ctx, letter, _ref5) {
    var pattern = _ref5.pattern;
    if (pattern == null) throw new Error("Missing 'pattern' for config/where");
    letter.reply(ctx.where(pattern));
  }), _defineProperty(_HANDLERS, SUBSCRIBE, function (ctx, letter) {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS, UNSUBSCRIBE, function (ctx, letter) {
    ctx.unsubscribe(letter.from);
  }), _HANDLERS);
  spawn(HANDLERS, NAME);

  function put$1(key, value) {
    _send(NAME, PUT, {
      key: key,
      value: value
    });
    return config();
  }

  function get$1(key, fallback) {
    return _send(NAME, GET, {
      key: key,
      fallback: fallback
    }, {
      expectReply: true,
      timeout: 10
    });
  }

  function first() {
    return _first.apply(this, arguments);
  }

  function _first() {
    _first = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
      var wants,
          fallback,
          _wants,
          head,
          rest,
          ret,
          _args2 = arguments;

      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              wants = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : [];
              fallback = _args2.length > 1 ? _args2[1] : undefined;

              if (wants.length) {
                _context2.next = 4;
                break;
              }

              return _context2.abrupt("return", fallback);

            case 4:
              _wants = _toArray(wants), head = _wants[0], rest = _wants.slice(1);
              _context2.next = 7;
              return get$1(head);

            case 7:
              ret = _context2.sent;

              if (!(ret == null)) {
                _context2.next = 10;
                break;
              }

              return _context2.abrupt("return", first(rest, fallback));

            case 10:
              return _context2.abrupt("return", ret);

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _first.apply(this, arguments);
  }

  function all() {
    return _send(NAME, GET_ALL, null, {
      expectReply: true,
      timeout: 10
    });
  }

  function update$1(key) {
    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;
    _send(NAME, UPDATE, {
      key: key,
      fn: fn
    });
    return config();
  }

  function _delete(key) {
    _send(NAME, DELETE, {
      key: key
    });
    return config();
  }

  function where(pattern) {
    return _send(NAME, WHERE, {
      pattern: pattern
    }, {
      expectReply: true,
      timeout: 10
    });
  }

  function subscribe(callback) {
    return subscriber(NAME, function () {
      return spawn(HANDLERS, NAME);
    }, callback);
  }

  function clearConfig() {
    return _send(NAME, CLEAR);
  }

  function config(values) {
    if (values != null && _typeof$1(values) === "object") {
      Object.keys(values).map(function (d) {
        return put$1(d, values[d]);
      });
    }

    return {
      put: put$1,
      get: get$1,
      all: all,
      first: first,
      update: update$1,
      "delete": _delete,
      where: where,
      subscribe: subscribe,
      overload: overload
    };
  }

  config.put = put$1;
  config.get = get$1;
  config.all = all;
  config.first = first;
  config.update = update$1;
  config["delete"] = _delete;
  config.where = where;
  config.subscribe = subscribe;
  config.overload = overload;

  var noop$1 = function noop(v) {
    return v;
  };

  function overload() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$1;
    return new Promise( /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(resolve, reject) {
        var oldConfig, result;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return all();

              case 2:
                oldConfig = _context.sent;
                _context.prev = 3;
                config(opts);
                _context.t0 = callback;
                _context.next = 8;
                return all();

              case 8:
                _context.t1 = _context.sent;
                _context.next = 11;
                return (0, _context.t0)(_context.t1);

              case 11:
                result = _context.sent;
                _context.next = 14;
                return clearConfig();

              case 14:
                _context.next = 16;
                return config(oldConfig);

              case 16:
                resolve(result);
                _context.next = 26;
                break;

              case 19:
                _context.prev = 19;
                _context.t2 = _context["catch"](3);
                _context.next = 23;
                return clearConfig();

              case 23:
                _context.next = 25;
                return config(oldConfig);

              case 25:
                reject(_context.t2);

              case 26:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[3, 19]]);
      }));

      return function (_x, _x2) {
        return _ref6.apply(this, arguments);
      };
    }());
  }

  var LEVELS = Object.freeze({
    debug: 5,
    info: 4,
    log: 3,
    warn: 2,
    error: 1
  });

  var buildLoggerMessageArgs = function buildLoggerMessageArgs(_ref) {
    var title = _ref.title,
        message = _ref.message;
    return ["\n    %c".concat(title, "\n    ============================\n\n    ").concat(message, "\n\n    ============================\n    ").replace(/\n[^\S\r\n]+/g, "\n").trim(),, "font-weight:bold;font-family:monospace;"];
  };

  var log = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref2) {
      var _console, _console2, _console3, _console4, _console5;

      var title, message, level, _ref2$always, always, configLoggerLevel, loggerMessageArgs;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              title = _ref2.title, message = _ref2.message, level = _ref2.level, _ref2$always = _ref2.always, always = _ref2$always === void 0 ? false : _ref2$always;
              _context.next = 3;
              return config.get("logger.level", LEVELS.warn);

            case 3:
              configLoggerLevel = _context.sent;

              if (!(!always && configLoggerLevel < level)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return");

            case 6:
              loggerMessageArgs = buildLoggerMessageArgs({
                title: title,
                message: message
              });
              _context.t0 = level;
              _context.next = _context.t0 === LEVELS.debug ? 10 : _context.t0 === LEVELS.info ? 12 : _context.t0 === LEVELS.warn ? 14 : _context.t0 === LEVELS.error ? 16 : 18;
              break;

            case 10:
              (_console = console).debug.apply(_console, _toConsumableArray(loggerMessageArgs));

              return _context.abrupt("break", 19);

            case 12:
              (_console2 = console).info.apply(_console2, _toConsumableArray(loggerMessageArgs));

              return _context.abrupt("break", 19);

            case 14:
              (_console3 = console).warn.apply(_console3, _toConsumableArray(loggerMessageArgs));

              return _context.abrupt("break", 19);

            case 16:
              (_console4 = console).error.apply(_console4, _toConsumableArray(loggerMessageArgs));

              return _context.abrupt("break", 19);

            case 18:
              (_console5 = console).log.apply(_console5, _toConsumableArray(loggerMessageArgs));

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function log(_x) {
      return _ref3.apply(this, arguments);
    };
  }();

  log.deprecate = function (_ref4) {
    var pkg = _ref4.pkg,
        subject = _ref4.subject,
        transition = _ref4.transition,
        _ref4$level = _ref4.level,
        level = _ref4$level === void 0 ? LEVELS.warn : _ref4$level,
        _ref4$message = _ref4.message,
        message = _ref4$message === void 0 ? "" : _ref4$message,
        _ref4$callback = _ref4.callback,
        callback = _ref4$callback === void 0 ? null : _ref4$callback;

    var capitalizeFirstLetter = function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    };

    var logMessage = function logMessage() {
      return log({
        title: "".concat(pkg ? pkg + " " : "", "Deprecation Notice"),
        message: "\n      ".concat(subject ? "".concat(capitalizeFirstLetter(subject), " is deprecated and will cease to work in future releases").concat(pkg ? " of " + pkg : "", ".") : "").concat(message ? "\n" + message : "").concat(transition ? "\nYou can learn more (including a guide on common transition paths) here: ".concat(transition) : "", "\n    ").trim(),
        level: level
      });
    };

    if (typeof callback === "function") {
      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
        var _args2 = arguments;
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return logMessage();

              case 2:
                _context2.next = 4;
                return callback.apply(void 0, _args2);

              case 4:
                return _context2.abrupt("return", _context2.sent);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
    }

    return logMessage();
  };

  function invariant$1(fact, msg) {
    if (!fact) {
      var _console;

      var error = new Error("INVARIANT ".concat(msg));
      error.stack = error.stack.split("\n").filter(function (d) {
        return !/at invariant/.test(d);
      }).join("\n");

      for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        rest[_key - 2] = arguments[_key];
      }

      (_console = console).error.apply(_console, ["\n\n---\n\n", error, "\n\n"].concat(rest, ["\n\n---\n\n"]));

      throw error;
    }
  }

  var UNKNOWN
  /*                       */
  = "UNKNOWN";
  var SCRIPT
  /*                        */
  = "SCRIPT";
  var TRANSACTION
  /*                   */
  = "TRANSACTION";
  var GET_TRANSACTION_STATUS
  /*        */
  = "GET_TRANSACTION_STATUS";
  var GET_ACCOUNT
  /*                   */
  = "GET_ACCOUNT";
  var GET_EVENTS
  /*                    */
  = "GET_EVENTS";
  var PING
  /*                          */
  = "PING";
  var GET_TRANSACTION
  /*               */
  = "GET_TRANSACTION";
  var GET_BLOCK
  /*                     */
  = "GET_BLOCK";
  var GET_BLOCK_HEADER
  /*              */
  = "GET_BLOCK_HEADER";
  var GET_COLLECTION
  /*                */
  = "GET_COLLECTION";
  var BAD
  /* */
  = "BAD";
  var OK
  /*  */
  = "OK";
  var ACCOUNT
  /*  */
  = "ACCOUNT";
  var PARAM
  /*    */
  = "PARAM";
  var ARGUMENT
  /* */
  = "ARGUMENT";
  var AUTHORIZER
  /* */
  = "authorizer";
  var PAYER
  /*      */
  = "payer";
  var PROPOSER
  /*   */
  = "proposer";
  var ACCT = "{\n  \"kind\":\"".concat(ACCOUNT, "\",\n  \"tempId\":null,\n  \"addr\":null,\n  \"keyId\":null,\n  \"sequenceNum\":null,\n  \"signature\":null,\n  \"signingFunction\":null,\n  \"resolve\":null,\n  \"role\": {\n    \"proposer\":false,\n    \"authorizer\":false,\n    \"payer\":false,\n    \"param\":false\n  }\n}");
  var ARG = "{\n  \"kind\":\"".concat(ARGUMENT, "\",\n  \"tempId\":null,\n  \"value\":null,\n  \"asArgument\":null,\n  \"xform\":null,\n  \"resolve\": null,\n  \"resolveArgument\": null\n}");
  var IX = "{\n  \"tag\":\"".concat(UNKNOWN, "\",\n  \"assigns\":{},\n  \"status\":\"").concat(OK, "\",\n  \"reason\":null,\n  \"accounts\":{},\n  \"params\":{},\n  \"arguments\":{},\n  \"message\": {\n    \"cadence\":null,\n    \"refBlock\":null,\n    \"computeLimit\":null,\n    \"proposer\":null,\n    \"payer\":null,\n    \"authorizations\":[],\n    \"params\":[],\n    \"arguments\":[]\n  },\n  \"proposer\":null,\n  \"authorizations\":[],\n  \"payer\":[],\n  \"events\": {\n    \"eventType\":null,\n    \"start\":null,\n    \"end\":null,\n    \"blockIds\":[]\n  },\n  \"transaction\": {\n    \"id\":null\n  },\n  \"block\": {\n    \"id\":null,\n    \"height\":null,\n    \"isSealed\":null\n  },\n  \"account\": {\n    \"addr\":null\n  },\n  \"collection\": {\n    \"id\":null\n  }\n}");
  var KEYS = new Set(Object.keys(JSON.parse(IX)));
  var interaction = function interaction() {
    return JSON.parse(IX);
  };
  var CHARS = "abcdefghijklmnopqrstuvwxyz0123456789".split("");

  var randChar = function randChar() {
    return CHARS[~~(Math.random() * CHARS.length)];
  };

  var uuid = function uuid() {
    return Array.from({
      length: 10
    }, randChar).join("");
  };
  var isNumber$1 = function isNumber(d) {
    return typeof d === "number";
  };
  var isArray$1 = function isArray(d) {
    return Array.isArray(d);
  };
  var isObj = function isObj(d) {
    return d !== null && _typeof$1(d) === "object";
  };
  var isNull = function isNull(d) {
    return d == null;
  };
  var isFn$3 = function isFn(d) {
    return typeof d === "function";
  };
  var isInteraction = function isInteraction(ix) {
    if (!isObj(ix) || isNull(ix) || isNumber$1(ix)) return false;

    var _iterator = _createForOfIteratorHelper(KEYS),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var key = _step.value;
        if (!ix.hasOwnProperty(key)) return false;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return true;
  };
  var Ok = function Ok(ix) {
    ix.status = OK;
    return ix;
  };
  var Bad = function Bad(ix, reason) {
    ix.status = BAD;
    ix.reason = reason;
    return ix;
  };

  var makeIx = function makeIx(wat) {
    return function (ix) {
      ix.tag = wat;
      return Ok(ix);
    };
  };

  var prepAccountKeyId = function prepAccountKeyId(acct) {
    if (acct.keyId == null) return acct;
    invariant$1(!isNaN(parseInt(acct.keyId)), "account.keyId must be an integer");
    return _objectSpread2(_objectSpread2({}, acct), {}, {
      keyId: parseInt(acct.keyId)
    });
  };

  var prepAccount = function prepAccount(acct) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (ix) {
      invariant$1(typeof acct === "function" || _typeof$1(acct) === "object", "prepAccount must be passed an authorization function or an account object");
      invariant$1(opts.role != null, "Account must have a role");
      var ACCOUNT = JSON.parse(ACCT);
      var role = opts.role;
      var tempId = uuid();
      if (acct.authorization && isFn$3(acct.authorization)) acct = {
        resolve: acct.authorization
      };
      if (!acct.authorization && isFn$3(acct)) acct = {
        resolve: acct
      };
      var resolve = acct.resolve;
      if (resolve) acct.resolve = function (acct) {
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }

        return [resolve, prepAccountKeyId].reduce( /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(d, fn) {
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.t0 = fn;
                    _context.t1 = void 0;
                    _context.next = 4;
                    return d;

                  case 4:
                    _context.t2 = _context.sent;
                    _context.t3 = [_context.t2].concat(rest);
                    return _context.abrupt("return", _context.t0.apply.call(_context.t0, _context.t1, _context.t3));

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          return function (_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }(), acct);
      };
      acct = prepAccountKeyId(acct);
      ix.accounts[tempId] = _objectSpread2(_objectSpread2(_objectSpread2({}, ACCOUNT), {}, {
        tempId: tempId
      }, acct), {}, {
        role: _objectSpread2(_objectSpread2(_objectSpread2({}, ACCOUNT.role), _typeof$1(acct.role) === "object" ? acct.role : {}), {}, _defineProperty({}, role, true))
      });

      if (role === AUTHORIZER) {
        ix.authorizations.push(tempId);
      } else if (role === PAYER) {
        ix.payer.push(tempId);
      } else {
        ix[role] = tempId;
      }

      return ix;
    };
  };
  var makeArgument = function makeArgument(arg) {
    return function (ix) {
      var tempId = uuid();
      ix.message.arguments.push(tempId);
      ix.arguments[tempId] = JSON.parse(ARG);
      ix.arguments[tempId].tempId = tempId;
      ix.arguments[tempId].value = arg.value;
      ix.arguments[tempId].asArgument = arg.asArgument;
      ix.arguments[tempId].xform = arg.xform;
      ix.arguments[tempId].resolve = arg.resolve;
      ix.arguments[tempId].resolveArgument = isFn$3(arg.resolveArgument) ? arg.resolveArgument.bind(arg) : arg.resolveArgument;
      return Ok(ix);
    };
  };
  var makeUnknown
  /*                 */
  = makeIx(UNKNOWN);
  var makeScript
  /*                  */
  = makeIx(SCRIPT);
  var makeTransaction
  /*             */
  = makeIx(TRANSACTION);
  var makeGetTransactionStatus
  /*    */
  = makeIx(GET_TRANSACTION_STATUS);
  var makeGetTransaction
  /*          */
  = makeIx(GET_TRANSACTION);
  var makeGetAccount
  /*              */
  = makeIx(GET_ACCOUNT);
  var makeGetEvents
  /*               */
  = makeIx(GET_EVENTS);
  var makePing
  /*                    */
  = makeIx(PING);
  var makeGetBlock
  /*                */
  = makeIx(GET_BLOCK);
  var makeGetBlockHeader
  /*          */
  = makeIx(GET_BLOCK_HEADER);
  var makeGetCollection
  /*           */
  = makeIx(GET_COLLECTION);

  var is = function is(wat) {
    return function (ix) {
      return ix.tag === wat;
    };
  };

  var isUnknown
  /*                 */
  = is(UNKNOWN);
  var isScript
  /*                  */
  = is(SCRIPT);
  var isTransaction
  /*             */
  = is(TRANSACTION);
  var isGetTransactionStatus
  /*    */
  = is(GET_TRANSACTION_STATUS);
  var isGetTransaction
  /*          */
  = is(GET_TRANSACTION);
  var isGetAccount
  /*              */
  = is(GET_ACCOUNT);
  var isGetEvents
  /*               */
  = is(GET_EVENTS);
  var isPing
  /*                    */
  = is(PING);
  var isGetBlock
  /*                */
  = is(GET_BLOCK);
  var isGetBlockHeader
  /*          */
  = is(GET_BLOCK_HEADER);
  var isGetCollection
  /*           */
  = is(GET_COLLECTION);
  var isOk
  /*  */
  = function isOk
  /*  */
  (ix) {
    return ix.status === OK;
  };
  var isBad
  /* */
  = function isBad
  /* */
  (ix) {
    return ix.status === BAD;
  };
  var why
  /*   */
  = function why
  /*   */
  (ix) {
    return ix.reason;
  };
  var isAccount
  /*  */
  = function isAccount
  /*  */
  (account) {
    return account.kind === ACCOUNT;
  };
  var isParam
  /*    */
  = function isParam
  /*    */
  (param) {
    return param.kind === PARAM;
  };
  var isArgument
  /* */
  = function isArgument
  /* */
  (argument) {
    return argument.kind === ARGUMENT;
  };

  var hardMode = function hardMode(ix) {
    for (var _i = 0, _Object$keys = Object.keys(ix); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (!KEYS.has(key)) throw new Error("\"".concat(key, "\" is an invalid root level Interaction property."));
    }

    return ix;
  };

  var recPipe = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix) {
      var fns,
          _fns,
          hd,
          rest,
          cur,
          _args2 = arguments;

      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              fns = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : [];
              _context2.prev = 1;
              _context2.t0 = hardMode;
              _context2.next = 5;
              return ix;

            case 5:
              _context2.t1 = _context2.sent;
              ix = (0, _context2.t0)(_context2.t1);

              if (!isBad(ix)) {
                _context2.next = 9;
                break;
              }

              throw new Error("Interaction Error: ".concat(ix.reason));

            case 9:
              if (fns.length) {
                _context2.next = 11;
                break;
              }

              return _context2.abrupt("return", ix);

            case 11:
              _fns = _toArray(fns), hd = _fns[0], rest = _fns.slice(1);
              _context2.next = 14;
              return hd;

            case 14:
              cur = _context2.sent;

              if (!isFn$3(cur)) {
                _context2.next = 17;
                break;
              }

              return _context2.abrupt("return", recPipe(cur(ix), rest));

            case 17:
              if (!(isNull(cur) || !cur)) {
                _context2.next = 19;
                break;
              }

              return _context2.abrupt("return", recPipe(ix, rest));

            case 19:
              if (!isInteraction(cur)) {
                _context2.next = 21;
                break;
              }

              return _context2.abrupt("return", recPipe(cur, rest));

            case 21:
              throw new Error("Invalid Interaction Composition");

            case 24:
              _context2.prev = 24;
              _context2.t2 = _context2["catch"](1);
              throw _context2.t2;

            case 27:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[1, 24]]);
    }));

    return function recPipe(_x3) {
      return _ref2.apply(this, arguments);
    };
  }();

  var pipe = function pipe() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var arg1 = args[0],
        arg2 = args[1];
    if (isArray$1(arg1) && arg2 == null) return function (d) {
      return pipe(d, arg1);
    };
    return recPipe(arg1, arg2);
  };

  var identity$1 = function identity(v) {
    return v;
  };

  var get = function get(ix, key, fallback) {
    return ix.assigns[key] == null ? fallback : ix.assigns[key];
  };
  var put = function put(key, value) {
    return function (ix) {
      ix.assigns[key] = value;
      return Ok(ix);
    };
  };
  var update = function update(key) {
    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;
    return function (ix) {
      ix.assigns[key] = fn(ix.assigns[key], ix);
      return Ok(ix);
    };
  };
  var destroy = function destroy(key) {
    return function (ix) {
      delete ix.assigns[key];
      return Ok(ix);
    };
  };

  var ixModule = /*#__PURE__*/Object.freeze({
    __proto__: null,
    UNKNOWN: UNKNOWN,
    SCRIPT: SCRIPT,
    TRANSACTION: TRANSACTION,
    GET_TRANSACTION_STATUS: GET_TRANSACTION_STATUS,
    GET_ACCOUNT: GET_ACCOUNT,
    GET_EVENTS: GET_EVENTS,
    PING: PING,
    GET_TRANSACTION: GET_TRANSACTION,
    GET_BLOCK: GET_BLOCK,
    GET_BLOCK_HEADER: GET_BLOCK_HEADER,
    GET_COLLECTION: GET_COLLECTION,
    BAD: BAD,
    OK: OK,
    ACCOUNT: ACCOUNT,
    PARAM: PARAM,
    ARGUMENT: ARGUMENT,
    AUTHORIZER: AUTHORIZER,
    PAYER: PAYER,
    PROPOSER: PROPOSER,
    interaction: interaction,
    uuid: uuid,
    isNumber: isNumber$1,
    isArray: isArray$1,
    isObj: isObj,
    isNull: isNull,
    isFn: isFn$3,
    isInteraction: isInteraction,
    Ok: Ok,
    Bad: Bad,
    prepAccount: prepAccount,
    makeArgument: makeArgument,
    makeUnknown: makeUnknown,
    makeScript: makeScript,
    makeTransaction: makeTransaction,
    makeGetTransactionStatus: makeGetTransactionStatus,
    makeGetTransaction: makeGetTransaction,
    makeGetAccount: makeGetAccount,
    makeGetEvents: makeGetEvents,
    makePing: makePing,
    makeGetBlock: makeGetBlock,
    makeGetBlockHeader: makeGetBlockHeader,
    makeGetCollection: makeGetCollection,
    isUnknown: isUnknown,
    isScript: isScript,
    isTransaction: isTransaction,
    isGetTransactionStatus: isGetTransactionStatus,
    isGetTransaction: isGetTransaction,
    isGetAccount: isGetAccount,
    isGetEvents: isGetEvents,
    isPing: isPing,
    isGetBlock: isGetBlock,
    isGetBlockHeader: isGetBlockHeader,
    isGetCollection: isGetCollection,
    isOk: isOk,
    isBad: isBad,
    why: why,
    isAccount: isAccount,
    isParam: isParam,
    isArgument: isArgument,
    pipe: pipe,
    get: get,
    put: put,
    update: update,
    destroy: destroy
  });

  function build() {
    var fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return pipe(interaction(), fns);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  var buffer = {};

  var base64Js = {};

  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  } // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications


  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function getLens(b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    } // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42


    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  } // base64 is 4/3 + up to two characters of the original data


  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;

    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 0xFF;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3
    // go through the array every three bytes, we'll deal with trailing stuff later

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    } // pad the end with zeros, but make sure to not forget the extra bytes


    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }

    return parts.join('');
  }

  var ieee754 = {};

  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

  ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;

    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;

    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }

    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };

  ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);

      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }

      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }

      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;

    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };

  (function (exports) {

    var base64 = base64Js;
    var ieee754$1 = ieee754;
    var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null;
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 0x7fffffff;
    exports.kMaxLength = K_MAX_LENGTH;
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Print warning and recommend using `buffer` v4.x which has an Object
     *               implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * We report that the browser does not support typed arrays if the are not subclassable
     * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
     * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
     * for __proto__ and has a buggy typed array implementation.
     */

    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
    }

    function typedArraySupport() {
      // Can typed array instances can be augmented?
      try {
        var arr = new Uint8Array(1);
        var proto = {
          foo: function foo() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }

    Object.defineProperty(Buffer.prototype, 'parent', {
      enumerable: true,
      get: function get() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer.prototype, 'offset', {
      enumerable: true,
      get: function get() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
      }
    });

    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      } // Return an augmented `Uint8Array` instance


      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */


    function Buffer(arg, encodingOrOffset, length) {
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }

        return allocUnsafe(arg);
      }

      return from(arg, encodingOrOffset, length);
    }

    Buffer.poolSize = 8192; // not used by this implementation

    function from(value, encodingOrOffset, length) {
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset);
      }

      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }

      if (value == null) {
        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof$1(value));
      }

      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }

      if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }

      if (typeof value === 'number') {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }

      var valueOf = value.valueOf && value.valueOf();

      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
      }

      var b = fromObject(value);
      if (b) return b;

      if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
      }

      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof$1(value));
    }
    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/


    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    // https://github.com/feross/buffer/pull/148


    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);

    function assertSize(size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }

    function alloc(size, fill, encoding) {
      assertSize(size);

      if (size <= 0) {
        return createBuffer(size);
      }

      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpreted as a start offset.
        return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }

      return createBuffer(size);
    }
    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/


    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding);
    };

    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */


    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size);
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */


    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size);
    };

    function fromString(string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }

      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual);
      }

      return buf;
    }

    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);

      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }

      return buf;
    }

    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }

      return fromArrayLike(arrayView);
    }

    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }

      var buf;

      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      } // Return an augmented `Uint8Array` instance


      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }

    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);

        if (buf.length === 0) {
          return buf;
        }

        obj.copy(buf, 0, 0, len);
        return buf;
      }

      if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }

        return fromArrayLike(obj);
      }

      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }

    function checked(length) {
      // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
      }

      return length | 0;
    }

    function SlowBuffer(length) {
      if (+length != length) {
        // eslint-disable-line eqeqeq
        length = 0;
      }

      return Buffer.alloc(+length);
    }

    Buffer.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
    };

    Buffer.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }

      if (a === b) return 0;
      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true;

        default:
          return false;
      }
    };

    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      if (list.length === 0) {
        return Buffer.alloc(0);
      }

      var i;

      if (length === undefined) {
        length = 0;

        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;

      for (i = 0; i < list.length; ++i) {
        var buf = list[i];

        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }

        pos += buf.length;
      }

      return buffer;
    };

    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }

      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }

      if (typeof string !== 'string') {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof$1(string));
      }

      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len;

          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length;

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2;

          case 'hex':
            return len >>> 1;

          case 'base64':
            return base64ToBytes(string).length;

          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
            }

            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }

    Buffer.byteLength = byteLength;

    function slowToString(encoding, start, end) {
      var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.
      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

      if (start === undefined || start < 0) {
        start = 0;
      } // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.


      if (start > this.length) {
        return '';
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return '';
      } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.


      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return '';
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end);

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end);

          case 'ascii':
            return asciiSlice(this, start, end);

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end);

          case 'base64':
            return base64Slice(this, start, end);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    // reliably in a browserify context because there could be multiple different
    // copies of the 'buffer' package in use. This method works even for Buffer
    // instances that were created from another copy of the `buffer` package.
    // See: https://github.com/feross/buffer/issues/154


    Buffer.prototype._isBuffer = true;

    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;

      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      }

      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }

      return this;
    };

    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;

      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      }

      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }

      return this;
    };

    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;

      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      }

      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }

      return this;
    };

    Buffer.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0) return '';
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };

    Buffer.prototype.toLocaleString = Buffer.prototype.toString;

    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
      if (this === b) return true;
      return Buffer.compare(this, b) === 0;
    };

    Buffer.prototype.inspect = function inspect() {
      var str = '';
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
      if (this.length > max) str += ' ... ';
      return '<Buffer ' + str + '>';
    };

    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }

    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }

      if (!Buffer.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof$1(target));
      }

      if (start === undefined) {
        start = 0;
      }

      if (end === undefined) {
        end = target ? target.length : 0;
      }

      if (thisStart === undefined) {
        thisStart = 0;
      }

      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }

      if (thisStart >= thisEnd) {
        return -1;
      }

      if (start >= end) {
        return 1;
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf


    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1; // Normalize byteOffset

      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }

      byteOffset = +byteOffset; // Coerce to Number.

      if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : buffer.length - 1;
      } // Normalize byteOffset: negative offsets start from the end of the buffer


      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

      if (byteOffset >= buffer.length) {
        if (dir) return -1;else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;else return -1;
      } // Normalize val


      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      } // Finally, search either indexOf (if dir is true) or lastIndexOf


      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1;
        }

        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]

        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }

        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }

      throw new TypeError('val must be string, number or Buffer');
    }

    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();

        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }

          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read(buf, i) {
        if (indexSize === 1) {
          return buf[i];
        } else {
          return buf.readUInt16BE(i * indexSize);
        }
      }

      var i;

      if (dir) {
        var foundIndex = -1;

        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

        for (i = byteOffset; i >= 0; i--) {
          var found = true;

          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }

          if (found) return i;
        }
      }

      return -1;
    }

    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };

    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };

    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;

      if (!length) {
        length = remaining;
      } else {
        length = Number(length);

        if (length > remaining) {
          length = remaining;
        }
      }

      var strLen = string.length;

      if (length > strLen / 2) {
        length = strLen / 2;
      }

      var i;

      for (i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }

      return i;
    }

    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }

    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }

    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }

    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }

    Buffer.prototype.write = function write(string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0; // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0; // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset >>> 0;

        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
      }

      if (!encoding) encoding = 'utf8';
      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length);

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length);

          case 'ascii':
          case 'latin1':
          case 'binary':
            return asciiWrite(this, string, offset, length);

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };

    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }

    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;

      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte = void 0,
              thirdByte = void 0,
              fourthByte = void 0,
              tempCodePoint = void 0;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }

              break;

            case 2:
              secondByte = buf[i + 1];

              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }

          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res);
    } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety


    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;

      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
      } // Decode in chunks to avoid "call stack size exceeded".


      var res = '';
      var i = 0;

      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }

      return res;
    }

    function asciiSlice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }

      return ret;
    }

    function latin1Slice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }

      return ret;
    }

    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = '';

      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }

      return out;
    }

    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)

      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }

      return res;
    }

    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;
      var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

      Object.setPrototypeOf(newBuf, Buffer.prototype);
      return newBuf;
    };
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */


    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
    }

    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val;
    };

    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;

      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val;
    };

    Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };

    Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };

    Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };

    Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
    };

    Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };

    Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      var first = this[offset];
      var last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
      var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      var first = this[offset];
      var last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
      var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });

    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];

      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return this[offset];
      return (0xff - this[offset] + 1) * -1;
    };

    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };

    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };

    Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      var first = this[offset];
      var last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24); // Overflow

      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
    });
    Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      var first = this[offset];
      var last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      var val = (first << 24) + // Overflow
      this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
    });

    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    };

    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    };

    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
    }

    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };

    Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
      return offset + 2;
    };

    Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
      return offset + 4;
    };

    Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
      return offset + 4;
    };

    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      var lo = Number(value & BigInt(0xffffffff));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }

    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      var lo = Number(value & BigInt(0xffffffff));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }

    Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
    });
    Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
    });

    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
      return offset + 2;
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
      return offset + 4;
    };

    Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
    });
    Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
    });

    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
      if (offset < 0) throw new RangeError('Index out of range');
    }

    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }

      ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };

    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }

      ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
      }

      if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
      if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

      if (end > this.length) end = this.length;

      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;

      if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }

      return len;
    }; // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])


    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }

        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string');
        }

        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }

        if (val.length === 1) {
          var code = val.charCodeAt(0);

          if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
            // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
          }
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      } else if (typeof val === 'boolean') {
        val = Number(val);
      } // Invalid ranges are not set to a default, so can range check early.


      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
      }

      if (end <= start) {
        return this;
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;

      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;

        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }

        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this;
    }; // CUSTOM ERRORS
    // =============
    // Simplified versions from Node, changed for Buffer-only usage


    var errors = {};

    function E(sym, getMessage, Base) {
      errors[sym] = /*#__PURE__*/function (_Base) {
        _inherits(NodeError, _Base);

        var _super = _createSuper(NodeError);

        function NodeError() {
          var _this;

          _classCallCheck(this, NodeError);

          _this = _super.call(this);
          Object.defineProperty(_assertThisInitialized(_this), 'message', {
            value: getMessage.apply(_assertThisInitialized(_this), arguments),
            writable: true,
            configurable: true
          }); // Add the error code to the name to include it in the stack trace.

          _this.name = "".concat(_this.name, " [").concat(sym, "]"); // Access the stack to generate the error message including the error code
          // from the name.

          _this.stack; // eslint-disable-line no-unused-expressions
          // Reset the name to the actual name.

          delete _this.name;
          return _this;
        }

        _createClass(NodeError, [{
          key: "code",
          get: function get() {
            return sym;
          },
          set: function set(value) {
            Object.defineProperty(this, 'code', {
              configurable: true,
              enumerable: true,
              value: value,
              writable: true
            });
          }
        }, {
          key: "toString",
          value: function toString() {
            return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
          }
        }]);

        return NodeError;
      }(Base);
    }

    E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
      if (name) {
        return "".concat(name, " is outside of buffer bounds");
      }

      return 'Attempt to access memory outside buffer bounds';
    }, RangeError);
    E('ERR_INVALID_ARG_TYPE', function (name, actual) {
      return "The \"".concat(name, "\" argument must be of type number. Received type ").concat(_typeof$1(actual));
    }, TypeError);
    E('ERR_OUT_OF_RANGE', function (str, range, input) {
      var msg = "The value of \"".concat(str, "\" is out of range.");
      var received = input;

      if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === 'bigint') {
        received = String(input);

        if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
          received = addNumericalSeparator(received);
        }

        received += 'n';
      }

      msg += " It must be ".concat(range, ". Received ").concat(received);
      return msg;
    }, RangeError);

    function addNumericalSeparator(val) {
      var res = '';
      var i = val.length;
      var start = val[0] === '-' ? 1 : 0;

      for (; i >= start + 4; i -= 3) {
        res = "_".concat(val.slice(i - 3, i)).concat(res);
      }

      return "".concat(val.slice(0, i)).concat(res);
    } // CHECK FUNCTIONS
    // ===============


    function checkBounds(buf, offset, byteLength) {
      validateNumber(offset, 'offset');

      if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1));
      }
    }

    function checkIntBI(value, min, max, buf, offset, byteLength) {
      if (value > max || value < min) {
        var n = typeof min === 'bigint' ? 'n' : '';
        var range;

        if (byteLength > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
          } else {
            range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
          }
        } else {
          range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
        }

        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
      }

      checkBounds(buf, offset, byteLength);
    }

    function validateNumber(value, name) {
      if (typeof value !== 'number') {
        throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
      }
    }

    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
      }

      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }

      throw new errors.ERR_OUT_OF_RANGE(type || 'offset', ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
    } // HELPER FUNCTIONS
    // ================


    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

    function base64clean(str) {
      // Node takes equal signs as end of the Base64 encoding
      str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

      str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

      if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

      while (str.length % 4 !== 0) {
        str = str + '=';
      }

      return str;
    }

    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i); // is surrogate component

        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } // valid lead


            leadSurrogate = codePoint;
            continue;
          } // 2 leads in a row


          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          } // valid surrogate pair


          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null; // encode utf8

        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
          throw new Error('Invalid code point');
        }
      }

      return bytes;
    }

    function asciiToBytes(str) {
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }

      return byteArray;
    }

    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray;
    }

    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }

    function blitBuffer(src, dst, offset, length) {
      var i;

      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }

      return i;
    } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    // the `instanceof` check but they should be treated as of that type.
    // See: https://github.com/feross/buffer/issues/166


    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }

    function numberIsNaN(obj) {
      // For IE11 support
      return obj !== obj; // eslint-disable-line no-self-compare
    } // Create lookup table for `toString('hex')`
    // See: https://github.com/feross/buffer/issues/219


    var hexSliceLookupTable = function () {
      var alphabet = '0123456789abcdef';
      var table = new Array(256);

      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;

        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }

      return table;
    }(); // Return not function with Error if BigInt not supported


    function defineBigIntMethod(fn) {
      return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
    }

    function BufferBigIntNotDefined() {
      throw new Error('BigInt not supported');
    }
  })(buffer);

  /**
   * Built on top of rlp library, removing the BN dependency for the flow.
   * Package : https://github.com/ethereumjs/rlp
   * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE
   *
   * ethereumjs/rlp is licensed under the
   * Mozilla Public License 2.0
   * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.
   **/

  /**
   * @param input - will be converted to buffer
   * @returns returns buffer of encoded data
   **/

  function encode(input) {
    if (Array.isArray(input)) {
      var output = [];

      for (var i = 0; i < input.length; i++) {
        output.push(encode(input[i]));
      }

      var buf = buffer.Buffer.concat(output);
      return buffer.Buffer.concat([encodeLength(buf.length, 192), buf]);
    } else {
      var inputBuf = toBuffer(input);
      return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : buffer.Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
    }
  }

  function encodeLength(len, offset) {
    if (len < 56) {
      return buffer.Buffer.from([len + offset]);
    } else {
      var hexLength = intToHex(len);
      var lLength = hexLength.length / 2;
      var firstByte = intToHex(offset + 55 + lLength);
      return buffer.Buffer.from(firstByte + hexLength, "hex");
    }
  }
  /** Check if a string is prefixed by 0x */


  function isHexPrefixed(str) {
    return str.slice(0, 2) === "0x";
  }
  /** Removes 0x from a given String */


  function stripHexPrefix(str) {
    if (typeof str !== "string") {
      return str;
    }

    return isHexPrefixed(str) ? str.slice(2) : str;
  }
  /** Transform an integer into its hexadecimal value */


  function intToHex(integer) {
    if (integer < 0) {
      throw new Error("Invalid integer as argument, must be unsigned!");
    }

    var hex = integer.toString(16);
    return hex.length % 2 ? "0" + hex : hex;
  }
  /** Pad a string to be even */


  function padToEven(a) {
    return a.length % 2 ? "0" + a : a;
  }
  /** Transform an integer into a Buffer */


  function intToBuffer(integer) {
    var hex = intToHex(integer);
    return buffer.Buffer.from(hex, "hex");
  }
  /** Transform anything into a Buffer */


  function toBuffer(v) {
    if (!buffer.Buffer.isBuffer(v)) {
      if (typeof v === "string") {
        if (isHexPrefixed(v)) {
          return buffer.Buffer.from(padToEven(stripHexPrefix(v)), "hex");
        } else {
          return buffer.Buffer.from(v);
        }
      } else if (typeof v === "number") {
        if (!v) {
          return buffer.Buffer.from([]);
        } else {
          return intToBuffer(v);
        }
      } else if (v === null || v === undefined) {
        return buffer.Buffer.from([]);
      } else if (v instanceof Uint8Array) {
        return buffer.Buffer.from(v);
      } else {
        throw new Error("invalid type");
      }
    }

    return v;
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  var browser = {exports: {}};

  (function (module, exports) {

    var getGlobal = function getGlobal() {
      // the only reliable means to get the global object is
      // `Function('return this')()`
      // However, this causes CSP violations in Chrome apps.
      if (typeof self !== 'undefined') {
        return self;
      }

      if (typeof window !== 'undefined') {
        return window;
      }

      if (typeof global !== 'undefined') {
        return global;
      }

      throw new Error('unable to locate global object');
    };

    var global = getGlobal();
    module.exports = exports = global.fetch; // Needed for TypeScript and Webpack.

    if (global.fetch) {
      exports["default"] = global.fetch.bind(global);
    }

    exports.Headers = global.Headers;
    exports.Request = global.Request;
    exports.Response = global.Response;
  })(browser, browser.exports);

  var fetchTransport = browser.exports;

  function sansPrefix(address) {
    if (address == null) return null;
    return address.replace(/^0x/, "").replace(/^Fx/, "");
  }

  function withPrefix$1(address) {
    if (address == null) return null;
    return "0x" + sansPrefix(address);
  }

  var HTTPRequestError = /*#__PURE__*/function (_Error) {
    _inherits(HTTPRequestError, _Error);

    var _super = _createSuper(HTTPRequestError);

    function HTTPRequestError(_ref) {
      var _this;

      var error = _ref.error,
          hostname = _ref.hostname,
          path = _ref.path,
          method = _ref.method,
          requestBody = _ref.requestBody,
          responseBody = _ref.responseBody,
          responseStatusText = _ref.responseStatusText,
          statusCode = _ref.statusCode;

      _classCallCheck(this, HTTPRequestError);

      var msg = "\n      HTTP Request Error: An error occurred when interacting with the Access API.\n      ".concat(error ? "error=".concat(error) : "", "\n      ").concat(hostname ? "hostname=".concat(hostname) : "", "\n      ").concat(path ? "path=".concat(path) : "", "\n      ").concat(method ? "method=".concat(method) : "", "\n      ").concat(requestBody ? "requestBody=".concat(requestBody) : "", "\n      ").concat(responseBody ? "responseBody=".concat(responseBody) : "", "\n      ").concat(responseStatusText ? "responseStatusText=".concat(responseStatusText) : "", "\n      ").concat(statusCode ? "statusCode=".concat(statusCode) : "", "\n    ");
      _this = _super.call(this, msg);
      _this.name = "HTTP Request Error";
      _this.statusCode = statusCode;
      _this.errorMessage = error;
      return _this;
    }

    return _createClass(HTTPRequestError);
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /**
   * Creates an HTTP Request to be sent to a REST Access API via Fetch API.
   *
   * @param {Object} options - Options for the HTTP Request
   * @param {String} options.hostname - Access API Hostname
   * @param {String} options.path - Path to the resource on the Access API
   * @param {String} options.method - HTTP Method
   * @param {Object} options.body - HTTP Request Body
   * @param {Object | Headers} [options.headers] - HTTP Request Headers
   *
   * @returns JSON object response from Access API.
   */


  function httpRequest(_x) {
    return _httpRequest.apply(this, arguments);
  }

  function _httpRequest() {
    _httpRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(_ref2) {
      var hostname, path, method, body, headers, _ref2$retryLimit, retryLimit, _ref2$retryIntervalMs, retryIntervalMs, bodyJSON, makeRequest, requestLoop, _requestLoop;

      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _requestLoop = function _requestLoop3() {
                _requestLoop = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
                  var retryAttempt,
                      resp,
                      retryStatusCodes,
                      _args3 = arguments;
                  return regenerator.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          retryAttempt = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 0;
                          _context3.prev = 1;
                          _context3.next = 4;
                          return makeRequest();

                        case 4:
                          resp = _context3.sent;
                          return _context3.abrupt("return", resp);

                        case 8:
                          _context3.prev = 8;
                          _context3.t0 = _context3["catch"](1);
                          retryStatusCodes = [408, 429, 500, 502, 503, 504];

                          if (!retryStatusCodes.includes(_context3.t0.statusCode)) {
                            _context3.next = 17;
                            break;
                          }

                          _context3.next = 14;
                          return new Promise(function (resolve, reject) {
                            if (retryAttempt < retryLimit) {
                              console.warn("Access node unavailable, retrying in ".concat(retryIntervalMs, " ms..."));
                              setTimeout(function () {
                                resolve(requestLoop(retryAttempt + 1));
                              }, retryIntervalMs);
                            } else {
                              reject(_context3.t0);
                            }
                          });

                        case 14:
                          return _context3.abrupt("return", _context3.sent);

                        case 17:
                          throw _context3.t0;

                        case 18:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3, null, [[1, 8]]);
                }));
                return _requestLoop.apply(this, arguments);
              };

              requestLoop = function _requestLoop2() {
                return _requestLoop.apply(this, arguments);
              };

              makeRequest = function _makeRequest() {
                return fetchTransport("".concat(hostname).concat(path), {
                  method: method,
                  body: bodyJSON,
                  headers: headers
                }).then( /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(res) {
                    var responseText, response;
                    return regenerator.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (!res.ok) {
                              _context.next = 2;
                              break;
                            }

                            return _context.abrupt("return", res.json());

                          case 2:
                            if (!res.body) {
                              _context.next = 8;
                              break;
                            }

                            _context.next = 5;
                            return res.text();

                          case 5:
                            _context.t0 = _context.sent;
                            _context.next = 9;
                            break;

                          case 8:
                            _context.t0 = null;

                          case 9:
                            responseText = _context.t0;
                            response = safeParseJSON(responseText);
                            throw new HTTPRequestError({
                              error: response === null || response === void 0 ? void 0 : response.message,
                              hostname: hostname,
                              path: path,
                              method: method,
                              requestBody: bodyJSON,
                              responseBody: responseText,
                              responseStatusText: res.statusText,
                              statusCode: res.status
                            });

                          case 12:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x2) {
                    return _ref3.apply(this, arguments);
                  };
                }())["catch"]( /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(e) {
                    return regenerator.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!(e instanceof HTTPRequestError)) {
                              _context2.next = 2;
                              break;
                            }

                            throw e;

                          case 2:
                            _context2.next = 4;
                            return log({
                              title: "Access Node Error",
                              message: "The provided access node ".concat(hostname, " does not appear to be a valid REST/HTTP access node.\nPlease verify that you are not unintentionally using a GRPC access node.\nSee more here: https://docs.onflow.org/fcl/reference/sdk-guidelines/#connect"),
                              level: LEVELS.error
                            });

                          case 4:
                            throw new HTTPRequestError({
                              error: e === null || e === void 0 ? void 0 : e.message,
                              hostname: hostname,
                              path: path,
                              method: method,
                              requestBody: bodyJSON
                            });

                          case 5:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x3) {
                    return _ref4.apply(this, arguments);
                  };
                }());
              };

              hostname = _ref2.hostname, path = _ref2.path, method = _ref2.method, body = _ref2.body, headers = _ref2.headers, _ref2$retryLimit = _ref2.retryLimit, retryLimit = _ref2$retryLimit === void 0 ? 5 : _ref2$retryLimit, _ref2$retryIntervalMs = _ref2.retryIntervalMs, retryIntervalMs = _ref2$retryIntervalMs === void 0 ? 1000 : _ref2$retryIntervalMs;
              bodyJSON = body ? JSON.stringify(body) : null;
              _context4.next = 7;
              return requestLoop();

            case 7:
              return _context4.abrupt("return", _context4.sent);

            case 8:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _httpRequest.apply(this, arguments);
  }

  function safeParseJSON(data) {
    try {
      return JSON.parse(data);
    } catch (_unused) {
      return null;
    }
  }

  function sendExecuteScriptAtBlockIDRequest(_x, _x2, _x3) {
    return _sendExecuteScriptAtBlockIDRequest.apply(this, arguments);
  }

  function _sendExecuteScriptAtBlockIDRequest() {
    _sendExecuteScriptAtBlockIDRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/scripts?block_id=".concat(ix.block.id),
                method: "POST",
                body: {
                  script: context.Buffer.from(ix.message.cadence).toString("base64"),
                  arguments: ix.message.arguments.map(function (arg) {
                    return context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64");
                  })
                }
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse$4(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendExecuteScriptAtBlockIDRequest.apply(this, arguments);
  }

  function sendExecuteScriptAtBlockHeightRequest(_x4, _x5, _x6) {
    return _sendExecuteScriptAtBlockHeightRequest.apply(this, arguments);
  }

  function _sendExecuteScriptAtBlockHeightRequest() {
    _sendExecuteScriptAtBlockHeightRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/scripts?block_height=".concat(ix.block.height),
                method: "POST",
                body: {
                  script: context.Buffer.from(ix.message.cadence).toString("base64"),
                  arguments: ix.message.arguments.map(function (arg) {
                    return context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64");
                  })
                }
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse$4(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendExecuteScriptAtBlockHeightRequest.apply(this, arguments);
  }

  function sendExecuteScriptAtLatestBlockRequest(_x7, _x8, _x9) {
    return _sendExecuteScriptAtLatestBlockRequest.apply(this, arguments);
  }

  function _sendExecuteScriptAtLatestBlockRequest() {
    _sendExecuteScriptAtLatestBlockRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context3.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/scripts?block_height=sealed",
                method: "POST",
                body: {
                  script: context.Buffer.from(ix.message.cadence).toString("base64"),
                  arguments: ix.message.arguments.map(function (arg) {
                    return context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64");
                  })
                }
              });

            case 3:
              res = _context3.sent;
              return _context3.abrupt("return", constructResponse$4(ix, context, res));

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendExecuteScriptAtLatestBlockRequest.apply(this, arguments);
  }

  function constructResponse$4(ix, context, res) {
    var ret = context.response();
    ret.tag = ix.tag;
    ret.encodedData = JSON.parse(context.Buffer.from(res, "base64").toString());
    return ret;
  }

  function sendExecuteScript(_x10) {
    return _sendExecuteScript.apply(this, arguments);
  }

  function _sendExecuteScript() {
    _sendExecuteScript = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ix) {
      var context,
          opts,
          _args4 = arguments;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              context = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
              opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
              invariant$1(opts.node, "SDK Send Execute Script Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Execute Script Error: context.response must be defined.");
              invariant$1(context.Buffer, "SDK Send Execute Script Error: context.Buffer must be defined.");
              _context4.next = 7;
              return ix;

            case 7:
              ix = _context4.sent;

              if (!ix.block.id) {
                _context4.next = 14;
                break;
              }

              _context4.next = 11;
              return sendExecuteScriptAtBlockIDRequest(ix, context, opts);

            case 11:
              return _context4.abrupt("return", _context4.sent);

            case 14:
              if (!ix.block.height) {
                _context4.next = 20;
                break;
              }

              _context4.next = 17;
              return sendExecuteScriptAtBlockHeightRequest(ix, context, opts);

            case 17:
              return _context4.abrupt("return", _context4.sent);

            case 20:
              _context4.next = 22;
              return sendExecuteScriptAtLatestBlockRequest(ix, context, opts);

            case 22:
              return _context4.abrupt("return", _context4.sent);

            case 23:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _sendExecuteScript.apply(this, arguments);
  }

  var HashAlgorithmIDs = {
    SHA2_256: 1,
    SHA2_384: 2,
    SHA3_256: 3,
    SHA3_384: 4,
    KMAC128_BLS_BLS12_381: 5
  };
  var SignatureAlgorithmIDs = {
    ECDSA_P256: 1,
    ECDSA_secp256k1: 2,
    BLS_BLS12_381: 3
  };

  function sendGetAccountAtBlockHeightRequest(_x, _x2, _x3) {
    return _sendGetAccountAtBlockHeightRequest.apply(this, arguments);
  }

  function _sendGetAccountAtBlockHeightRequest() {
    _sendGetAccountAtBlockHeightRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/accounts/".concat(ix.account.addr, "?block_height=").concat(ix.block.height, "&expand=contracts,keys"),
                method: "GET",
                body: null
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse$3(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetAccountAtBlockHeightRequest.apply(this, arguments);
  }

  function sendGetAccountAtLatestBlockRequest(_x4, _x5, _x6) {
    return _sendGetAccountAtLatestBlockRequest.apply(this, arguments);
  }

  function _sendGetAccountAtLatestBlockRequest() {
    _sendGetAccountAtLatestBlockRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/accounts/".concat(ix.account.addr, "?block_height=sealed&expand=contracts,keys"),
                method: "GET",
                body: null
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse$3(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendGetAccountAtLatestBlockRequest.apply(this, arguments);
  }

  function constructResponse$3(ix, context, res) {
    var _res$keys$map, _res$keys;

    var ret = context.response();
    ret.tag = ix.tag;

    var unwrapContracts = function unwrapContracts(contracts) {
      var c = {};
      if (!contracts) return c;

      for (var _i = 0, _Object$keys = Object.keys(contracts); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        c[key] = context.Buffer.from(contracts[key], "base64").toString();
      }

      return c;
    };

    ret.account = {
      address: res.address,
      balance: Number(res.balance),
      code: "",
      contracts: unwrapContracts(res.contracts),
      keys: (_res$keys$map = (_res$keys = res.keys) === null || _res$keys === void 0 ? void 0 : _res$keys.map(function (key) {
        return {
          index: Number(key.index),
          publicKey: key.public_key.replace(/^0x/, ""),
          signAlgo: SignatureAlgorithmIDs[key.signing_algorithm],
          signAlgoString: key.signing_algorithm,
          hashAlgo: HashAlgorithmIDs[key.hashing_algorithm],
          hashAlgoString: key.hashing_algorithm,
          sequenceNumber: Number(key.sequence_number),
          weight: Number(key.weight),
          revoked: key.revoked
        };
      })) !== null && _res$keys$map !== void 0 ? _res$keys$map : []
    };
    return ret;
  }

  function sendGetAccount(_x7) {
    return _sendGetAccount.apply(this, arguments);
  }

  function _sendGetAccount() {
    _sendGetAccount = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix) {
      var context,
          opts,
          _args3 = arguments;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              context = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
              opts = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
              invariant$1(opts.node, "SDK Send Get Account Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Account Error: context.response must be defined.");
              invariant$1(context.Buffer, "SDK Send Get Account Error: context.Buffer must be defined.");
              _context3.next = 7;
              return ix;

            case 7:
              ix = _context3.sent;

              if (!(ix.block.height !== null)) {
                _context3.next = 14;
                break;
              }

              _context3.next = 11;
              return sendGetAccountAtBlockHeightRequest(ix, context, opts);

            case 11:
              return _context3.abrupt("return", _context3.sent);

            case 14:
              _context3.next = 16;
              return sendGetAccountAtLatestBlockRequest(ix, context, opts);

            case 16:
              return _context3.abrupt("return", _context3.sent);

            case 17:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendGetAccount.apply(this, arguments);
  }

  function sendGetBlockHeaderByIDRequest(_x, _x2, _x3) {
    return _sendGetBlockHeaderByIDRequest.apply(this, arguments);
  }

  function _sendGetBlockHeaderByIDRequest() {
    _sendGetBlockHeaderByIDRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks/".concat(ix.block.id),
                method: "GET",
                body: null
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse$2(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetBlockHeaderByIDRequest.apply(this, arguments);
  }

  function sendGetBlockHeaderByHeightRequest(_x4, _x5, _x6) {
    return _sendGetBlockHeaderByHeightRequest.apply(this, arguments);
  }

  function _sendGetBlockHeaderByHeightRequest() {
    _sendGetBlockHeaderByHeightRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=".concat(ix.block.height),
                method: "GET",
                body: null
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse$2(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendGetBlockHeaderByHeightRequest.apply(this, arguments);
  }

  function sendGetLatestBlockHeaderRequest(_x7, _x8, _x9) {
    return _sendGetLatestBlockHeaderRequest.apply(this, arguments);
  }

  function _sendGetLatestBlockHeaderRequest() {
    _sendGetLatestBlockHeaderRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix, context, opts) {
      var _ix$block;

      var httpRequest$1, height, res;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              height = (_ix$block = ix.block) !== null && _ix$block !== void 0 && _ix$block.isSealed ? "sealed" : "finalized";
              _context3.next = 4;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=".concat(height),
                method: "GET",
                body: null
              });

            case 4:
              res = _context3.sent;
              return _context3.abrupt("return", constructResponse$2(ix, context, res));

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendGetLatestBlockHeaderRequest.apply(this, arguments);
  }

  function constructResponse$2(ix, context, res) {
    var block = res.length ? res[0] : null;
    var ret = context.response();
    ret.tag = ix.tag;
    ret.blockHeader = {
      id: block.header.id,
      parentId: block.header.parent_id,
      height: Number(block.header.height),
      timestamp: block.header.timestamp
    };
    return ret;
  }

  function sendGetBlockHeader(_x10) {
    return _sendGetBlockHeader.apply(this, arguments);
  }

  function _sendGetBlockHeader() {
    _sendGetBlockHeader = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ix) {
      var context,
          opts,
          interactionHasBlockID,
          interactionHasBlockHeight,
          _args4 = arguments;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              context = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
              opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
              invariant$1(opts.node, "SDK Send Get Block Header Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Block Header Error: context.response must be defined.");
              _context4.next = 6;
              return ix;

            case 6:
              ix = _context4.sent;
              interactionHasBlockID = ix.block.id !== null;
              interactionHasBlockHeight = ix.block.height !== null;

              if (!interactionHasBlockID) {
                _context4.next = 15;
                break;
              }

              _context4.next = 12;
              return sendGetBlockHeaderByIDRequest(ix, context, opts);

            case 12:
              return _context4.abrupt("return", _context4.sent);

            case 15:
              if (!interactionHasBlockHeight) {
                _context4.next = 21;
                break;
              }

              _context4.next = 18;
              return sendGetBlockHeaderByHeightRequest(ix, context, opts);

            case 18:
              return _context4.abrupt("return", _context4.sent);

            case 21:
              _context4.next = 23;
              return sendGetLatestBlockHeaderRequest(ix, context, opts);

            case 23:
              return _context4.abrupt("return", _context4.sent);

            case 24:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _sendGetBlockHeader.apply(this, arguments);
  }

  function sendGetBlockByIDRequest(_x, _x2, _x3) {
    return _sendGetBlockByIDRequest.apply(this, arguments);
  }

  function _sendGetBlockByIDRequest() {
    _sendGetBlockByIDRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks/".concat(ix.block.id, "?expand=payload"),
                method: "GET",
                body: null
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse$1(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetBlockByIDRequest.apply(this, arguments);
  }

  function sendGetBlockByHeightRequest(_x4, _x5, _x6) {
    return _sendGetBlockByHeightRequest.apply(this, arguments);
  }

  function _sendGetBlockByHeightRequest() {
    _sendGetBlockByHeightRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=".concat(ix.block.height, "&expand=payload"),
                method: "GET",
                body: null
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse$1(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendGetBlockByHeightRequest.apply(this, arguments);
  }

  function sendGetBlockRequest(_x7, _x8, _x9) {
    return _sendGetBlockRequest.apply(this, arguments);
  }

  function _sendGetBlockRequest() {
    _sendGetBlockRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix, context, opts) {
      var _ix$block;

      var httpRequest$1, height, res;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              height = (_ix$block = ix.block) !== null && _ix$block !== void 0 && _ix$block.isSealed ? "sealed" : "final";
              _context3.next = 4;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=".concat(height, "&expand=payload"),
                method: "GET",
                body: null
              });

            case 4:
              res = _context3.sent;
              return _context3.abrupt("return", constructResponse$1(ix, context, res));

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendGetBlockRequest.apply(this, arguments);
  }

  function constructResponse$1(ix, context, res) {
    var block = res.length ? res[0] : null;
    var ret = context.response();
    ret.tag = ix.tag;
    ret.block = {
      id: block.header.id,
      parentId: block.header.parent_id,
      height: Number(block.header.height),
      timestamp: block.header.timestamp,
      collectionGuarantees: block.payload.collection_guarantees.map(function (collectionGuarantee) {
        return {
          collectionId: collectionGuarantee.collection_id,
          signerIds: collectionGuarantee.signer_ids
        };
      }),
      blockSeals: block.payload.block_seals.map(function (blockSeal) {
        return {
          blockId: blockSeal.block_id,
          executionReceiptId: blockSeal.result_id
        };
      })
    };
    return ret;
  }

  function sendGetBlock(_x10) {
    return _sendGetBlock.apply(this, arguments);
  }

  function _sendGetBlock() {
    _sendGetBlock = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ix) {
      var context,
          opts,
          interactionHasBlockID,
          interactionHasBlockHeight,
          _args4 = arguments;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              context = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
              opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
              invariant$1(opts.node, "SDK Send Get Block Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Block Error: context.response must be defined.");
              _context4.next = 6;
              return ix;

            case 6:
              ix = _context4.sent;
              interactionHasBlockID = ix.block.id !== null;
              interactionHasBlockHeight = ix.block.height !== null;

              if (!interactionHasBlockID) {
                _context4.next = 15;
                break;
              }

              _context4.next = 12;
              return sendGetBlockByIDRequest(ix, context, opts);

            case 12:
              return _context4.abrupt("return", _context4.sent);

            case 15:
              if (!interactionHasBlockHeight) {
                _context4.next = 21;
                break;
              }

              _context4.next = 18;
              return sendGetBlockByHeightRequest(ix, context, opts);

            case 18:
              return _context4.abrupt("return", _context4.sent);

            case 21:
              _context4.next = 23;
              return sendGetBlockRequest(ix, context, opts);

            case 23:
              return _context4.abrupt("return", _context4.sent);

            case 24:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _sendGetBlock.apply(this, arguments);
  }

  function sendGetCollection(_x) {
    return _sendGetCollection.apply(this, arguments);
  }

  function _sendGetCollection() {
    _sendGetCollection = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          res,
          ret,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant$1(opts.node, "SDK Send Get Collection Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Collection Error: context.response must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 7;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/collections/".concat(ix.collection.id, "?expand=transactions"),
                method: "GET",
                body: null
              });

            case 7:
              res = _context.sent;
              ret = context.response();
              ret.tag = ix.tag;
              ret.collection = {
                id: res.id,
                transactionIds: res.transactions.map(function (transaction) {
                  return transaction.id;
                })
              };
              return _context.abrupt("return", ret);

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetCollection.apply(this, arguments);
  }

  function sendGetEventsForHeightRangeRequest(_x, _x2, _x3) {
    return _sendGetEventsForHeightRangeRequest.apply(this, arguments);
  }

  function _sendGetEventsForHeightRangeRequest() {
    _sendGetEventsForHeightRangeRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/events?type=".concat(ix.events.eventType, "&start_height=").concat(ix.events.start, "&end_height=").concat(ix.events.end),
                method: "GET",
                body: null
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetEventsForHeightRangeRequest.apply(this, arguments);
  }

  function sendGetEventsForBlockIDsRequest(_x4, _x5, _x6) {
    return _sendGetEventsForBlockIDsRequest.apply(this, arguments);
  }

  function _sendGetEventsForBlockIDsRequest() {
    _sendGetEventsForBlockIDsRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/events?type=".concat(ix.events.eventType, "&block_ids=").concat(ix.events.blockIds.join(",")),
                method: "GET",
                body: null
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendGetEventsForBlockIDsRequest.apply(this, arguments);
  }

  function constructResponse(ix, context, res) {
    var ret = context.response();
    ret.tag = ix.tag;
    ret.events = [];
    res.forEach(function (block) {
      return block.events ? block.events.forEach(function (event) {
        return ret.events.push({
          blockId: block.block_id,
          blockHeight: Number(block.block_height),
          blockTimestamp: block.block_timestamp,
          type: event.type,
          transactionId: event.transaction_id,
          transactionIndex: Number(event.transaction_index),
          eventIndex: Number(event.event_index),
          payload: JSON.parse(context.Buffer.from(event.payload, "base64").toString())
        });
      }) : null;
    });
    return ret;
  }

  function sendGetEvents(_x7) {
    return _sendGetEvents.apply(this, arguments);
  }

  function _sendGetEvents() {
    _sendGetEvents = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix) {
      var context,
          opts,
          interactionContainsBlockHeightRange,
          interactionContainsBlockIDsList,
          _args3 = arguments;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              context = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
              opts = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
              invariant$1(opts.node, "SDK Send Get Events Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Events Error: context.response must be defined.");
              invariant$1(context.Buffer, "SDK Send Get Events Error: context.Buffer must be defined.");
              _context3.next = 7;
              return ix;

            case 7:
              ix = _context3.sent;
              interactionContainsBlockHeightRange = ix.events.start !== null;
              interactionContainsBlockIDsList = Array.isArray(ix.events.blockIds) && ix.events.blockIds.length > 0;
              invariant$1(interactionContainsBlockHeightRange || interactionContainsBlockIDsList, "SendGetEventsError: Unable to determine which get events request to send. Either a block height range, or block IDs must be specified.");

              if (!interactionContainsBlockHeightRange) {
                _context3.next = 17;
                break;
              }

              _context3.next = 14;
              return sendGetEventsForHeightRangeRequest(ix, context, opts);

            case 14:
              return _context3.abrupt("return", _context3.sent);

            case 17:
              _context3.next = 19;
              return sendGetEventsForBlockIDsRequest(ix, context, opts);

            case 19:
              return _context3.abrupt("return", _context3.sent);

            case 20:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendGetEvents.apply(this, arguments);
  }

  function sendGetTransaction(_x) {
    return _sendGetTransaction.apply(this, arguments);
  }

  function _sendGetTransaction() {
    _sendGetTransaction = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          res,
          unwrapKey,
          unwrapSignature,
          unwrapArg,
          ret,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant$1(opts.node, "SDK Send Get Transaction Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Transaction Error: context.response must be defined.");
              invariant$1(context.Buffer, "SDK Send Get Transaction Error: context.Buffer must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 8;
              return ix;

            case 8:
              ix = _context.sent;
              _context.next = 11;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/transactions/".concat(ix.transaction.id),
                method: "GET",
                body: null
              });

            case 11:
              res = _context.sent;

              unwrapKey = function unwrapKey(key) {
                return {
                  address: key.address,
                  keyId: Number(key.key_id),
                  sequenceNumber: Number(key.sequence_number)
                };
              };

              unwrapSignature = function unwrapSignature(sig) {
                return {
                  address: sig.address,
                  keyId: Number(sig.key_index),
                  signature: sig.signature
                };
              };

              unwrapArg = function unwrapArg(arg) {
                return JSON.parse(context.Buffer.from(arg, "base64").toString());
              };

              ret = context.response();
              ret.tag = ix.tag;
              ret.transaction = {
                script: context.Buffer.from(res.script, "base64").toString(),
                args: _toConsumableArray(res.arguments.map(unwrapArg)),
                referenceBlockId: res.reference_block_id,
                gasLimit: Number(res.gas_limit),
                payer: res.payer,
                proposalKey: res.proposal_key ? unwrapKey(res.proposal_key) : res.proposal_key,
                authorizers: res.authorizers,
                payloadSignatures: _toConsumableArray(res.payload_signatures.map(unwrapSignature)),
                envelopeSignatures: _toConsumableArray(res.envelope_signatures.map(unwrapSignature))
              };
              return _context.abrupt("return", ret);

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetTransaction.apply(this, arguments);
  }

  var STATUS_MAP = {
    UNKNOWN: 0,
    PENDING: 1,
    FINALIZED: 2,
    EXECUTED: 3,
    SEALED: 4,
    EXPIRED: 5
  };

  function sendGetTransactionStatus(_x) {
    return _sendGetTransactionStatus.apply(this, arguments);
  }

  function _sendGetTransactionStatus() {
    _sendGetTransactionStatus = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          res,
          ret,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant$1(opts.node, "SDK Send Get Transaction Status Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Transaction Status Error: context.response must be defined.");
              invariant$1(context.Buffer, "SDK Send Get Transaction Status Error: context.Buffer must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 8;
              return ix;

            case 8:
              ix = _context.sent;
              _context.next = 11;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/transaction_results/".concat(ix.transaction.id),
                method: "GET",
                body: null
              });

            case 11:
              res = _context.sent;
              ret = context.response();
              ret.tag = ix.tag;
              ret.transactionStatus = {
                blockId: res.block_id,
                status: STATUS_MAP[res.status.toUpperCase()] || "",
                statusString: res.status.toUpperCase(),
                statusCode: res.status_code,
                errorMessage: res.error_message,
                events: res.events.map(function (event) {
                  return {
                    type: event.type,
                    transactionId: event.transaction_id,
                    transactionIndex: Number(event.transaction_index),
                    eventIndex: Number(event.event_index),
                    payload: JSON.parse(context.Buffer.from(event.payload, "base64").toString())
                  };
                })
              };
              return _context.abrupt("return", ret);

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetTransactionStatus.apply(this, arguments);
  }

  function sendPing(_x) {
    return _sendPing.apply(this, arguments);
  }

  function _sendPing() {
    _sendPing = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          ret,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant$1(opts.node, "SDK Send Ping Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Ping Error: context.response must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 7;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=sealed",
                method: "GET",
                body: null
              });

            case 7:
              ret = context.response();
              ret.tag = ix.tag;
              return _context.abrupt("return", ret);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendPing.apply(this, arguments);
  }

  var idof$2 = function idof(acct) {
    return "".concat(withPrefix(acct.addr), "-").concat(acct.keyId);
  };

  function sendTransaction(_x) {
    return _sendTransaction.apply(this, arguments);
  }

  function _sendTransaction() {
    _sendTransaction = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          payloadSignatures,
          _i,
          _Object$values,
          acct,
          envelopeSignatures,
          _i2,
          _Object$values2,
          _acct,
          id,
          t1,
          res,
          t2,
          ret,
          _args = arguments;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant$1(opts.node, "SDK Send Transaction Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Transaction Error: context.response must be defined.");
              invariant$1(context.Buffer, "SDK Send Transaction Error: context.Buffer must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 8;
              return ix;

            case 8:
              ix = _context.sent; // Apply Non Payer Signatures to Payload Signatures

              payloadSignatures = [];
              _i = 0, _Object$values = Object.values(ix.accounts);

            case 11:
              if (!(_i < _Object$values.length)) {
                _context.next = 24;
                break;
              }

              acct = _Object$values[_i];
              _context.prev = 13;

              if (!acct.role.payer && acct.signature != null) {
                payloadSignatures.push({
                  address: sansPrefix(acct.addr),
                  key_index: String(acct.keyId),
                  signature: context.Buffer.from(acct.signature, "hex").toString("base64")
                });
              }

              _context.next = 21;
              break;

            case 17:
              _context.prev = 17;
              _context.t0 = _context["catch"](13);
              console.error("SDK HTTP Send Error: Trouble applying payload signature", {
                acct: acct,
                ix: ix
              });
              throw _context.t0;

            case 21:
              _i++;
              _context.next = 11;
              break;

            case 24:
              // Apply Payer Signatures to Envelope Signatures
              envelopeSignatures = {};
              _i2 = 0, _Object$values2 = Object.values(ix.accounts);

            case 26:
              if (!(_i2 < _Object$values2.length)) {
                _context.next = 39;
                break;
              }

              _acct = _Object$values2[_i2];
              _context.prev = 28;

              if (_acct.role.payer && _acct.signature != null) {
                id = _acct.tempId || idof$2(_acct);
                envelopeSignatures[id] = envelopeSignatures[id] || {
                  address: sansPrefix(_acct.addr),
                  key_index: String(_acct.keyId),
                  signature: context.Buffer.from(_acct.signature, "hex").toString("base64")
                };
              }

              _context.next = 36;
              break;

            case 32:
              _context.prev = 32;
              _context.t1 = _context["catch"](28);
              console.error("SDK HTTP Send Error: Trouble applying envelope signature", {
                acct: _acct,
                ix: ix
              });
              throw _context.t1;

            case 36:
              _i2++;
              _context.next = 26;
              break;

            case 39:
              envelopeSignatures = Object.values(envelopeSignatures);
              t1 = Date.now();
              _context.next = 43;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/transactions",
                method: "POST",
                body: {
                  script: context.Buffer.from(ix.message.cadence).toString("base64"),
                  arguments: _toConsumableArray(ix.message.arguments.map(function (arg) {
                    return context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64");
                  })),
                  reference_block_id: ix.message.refBlock ? ix.message.refBlock : null,
                  gas_limit: String(ix.message.computeLimit),
                  payer: sansPrefix(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
                  proposal_key: {
                    address: sansPrefix(ix.accounts[ix.proposer].addr),
                    key_index: String(ix.accounts[ix.proposer].keyId),
                    sequence_number: String(ix.accounts[ix.proposer].sequenceNum)
                  },
                  authorizers: ix.authorizations.map(function (tempId) {
                    return ix.accounts[tempId].addr;
                  }).reduce(function (prev, current) {
                    return prev.find(function (item) {
                      return item === current;
                    }) ? prev : [].concat(_toConsumableArray(prev), [current]);
                  }, []).map(sansPrefix),
                  payload_signatures: payloadSignatures,
                  envelope_signatures: envelopeSignatures
                }
              });

            case 43:
              res = _context.sent;
              t2 = Date.now();
              ret = context.response();
              ret.tag = ix.tag;
              ret.transactionId = res.id;

              if (typeof window !== "undefined") {
                window.dispatchEvent(new CustomEvent("FLOW::TX", {
                  detail: {
                    txId: ret.transactionId,
                    delta: t2 - t1
                  }
                }));
              }

              return _context.abrupt("return", ret);

            case 50:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[13, 17], [28, 32]]);
    }));
    return _sendTransaction.apply(this, arguments);
  }

  var send$1 = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant$1(opts.node, "SDK Send Error: Either opts.node or \"accessNode.api\" in config must be defined.");
              invariant$1(context.ix, "SDK Send Error: context.ix must be defined.");
              _context.next = 6;
              return ix;

            case 6:
              ix = _context.sent;
              _context.t0 = true;
              _context.next = _context.t0 === context.ix.isTransaction(ix) ? 10 : _context.t0 === context.ix.isGetTransactionStatus(ix) ? 11 : _context.t0 === context.ix.isGetTransaction(ix) ? 12 : _context.t0 === context.ix.isScript(ix) ? 13 : _context.t0 === context.ix.isGetAccount(ix) ? 14 : _context.t0 === context.ix.isGetEvents(ix) ? 15 : _context.t0 === context.ix.isGetBlock(ix) ? 16 : _context.t0 === context.ix.isGetBlockHeader(ix) ? 17 : _context.t0 === context.ix.isGetCollection(ix) ? 18 : _context.t0 === context.ix.isPing(ix) ? 19 : 20;
              break;

            case 10:
              return _context.abrupt("return", opts.sendTransaction ? opts.sendTransaction(ix, context, opts) : sendTransaction(ix, context, opts));

            case 11:
              return _context.abrupt("return", opts.sendGetTransactionStatus ? opts.sendGetTransactionStatus(ix, context, opts) : sendGetTransactionStatus(ix, context, opts));

            case 12:
              return _context.abrupt("return", opts.sendGetTransaction ? opts.sendGetTransaction(ix, context, opts) : sendGetTransaction(ix, context, opts));

            case 13:
              return _context.abrupt("return", opts.sendExecuteScript ? opts.sendExecuteScript(ix, context, opts) : sendExecuteScript(ix, context, opts));

            case 14:
              return _context.abrupt("return", opts.sendGetAccount ? opts.sendGetAccount(ix, context, opts) : sendGetAccount(ix, context, opts));

            case 15:
              return _context.abrupt("return", opts.sendGetEvents ? opts.sendGetEvents(ix, context, opts) : sendGetEvents(ix, context, opts));

            case 16:
              return _context.abrupt("return", opts.sendGetBlock ? opts.sendGetBlock(ix, context, opts) : sendGetBlock(ix, context, opts));

            case 17:
              return _context.abrupt("return", opts.sendGetBlockHeader ? opts.sendGetBlockHeader(ix, context, opts) : sendGetBlockHeader(ix, context, opts));

            case 18:
              return _context.abrupt("return", opts.sendGetCollection ? opts.sendGetCollection(ix, context, opts) : sendGetCollection(ix, context, opts));

            case 19:
              return _context.abrupt("return", opts.sendPing ? opts.sendPing(ix, context, opts) : sendPing(ix, context, opts));

            case 20:
              return _context.abrupt("return", ix);

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function send(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  var DEFAULT_RESPONSE = "{\n    \"tag\":null,\n    \"transaction\":null,\n    \"transactionStatus\":null,\n    \"transactionId\":null,\n    \"encodedData\":null,\n    \"events\":null,\n    \"account\":null,\n    \"block\":null,\n    \"blockHeader\":null,\n    \"latestBlock\":null,\n    \"collection\":null\n}";
  var response = function response() {
    return JSON.parse(DEFAULT_RESPONSE);
  };

  function getBlock() {
    var isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return pipe([makeGetBlock, function (ix) {
      ix.block.isSealed = isSealed;
      return Ok(ix);
    }]);
  }

  function getAccount(addr) {
    return pipe([makeGetAccount, function (ix) {
      ix.account.addr = sansPrefix(addr);
      return Ok(ix);
    }]);
  }

  var latestBlockDeprecationNotice = function latestBlockDeprecationNotice() {
    log.deprecate({
      pkg: "@onflow/decode",
      subject: "Operating upon data of the latestBlock field of the response object",
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field"
    });
  };

  var decodeImplicit = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(i) {
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", i);

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function decodeImplicit(_x4) {
      return _ref2.apply(this, arguments);
    };
  }();

  var decodeVoid = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", null);

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function decodeVoid() {
      return _ref3.apply(this, arguments);
    };
  }();

  var decodeType = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(type) {
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", type.staticType);

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function decodeType(_x5) {
      return _ref4.apply(this, arguments);
    };
  }();

  var decodePath = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(path) {
      return regenerator.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", {
                domain: path.domain,
                identifier: path.identifier
              });

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function decodePath(_x6) {
      return _ref5.apply(this, arguments);
    };
  }();

  var decodeCapability = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(cap) {
      return regenerator.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", {
                path: cap.path,
                address: cap.address,
                borrowType: cap.borrowType
              });

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function decodeCapability(_x7) {
      return _ref6.apply(this, arguments);
    };
  }();

  var decodeOptional = /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7(optional, decoders, stack) {
      return regenerator.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!optional) {
                _context7.next = 6;
                break;
              }

              _context7.next = 3;
              return recurseDecode(optional, decoders, stack);

            case 3:
              _context7.t0 = _context7.sent;
              _context7.next = 7;
              break;

            case 6:
              _context7.t0 = null;

            case 7:
              return _context7.abrupt("return", _context7.t0);

            case 8:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    return function decodeOptional(_x8, _x9, _x10) {
      return _ref7.apply(this, arguments);
    };
  }();

  var decodeReference = /*#__PURE__*/function () {
    var _ref8 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8(v) {
      return regenerator.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              return _context8.abrupt("return", {
                address: v.address,
                type: v.type
              });

            case 1:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));

    return function decodeReference(_x11) {
      return _ref8.apply(this, arguments);
    };
  }();

  var decodeArray = /*#__PURE__*/function () {
    var _ref9 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10(array, decoders, stack) {
      return regenerator.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return Promise.all(array.map(function (v) {
                return new Promise( /*#__PURE__*/function () {
                  var _ref10 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9(res) {
                    return regenerator.wrap(function _callee9$(_context9) {
                      while (1) {
                        switch (_context9.prev = _context9.next) {
                          case 0:
                            _context9.t0 = res;
                            _context9.next = 3;
                            return recurseDecode(v, decoders, [].concat(_toConsumableArray(stack), [v.type]));

                          case 3:
                            _context9.t1 = _context9.sent;
                            return _context9.abrupt("return", (0, _context9.t0)(_context9.t1));

                          case 5:
                          case "end":
                            return _context9.stop();
                        }
                      }
                    }, _callee9);
                  }));

                  return function (_x15) {
                    return _ref10.apply(this, arguments);
                  };
                }());
              }));

            case 2:
              return _context10.abrupt("return", _context10.sent);

            case 3:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }));

    return function decodeArray(_x12, _x13, _x14) {
      return _ref9.apply(this, arguments);
    };
  }();

  var decodeDictionary = /*#__PURE__*/function () {
    var _ref11 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12(dictionary, decoders, stack) {
      return regenerator.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return dictionary.reduce( /*#__PURE__*/function () {
                var _ref12 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11(acc, v) {
                  return regenerator.wrap(function _callee11$(_context11) {
                    while (1) {
                      switch (_context11.prev = _context11.next) {
                        case 0:
                          _context11.next = 2;
                          return acc;

                        case 2:
                          acc = _context11.sent;
                          _context11.next = 5;
                          return recurseDecode(v.key, decoders, [].concat(_toConsumableArray(stack), [v.key]));

                        case 5:
                          _context11.t0 = _context11.sent;
                          _context11.next = 8;
                          return recurseDecode(v.value, decoders, [].concat(_toConsumableArray(stack), [v.key]));

                        case 8:
                          acc[_context11.t0] = _context11.sent;
                          return _context11.abrupt("return", acc);

                        case 10:
                        case "end":
                          return _context11.stop();
                      }
                    }
                  }, _callee11);
                }));

                return function (_x19, _x20) {
                  return _ref12.apply(this, arguments);
                };
              }(), Promise.resolve({}));

            case 2:
              return _context12.abrupt("return", _context12.sent);

            case 3:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));

    return function decodeDictionary(_x16, _x17, _x18) {
      return _ref11.apply(this, arguments);
    };
  }();

  var decodeComposite = /*#__PURE__*/function () {
    var _ref13 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee14(composite, decoders, stack) {
      var decoded, decoder;
      return regenerator.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return composite.fields.reduce( /*#__PURE__*/function () {
                var _ref14 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee13(acc, v) {
                  return regenerator.wrap(function _callee13$(_context13) {
                    while (1) {
                      switch (_context13.prev = _context13.next) {
                        case 0:
                          _context13.next = 2;
                          return acc;

                        case 2:
                          acc = _context13.sent;
                          _context13.next = 5;
                          return recurseDecode(v.value, decoders, [].concat(_toConsumableArray(stack), [v.name]));

                        case 5:
                          acc[v.name] = _context13.sent;
                          return _context13.abrupt("return", acc);

                        case 7:
                        case "end":
                          return _context13.stop();
                      }
                    }
                  }, _callee13);
                }));

                return function (_x24, _x25) {
                  return _ref14.apply(this, arguments);
                };
              }(), Promise.resolve({}));

            case 2:
              decoded = _context14.sent;
              decoder = composite.id && decoderLookup(decoders, composite.id);

              if (!decoder) {
                _context14.next = 10;
                break;
              }

              _context14.next = 7;
              return decoder(decoded);

            case 7:
              _context14.t0 = _context14.sent;
              _context14.next = 11;
              break;

            case 10:
              _context14.t0 = decoded;

            case 11:
              return _context14.abrupt("return", _context14.t0);

            case 12:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14);
    }));

    return function decodeComposite(_x21, _x22, _x23) {
      return _ref13.apply(this, arguments);
    };
  }();

  var defaultDecoders = {
    UInt: decodeImplicit,
    Int: decodeImplicit,
    UInt8: decodeImplicit,
    Int8: decodeImplicit,
    UInt16: decodeImplicit,
    Int16: decodeImplicit,
    UInt32: decodeImplicit,
    Int32: decodeImplicit,
    UInt64: decodeImplicit,
    Int64: decodeImplicit,
    UInt128: decodeImplicit,
    Int128: decodeImplicit,
    UInt256: decodeImplicit,
    Int256: decodeImplicit,
    Word8: decodeImplicit,
    Word16: decodeImplicit,
    Word32: decodeImplicit,
    Word64: decodeImplicit,
    UFix64: decodeImplicit,
    Fix64: decodeImplicit,
    String: decodeImplicit,
    Character: decodeImplicit,
    Bool: decodeImplicit,
    Address: decodeImplicit,
    Void: decodeVoid,
    Optional: decodeOptional,
    Reference: decodeReference,
    Array: decodeArray,
    Dictionary: decodeDictionary,
    Event: decodeComposite,
    Resource: decodeComposite,
    Struct: decodeComposite,
    Enum: decodeComposite,
    Type: decodeType,
    Path: decodePath,
    Capability: decodeCapability
  };

  var decoderLookup = function decoderLookup(decoders, lookup) {
    var found = Object.keys(decoders).find(function (decoder) {
      if (/^\/.*\/$/.test(decoder)) {
        var reg = new RegExp(decoder.substring(1, decoder.length - 1));
        return reg.test(lookup);
      }

      return decoder === lookup;
    });
    return lookup && found && decoders[found];
  };

  var recurseDecode = /*#__PURE__*/function () {
    var _ref15 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee15(decodeInstructions, decoders, stack) {
      var decoder;
      return regenerator.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              decoder = decoderLookup(decoders, decodeInstructions.type);

              if (decoder) {
                _context15.next = 3;
                break;
              }

              throw new Error("Undefined Decoder Error: ".concat(decodeInstructions.type, "@").concat(stack.join(".")));

            case 3:
              _context15.next = 5;
              return decoder(decodeInstructions.value, decoders, stack);

            case 5:
              return _context15.abrupt("return", _context15.sent);

            case 6:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15);
    }));

    return function recurseDecode(_x26, _x27, _x28) {
      return _ref15.apply(this, arguments);
    };
  }();

  var decode$1 = /*#__PURE__*/function () {
    var _ref16 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee16(decodeInstructions) {
      var customDecoders,
          stack,
          filteredDecoders,
          decoders,
          _args16 = arguments;
      return regenerator.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              customDecoders = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : {};
              stack = _args16.length > 2 && _args16[2] !== undefined ? _args16[2] : [];
              // Filter out all default decoders which are overridden by a custom decoder regex
              filteredDecoders = Object.keys(defaultDecoders).filter(function (decoder) {
                return !Object.keys(customDecoders).find(function (customDecoder) {
                  return new RegExp(customDecoder).test(decoder);
                });
              }).reduce(function (decoders, decoderKey) {
                decoders[decoderKey] = defaultDecoders[decoderKey];
                return decoders;
              }, customDecoders);
              decoders = _objectSpread2(_objectSpread2({}, filteredDecoders), customDecoders);
              return _context16.abrupt("return", recurseDecode(decodeInstructions, decoders, stack));

            case 5:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16);
    }));

    return function decode(_x29) {
      return _ref16.apply(this, arguments);
    };
  }();
  var decodeResponse = /*#__PURE__*/function () {
    var _ref17 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee19(response) {
      var customDecoders,
          _args19 = arguments;
      return regenerator.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              customDecoders = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : {};

              if (!response.encodedData) {
                _context19.next = 5;
                break;
              }

              return _context19.abrupt("return", decode$1(response.encodedData, customDecoders));

            case 5:
              if (!response.transactionStatus) {
                _context19.next = 16;
                break;
              }

              _context19.t0 = _objectSpread2;
              _context19.t1 = _objectSpread2({}, response.transactionStatus);
              _context19.t2 = {};
              _context19.next = 11;
              return Promise.all(response.transactionStatus.events.map( /*#__PURE__*/function () {
                var _decodeEvents = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee17(e) {
                  return regenerator.wrap(function _callee17$(_context17) {
                    while (1) {
                      switch (_context17.prev = _context17.next) {
                        case 0:
                          _context17.t0 = e.type;
                          _context17.t1 = e.transactionId;
                          _context17.t2 = e.transactionIndex;
                          _context17.t3 = e.eventIndex;
                          _context17.next = 6;
                          return decode$1(e.payload, customDecoders);

                        case 6:
                          _context17.t4 = _context17.sent;
                          return _context17.abrupt("return", {
                            type: _context17.t0,
                            transactionId: _context17.t1,
                            transactionIndex: _context17.t2,
                            eventIndex: _context17.t3,
                            data: _context17.t4
                          });

                        case 8:
                        case "end":
                          return _context17.stop();
                      }
                    }
                  }, _callee17);
                }));

                function decodeEvents(_x31) {
                  return _decodeEvents.apply(this, arguments);
                }

                return decodeEvents;
              }()));

            case 11:
              _context19.t3 = _context19.sent;
              _context19.t4 = {
                events: _context19.t3
              };
              return _context19.abrupt("return", (0, _context19.t0)(_context19.t1, _context19.t2, _context19.t4));

            case 16:
              if (!response.transaction) {
                _context19.next = 20;
                break;
              }

              return _context19.abrupt("return", response.transaction);

            case 20:
              if (!response.events) {
                _context19.next = 26;
                break;
              }

              _context19.next = 23;
              return Promise.all(response.events.map( /*#__PURE__*/function () {
                var _decodeEvents2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee18(e) {
                  return regenerator.wrap(function _callee18$(_context18) {
                    while (1) {
                      switch (_context18.prev = _context18.next) {
                        case 0:
                          _context18.t0 = e.blockId;
                          _context18.t1 = e.blockHeight;
                          _context18.t2 = e.blockTimestamp;
                          _context18.t3 = e.type;
                          _context18.t4 = e.transactionId;
                          _context18.t5 = e.transactionIndex;
                          _context18.t6 = e.eventIndex;
                          _context18.next = 9;
                          return decode$1(e.payload, customDecoders);

                        case 9:
                          _context18.t7 = _context18.sent;
                          return _context18.abrupt("return", {
                            blockId: _context18.t0,
                            blockHeight: _context18.t1,
                            blockTimestamp: _context18.t2,
                            type: _context18.t3,
                            transactionId: _context18.t4,
                            transactionIndex: _context18.t5,
                            eventIndex: _context18.t6,
                            data: _context18.t7
                          });

                        case 11:
                        case "end":
                          return _context18.stop();
                      }
                    }
                  }, _callee18);
                }));

                function decodeEvents(_x32) {
                  return _decodeEvents2.apply(this, arguments);
                }

                return decodeEvents;
              }()));

            case 23:
              return _context19.abrupt("return", _context19.sent);

            case 26:
              if (!response.account) {
                _context19.next = 30;
                break;
              }

              return _context19.abrupt("return", response.account);

            case 30:
              if (!response.block) {
                _context19.next = 34;
                break;
              }

              return _context19.abrupt("return", response.block);

            case 34:
              if (!response.blockHeader) {
                _context19.next = 38;
                break;
              }

              return _context19.abrupt("return", response.blockHeader);

            case 38:
              if (!response.latestBlock) {
                _context19.next = 43;
                break;
              }

              latestBlockDeprecationNotice();
              return _context19.abrupt("return", response.latestBlock);

            case 43:
              if (!response.transactionId) {
                _context19.next = 47;
                break;
              }

              return _context19.abrupt("return", response.transactionId);

            case 47:
              if (!response.collection) {
                _context19.next = 49;
                break;
              }

              return _context19.abrupt("return", response.collection);

            case 49:
              return _context19.abrupt("return", null);

            case 50:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19);
    }));

    return function decodeResponse(_x30) {
      return _ref17.apply(this, arguments);
    };
  }();

  function getRefId(_x) {
    return _getRefId.apply(this, arguments);
  }

  function _getRefId() {
    _getRefId = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(opts) {
      var node, sendFn, ix;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return config().get("accessNode.api");

            case 2:
              node = _context2.sent;
              _context2.next = 5;
              return config.first(["sdk.transport", "sdk.send"], send$1);

            case 5:
              sendFn = _context2.sent;
              invariant$1(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
              _context2.next = 9;
              return pipe(interaction(), [getBlock()]);

            case 9:
              ix = _context2.sent;
              _context2.next = 12;
              return sendFn(ix, {
                config: config,
                response: response,
                Buffer: buffer.Buffer,
                ix: ixModule
              }, {
                node: node
              });

            case 12:
              ix = _context2.sent;
              _context2.next = 15;
              return decodeResponse(ix);

            case 15:
              ix = _context2.sent;
              return _context2.abrupt("return", ix.id);

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _getRefId.apply(this, arguments);
  }

  function resolveRefBlockId(opts) {
    return /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isTransaction(ix)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", Ok(ix));

              case 2:
                if (!ix.message.refBlock) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", Ok(ix));

              case 4:
                _context.next = 6;
                return getRefId(opts);

              case 6:
                ix.message.refBlock = _context.sent;
                return _context.abrupt("return", Ok(ix));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x2) {
        return _ref.apply(this, arguments);
      };
    }();
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  var isFn$2 = function isFn(v) {
    return typeof v === "function";
  };

  var isString$1 = function isString(v) {
    return typeof v === "string";
  };

  function resolveCadence(_x) {
    return _resolveCadence.apply(this, arguments);
  }

  function _resolveCadence() {
    _resolveCadence = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var cadence;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(isTransaction(ix) || isScript(ix))) {
                _context.next = 11;
                break;
              }

              cadence = get(ix, "ix.cadence");
              invariant$1(isFn$2(cadence) || isString$1(cadence), "Cadence needs to be a function or a string.");

              if (!isFn$2(cadence)) {
                _context.next = 7;
                break;
              }

              _context.next = 6;
              return cadence({});

            case 6:
              cadence = _context.sent;

            case 7:
              invariant$1(isString$1(cadence), "Cadence needs to be a string at this point.");
              _context.next = 10;
              return config().where(/^0x/).then(function (d) {
                return Object.entries(d).reduce(function (cadence, _ref) {
                  var _ref2 = _slicedToArray(_ref, 2),
                      key = _ref2[0],
                      value = _ref2[1];

                  var regex = new RegExp("(\\b" + key + "\\b)", "g");
                  return cadence.replace(regex, value);
                }, cadence);
              });

            case 10:
              ix.message.cadence = _context.sent;

            case 11:
              return _context.abrupt("return", ix);

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolveCadence.apply(this, arguments);
  }

  var isFn$1 = function isFn(v) {
    return typeof v === "function";
  };

  function cast(arg) {
    // prettier-ignore
    invariant$1(_typeof$1(arg.xform) != null, "No type specified for argument: ".concat(arg.value));
    if (isFn$1(arg.xform)) return arg.xform(arg.value);
    if (isFn$1(arg.xform.asArgument)) return arg.xform.asArgument(arg.value); // prettier-ignore

    invariant$1(false, "Invalid Argument", arg);
  }

  function handleArgResolution(_x) {
    return _handleArgResolution.apply(this, arguments);
  }

  function _handleArgResolution() {
    _handleArgResolution = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(arg) {
      var depth,
          resolvedArg,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              depth = _args.length > 1 && _args[1] !== undefined ? _args[1] : 3;
              invariant$1(depth > 0, "Argument Resolve Recursion Limit Exceeded for Arg: ".concat(arg.tempId));

              if (!isFn$1(arg.resolveArgument)) {
                _context.next = 9;
                break;
              }

              _context.next = 5;
              return arg.resolveArgument();

            case 5:
              resolvedArg = _context.sent;
              return _context.abrupt("return", handleArgResolution(resolvedArg, depth - 1));

            case 9:
              return _context.abrupt("return", arg);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _handleArgResolution.apply(this, arguments);
  }

  function resolveArguments(_x2) {
    return _resolveArguments.apply(this, arguments);
  }

  function _resolveArguments() {
    _resolveArguments = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix) {
      var _i, _Object$entries, _Object$entries$_i, id, arg, res;

      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(isTransaction(ix) || isScript(ix))) {
                _context2.next = 11;
                break;
              }

              _i = 0, _Object$entries = Object.entries(ix.arguments);

            case 2:
              if (!(_i < _Object$entries.length)) {
                _context2.next = 11;
                break;
              }

              _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), id = _Object$entries$_i[0], arg = _Object$entries$_i[1];
              _context2.next = 6;
              return handleArgResolution(arg);

            case 6:
              res = _context2.sent;
              ix.arguments[id].asArgument = cast(res);

            case 8:
              _i++;
              _context2.next = 2;
              break;

            case 11:
              return _context2.abrupt("return", ix);

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _resolveArguments.apply(this, arguments);
  }

  var sha3 = {};

  var sponge = {};

  var permute = {};

  var chi = {};

  var copy = function copy(I, i) {
    return function (O, o) {
      var oi = o * 2;
      var ii = i * 2;
      O[oi] = I[ii];
      O[oi + 1] = I[ii + 1];
    };
  };

  var copy_1 = copy;

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _copy = _interopRequireDefault(copy_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var chi = function chi(_ref) {
      var A = _ref.A,
          C = _ref.C;

      for (var y = 0; y < 25; y += 5) {
        for (var x = 0; x < 5; x++) {
          (0, _copy["default"])(A, y + x)(C, x);
        }

        for (var _x = 0; _x < 5; _x++) {
          var xy = (y + _x) * 2;
          var x1 = (_x + 1) % 5 * 2;
          var x2 = (_x + 2) % 5 * 2;
          A[xy] ^= ~C[x1] & C[x2];
          A[xy + 1] ^= ~C[x1 + 1] & C[x2 + 1];
        }
      }
    };

    var _default = chi;
    exports["default"] = _default;
  })(chi);

  var iota = {};

  var roundConstants = {};

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var ROUND_CONSTANTS = new Uint32Array([0, 1, 0, 32898, 2147483648, 32906, 2147483648, 2147516416, 0, 32907, 0, 2147483649, 2147483648, 2147516545, 2147483648, 32777, 0, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 2147483648, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 0, 32778, 2147483648, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 0, 2147483649, 2147483648, 2147516424]);
    var _default = ROUND_CONSTANTS;
    exports["default"] = _default;
  })(roundConstants);

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _roundConstants = _interopRequireDefault(roundConstants);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var iota = function iota(_ref) {
      var A = _ref.A,
          roundIndex = _ref.roundIndex;
      var i = roundIndex * 2;
      A[0] ^= _roundConstants["default"][i];
      A[1] ^= _roundConstants["default"][i + 1];
    };

    var _default = iota;
    exports["default"] = _default;
  })(iota);

  var rhoPi = {};

  var piShuffles = {};

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var PI_SHUFFLES = [10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1];
    var _default = PI_SHUFFLES;
    exports["default"] = _default;
  })(piShuffles);

  var rhoOffsets = {};

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var RHO_OFFSETS = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44];
    var _default = RHO_OFFSETS;
    exports["default"] = _default;
  })(rhoOffsets);

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _piShuffles = _interopRequireDefault(piShuffles);

    var _rhoOffsets = _interopRequireDefault(rhoOffsets);

    var _copy = _interopRequireDefault(copy_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var rhoPi = function rhoPi(_ref) {
      var A = _ref.A,
          C = _ref.C,
          W = _ref.W;
      (0, _copy["default"])(A, 1)(W, 0);
      var H = 0;
      var L = 0;
      var Wi = 0;
      var ri = 32;

      for (var i = 0; i < 24; i++) {
        var j = _piShuffles["default"][i];
        var r = _rhoOffsets["default"][i];
        (0, _copy["default"])(A, j)(C, 0);
        H = W[0];
        L = W[1];
        ri = 32 - r;
        Wi = r < 32 ? 0 : 1;
        W[Wi] = H << r | L >>> ri;
        W[(Wi + 1) % 2] = L << r | H >>> ri;
        (0, _copy["default"])(W, 0)(A, j);
        (0, _copy["default"])(C, 0)(W, 0);
      }
    };

    var _default = rhoPi;
    exports["default"] = _default;
  })(rhoPi);

  var theta = {};

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _copy = _interopRequireDefault(copy_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var theta = function theta(_ref) {
      var A = _ref.A,
          C = _ref.C,
          D = _ref.D,
          W = _ref.W;
      var H = 0;
      var L = 0;

      for (var x = 0; x < 5; x++) {
        var x20 = x * 2;
        var x21 = (x + 5) * 2;
        var x22 = (x + 10) * 2;
        var x23 = (x + 15) * 2;
        var x24 = (x + 20) * 2;
        C[x20] = A[x20] ^ A[x21] ^ A[x22] ^ A[x23] ^ A[x24];
        C[x20 + 1] = A[x20 + 1] ^ A[x21 + 1] ^ A[x22 + 1] ^ A[x23 + 1] ^ A[x24 + 1];
      }

      for (var _x = 0; _x < 5; _x++) {
        (0, _copy["default"])(C, (_x + 1) % 5)(W, 0);
        H = W[0];
        L = W[1];
        W[0] = H << 1 | L >>> 31;
        W[1] = L << 1 | H >>> 31;
        D[_x * 2] = C[(_x + 4) % 5 * 2] ^ W[0];
        D[_x * 2 + 1] = C[(_x + 4) % 5 * 2 + 1] ^ W[1];

        for (var y = 0; y < 25; y += 5) {
          A[(y + _x) * 2] ^= D[_x * 2];
          A[(y + _x) * 2 + 1] ^= D[_x * 2 + 1];
        }
      }
    };

    var _default = theta;
    exports["default"] = _default;
  })(theta);

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _chi = _interopRequireDefault(chi);

    var _iota = _interopRequireDefault(iota);

    var _rhoPi = _interopRequireDefault(rhoPi);

    var _theta = _interopRequireDefault(theta);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var permute = function permute() {
      var C = new Uint32Array(10);
      var D = new Uint32Array(10);
      var W = new Uint32Array(2);
      return function (A) {
        for (var roundIndex = 0; roundIndex < 24; roundIndex++) {
          (0, _theta["default"])({
            A: A,
            C: C,
            D: D,
            W: W
          });
          (0, _rhoPi["default"])({
            A: A,
            C: C,
            W: W
          });
          (0, _chi["default"])({
            A: A,
            C: C
          });
          (0, _iota["default"])({
            A: A,
            roundIndex: roundIndex
          });
        }

        C.fill(0);
        D.fill(0);
        W.fill(0);
      };
    };

    var _default = permute;
    exports["default"] = _default;
  })(permute);

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _buffer = buffer;

    var _permute = _interopRequireDefault(permute);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var xorWords = function xorWords(I, O) {
      for (var i = 0; i < I.length; i += 8) {
        var o = i / 4;
        O[o] ^= I[i + 7] << 24 | I[i + 6] << 16 | I[i + 5] << 8 | I[i + 4];
        O[o + 1] ^= I[i + 3] << 24 | I[i + 2] << 16 | I[i + 1] << 8 | I[i];
      }

      return O;
    };

    var readWords = function readWords(I, O) {
      for (var o = 0; o < O.length; o += 8) {
        var i = o / 4;
        O[o] = I[i + 1];
        O[o + 1] = I[i + 1] >>> 8;
        O[o + 2] = I[i + 1] >>> 16;
        O[o + 3] = I[i + 1] >>> 24;
        O[o + 4] = I[i];
        O[o + 5] = I[i] >>> 8;
        O[o + 6] = I[i] >>> 16;
        O[o + 7] = I[i] >>> 24;
      }

      return O;
    };

    var Sponge = function Sponge(_ref) {
      var _this = this;

      var capacity = _ref.capacity,
          padding = _ref.padding;
      var keccak = (0, _permute["default"])();
      var stateSize = 200;
      var blockSize = capacity / 8;
      var queueSize = stateSize - capacity / 4;
      var queueOffset = 0;
      var state = new Uint32Array(stateSize / 4);

      var queue = _buffer.Buffer.allocUnsafe(queueSize);

      this.absorb = function (buffer) {
        for (var i = 0; i < buffer.length; i++) {
          queue[queueOffset] = buffer[i];
          queueOffset += 1;

          if (queueOffset >= queueSize) {
            xorWords(queue, state);
            keccak(state);
            queueOffset = 0;
          }
        }

        return _this;
      };

      this.squeeze = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var output = {
          buffer: options.buffer || _buffer.Buffer.allocUnsafe(blockSize),
          padding: options.padding || padding,
          queue: _buffer.Buffer.allocUnsafe(queue.length),
          state: new Uint32Array(state.length)
        };
        queue.copy(output.queue);

        for (var i = 0; i < state.length; i++) {
          output.state[i] = state[i];
        }

        output.queue.fill(0, queueOffset);
        output.queue[queueOffset] |= output.padding;
        output.queue[queueSize - 1] |= 128;
        xorWords(output.queue, output.state);

        for (var offset = 0; offset < output.buffer.length; offset += queueSize) {
          keccak(output.state);
          readWords(output.state, output.buffer.slice(offset, offset + queueSize));
        }

        return output.buffer;
      };

      this.reset = function () {
        queue.fill(0);
        state.fill(0);
        queueOffset = 0;
        return _this;
      };

      return this;
    };

    var _default = Sponge;
    exports["default"] = _default;
  })(sponge);

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = exports.SHAKE = exports.SHA3Hash = exports.SHA3 = exports.Keccak = void 0;
    var _buffer = buffer;

    var _sponge = _interopRequireDefault(sponge);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var createHash = function createHash(_ref) {
      var allowedSizes = _ref.allowedSizes,
          defaultSize = _ref.defaultSize,
          padding = _ref.padding;
      return function Hash() {
        var _this = this;

        var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSize;

        if (!this || this.constructor !== Hash) {
          return new Hash(size);
        }

        if (allowedSizes && !allowedSizes.includes(size)) {
          throw new Error("Unsupported hash length");
        }

        var sponge = new _sponge["default"]({
          capacity: size
        });

        this.update = function (input) {
          var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf8";

          if (_buffer.Buffer.isBuffer(input)) {
            sponge.absorb(input);
            return _this;
          }

          if (typeof input === "string") {
            return _this.update(_buffer.Buffer.from(input, encoding));
          }

          throw new TypeError("Not a string or buffer");
        };

        this.digest = function () {
          var formatOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "binary";
          var options = typeof formatOrOptions === "string" ? {
            format: formatOrOptions
          } : formatOrOptions;
          var buffer = sponge.squeeze({
            buffer: options.buffer,
            padding: options.padding || padding
          });

          if (options.format && options.format !== "binary") {
            return buffer.toString(options.format);
          }

          return buffer;
        };

        this.reset = function () {
          sponge.reset();
          return _this;
        };

        return this;
      };
    };

    var Keccak = createHash({
      allowedSizes: [224, 256, 384, 512],
      defaultSize: 512,
      padding: 1
    });
    exports.Keccak = Keccak;
    var SHA3 = createHash({
      allowedSizes: [224, 256, 384, 512],
      defaultSize: 512,
      padding: 6
    });
    exports.SHA3 = SHA3;
    var SHAKE = createHash({
      allowedSizes: [128, 256],
      defaultSize: 256,
      padding: 31
    });
    exports.SHAKE = SHAKE;
    var SHA3Hash = Keccak;
    exports.SHA3Hash = SHA3Hash;
    SHA3.SHA3Hash = SHA3Hash;
    var _default = SHA3;
    exports["default"] = _default;
  })(sha3);

  var encodeTransactionPayload = function encodeTransactionPayload(tx) {
    return prependTransactionDomainTag(rlpEncode(preparePayload(tx)));
  };
  var encodeTransactionEnvelope = function encodeTransactionEnvelope(tx) {
    return prependTransactionDomainTag(rlpEncode(prepareEnvelope(tx)));
  };
  var encodeTxIdFromVoucher = function encodeTxIdFromVoucher(voucher) {
    return sha3_256(rlpEncode(prepareVoucher(voucher)));
  };

  var rightPaddedHexBuffer = function rightPaddedHexBuffer(value, pad) {
    return buffer.Buffer.from(value.padEnd(pad * 2, 0), "hex");
  };

  var leftPaddedHexBuffer = function leftPaddedHexBuffer(value, pad) {
    return buffer.Buffer.from(value.padStart(pad * 2, 0), "hex");
  };

  var TRANSACTION_DOMAIN_TAG = rightPaddedHexBuffer(buffer.Buffer.from("FLOW-V0.0-transaction").toString("hex"), 32).toString("hex");

  var prependTransactionDomainTag = function prependTransactionDomainTag(tx) {
    return TRANSACTION_DOMAIN_TAG + tx;
  };

  var addressBuffer = function addressBuffer(addr) {
    return leftPaddedHexBuffer(addr, 8);
  };

  var blockBuffer = function blockBuffer(block) {
    return leftPaddedHexBuffer(block, 32);
  };

  var argumentToString = function argumentToString(arg) {
    return buffer.Buffer.from(JSON.stringify(arg), "utf8");
  };

  var scriptBuffer = function scriptBuffer(script) {
    return buffer.Buffer.from(script, "utf8");
  };

  var signatureBuffer = function signatureBuffer(signature) {
    return buffer.Buffer.from(signature, "hex");
  };

  var rlpEncode = function rlpEncode(v) {
    return encode(v).toString("hex");
  };

  var sha3_256 = function sha3_256(msg) {
    var sha = new sha3.SHA3(256);
    sha.update(buffer.Buffer.from(msg, "hex"));
    return sha.digest().toString("hex");
  };

  var preparePayload = function preparePayload(tx) {
    validatePayload(tx);
    return [scriptBuffer(tx.cadence), tx.arguments.map(argumentToString), blockBuffer(tx.refBlock), tx.computeLimit, addressBuffer(sansPrefix(tx.proposalKey.address)), tx.proposalKey.keyId, tx.proposalKey.sequenceNum, addressBuffer(sansPrefix(tx.payer)), tx.authorizers.map(function (authorizer) {
      return addressBuffer(sansPrefix(authorizer));
    })];
  };

  var prepareEnvelope = function prepareEnvelope(tx) {
    validateEnvelope(tx);
    return [preparePayload(tx), preparePayloadSignatures(tx)];
  };

  var preparePayloadSignatures = function preparePayloadSignatures(tx) {
    var signers = collectSigners(tx);
    return tx.payloadSigs.map(function (sig) {
      return {
        signerIndex: signers.get(sig.address),
        keyId: sig.keyId,
        sig: sig.sig
      };
    }).sort(function (a, b) {
      if (a.signerIndex > b.signerIndex) return 1;
      if (a.signerIndex < b.signerIndex) return -1;
      if (a.keyId > b.keyId) return 1;
      if (a.keyId < b.keyId) return -1;
    }).map(function (sig) {
      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
    });
  };

  var collectSigners = function collectSigners(tx) {
    var signers = new Map();
    var i = 0;

    var addSigner = function addSigner(addr) {
      if (!signers.has(addr)) {
        signers.set(addr, i);
        i++;
      }
    };

    addSigner(tx.proposalKey.address);
    addSigner(tx.payer);
    tx.authorizers.forEach(addSigner);
    return signers;
  };

  var prepareVoucher = function prepareVoucher(voucher) {
    validateVoucher(voucher);
    var signers = collectSigners(voucher);

    var prepareSigs = function prepareSigs(sigs) {
      return sigs.map(function (_ref) {
        var address = _ref.address,
            keyId = _ref.keyId,
            sig = _ref.sig;
        return {
          signerIndex: signers.get(address),
          keyId: keyId,
          sig: sig
        };
      }).sort(function (a, b) {
        if (a.signerIndex > b.signerIndex) return 1;
        if (a.signerIndex < b.signerIndex) return -1;
        if (a.keyId > b.keyId) return 1;
        if (a.keyId < b.keyId) return -1;
      }).map(function (sig) {
        return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
      });
    };

    return [[scriptBuffer(voucher.cadence), voucher.arguments.map(argumentToString), blockBuffer(voucher.refBlock), voucher.computeLimit, addressBuffer(sansPrefix(voucher.proposalKey.address)), voucher.proposalKey.keyId, voucher.proposalKey.sequenceNum, addressBuffer(sansPrefix(voucher.payer)), voucher.authorizers.map(function (authorizer) {
      return addressBuffer(sansPrefix(authorizer));
    })], prepareSigs(voucher.payloadSigs), prepareSigs(voucher.envelopeSigs)];
  };

  var validatePayload = function validatePayload(tx) {
    payloadFields.forEach(function (field) {
      return checkField(tx, field);
    });
    proposalKeyFields.forEach(function (field) {
      return checkField(tx.proposalKey, field, "proposalKey");
    });
  };

  var validateEnvelope = function validateEnvelope(tx) {
    payloadSigsFields.forEach(function (field) {
      return checkField(tx, field);
    });
    tx.payloadSigs.forEach(function (sig, index) {
      payloadSigFields.forEach(function (field) {
        return checkField(sig, field, "payloadSigs", index);
      });
    });
  };

  var validateVoucher = function validateVoucher(voucher) {
    payloadFields.forEach(function (field) {
      return checkField(voucher, field);
    });
    proposalKeyFields.forEach(function (field) {
      return checkField(voucher.proposalKey, field, "proposalKey");
    });
    payloadSigsFields.forEach(function (field) {
      return checkField(voucher, field);
    });
    voucher.payloadSigs.forEach(function (sig, index) {
      payloadSigFields.forEach(function (field) {
        return checkField(sig, field, "payloadSigs", index);
      });
    });
    envelopeSigsFields.forEach(function (field) {
      return checkField(voucher, field);
    });
    voucher.envelopeSigs.forEach(function (sig, index) {
      envelopeSigFields.forEach(function (field) {
        return checkField(sig, field, "envelopeSigs", index);
      });
    });
  };

  var isNumber = function isNumber(v) {
    return typeof v === "number";
  };

  var isString = function isString(v) {
    return typeof v === "string";
  };

  var isObject = function isObject(v) {
    return v !== null && _typeof$1(v) === "object";
  };

  var isArray = function isArray(v) {
    return isObject(v) && v instanceof Array;
  };

  var payloadFields = [{
    name: "cadence",
    check: isString
  }, {
    name: "arguments",
    check: isArray
  }, {
    name: "refBlock",
    check: isString,
    defaultVal: "0"
  }, {
    name: "computeLimit",
    check: isNumber
  }, {
    name: "proposalKey",
    check: isObject
  }, {
    name: "payer",
    check: isString
  }, {
    name: "authorizers",
    check: isArray
  }];
  var proposalKeyFields = [{
    name: "address",
    check: isString
  }, {
    name: "keyId",
    check: isNumber
  }, {
    name: "sequenceNum",
    check: isNumber
  }];
  var payloadSigsFields = [{
    name: "payloadSigs",
    check: isArray
  }];
  var payloadSigFields = [{
    name: "address",
    check: isString
  }, {
    name: "keyId",
    check: isNumber
  }, {
    name: "sig",
    check: isString
  }];
  var envelopeSigsFields = [{
    name: "envelopeSigs",
    check: isArray
  }];
  var envelopeSigFields = [{
    name: "address",
    check: isString
  }, {
    name: "keyId",
    check: isNumber
  }, {
    name: "sig",
    check: isString
  }];

  var checkField = function checkField(obj, field, base, index) {
    var name = field.name,
        check = field.check,
        defaultVal = field.defaultVal;
    if (obj[name] == null && defaultVal != null) obj[name] = defaultVal;
    if (obj[name] == null) throw missingFieldError(name, base, index);
    if (!check(obj[name])) throw invalidFieldError(name, base, index);
  };

  var printFieldName = function printFieldName(field, base, index) {
    if (!!base) return index == null ? "".concat(base, ".").concat(field) : "".concat(base, ".").concat(index, ".").concat(field);
    return field;
  };

  var missingFieldError = function missingFieldError(field, base, index) {
    return new Error("Missing field ".concat(printFieldName(field, base, index)));
  };

  var invalidFieldError = function invalidFieldError(field, base, index) {
    return new Error("Invalid field ".concat(printFieldName(field, base, index)));
  };

  function findInsideSigners(ix) {
    // Inside Signers Are: (authorizers + proposer) - payer
    var inside = new Set(ix.authorizations);
    inside.add(ix.proposer);

    if (Array.isArray(ix.payer)) {
      ix.payer.forEach(function (p) {
        return inside["delete"](p);
      });
    } else {
      inside["delete"](ix.payer);
    }

    return Array.from(inside);
  }
  function findOutsideSigners(ix) {
    // Outside Signers Are: (payer)
    var outside = new Set(Array.isArray(ix.payer) ? ix.payer : [ix.payer]);
    return Array.from(outside);
  }
  var createSignableVoucher = function createSignableVoucher(ix) {
    var buildAuthorizers = function buildAuthorizers() {
      var authorizations = ix.authorizations.map(function (cid) {
        return withPrefix$1(ix.accounts[cid].addr);
      }).reduce(function (prev, current) {
        return prev.find(function (item) {
          return item === current;
        }) ? prev : [].concat(_toConsumableArray(prev), [current]);
      }, []);
      return authorizations[0] ? authorizations : [];
    };

    var buildInsideSigners = function buildInsideSigners() {
      return findInsideSigners(ix).map(function (id) {
        return {
          address: withPrefix$1(ix.accounts[id].addr),
          keyId: ix.accounts[id].keyId,
          sig: ix.accounts[id].signature
        };
      });
    };

    var buildOutsideSigners = function buildOutsideSigners() {
      return findOutsideSigners(ix).map(function (id) {
        return {
          address: withPrefix$1(ix.accounts[id].addr),
          keyId: ix.accounts[id].keyId,
          sig: ix.accounts[id].signature
        };
      });
    };

    return {
      cadence: ix.message.cadence,
      refBlock: ix.message.refBlock || null,
      computeLimit: ix.message.computeLimit,
      arguments: ix.message.arguments.map(function (id) {
        return ix.arguments[id].asArgument;
      }),
      proposalKey: {
        address: withPrefix$1(ix.accounts[ix.proposer].addr),
        keyId: ix.accounts[ix.proposer].keyId,
        sequenceNum: ix.accounts[ix.proposer].sequenceNum
      },
      payer: withPrefix$1(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
      authorizers: buildAuthorizers(),
      payloadSigs: buildInsideSigners(),
      envelopeSigs: buildOutsideSigners()
    };
  };
  var voucherToTxId = function voucherToTxId(voucher) {
    return encodeTxIdFromVoucher(voucher);
  };

  var idof$1 = function idof(acct) {
    return "".concat(withPrefix$1(acct.addr), "-").concat(acct.keyId);
  };

  var isFn = function isFn(v) {
    return typeof v === "function";
  };

  function buildPreSignable(acct, ix) {
    try {
      return {
        f_type: "PreSignable",
        f_vsn: "1.0.1",
        roles: acct.role,
        cadence: ix.message.cadence,
        args: ix.message.arguments.map(function (d) {
          return ix.arguments[d].asArgument;
        }),
        data: {},
        interaction: ix,
        voucher: createSignableVoucher(ix)
      };
    } catch (error) {
      console.error("buildPreSignable", error);
      throw error;
    }
  }

  function collectAccounts(_x, _x2, _x3) {
    return _collectAccounts.apply(this, arguments);
  }

  function _collectAccounts() {
    _collectAccounts = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, accounts, last) {
      var depth,
          authorizations,
          _iterator,
          _step,
          _loop,
          old,
          _args2 = arguments;

      return regenerator.wrap(function _callee$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              depth = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 3;
              invariant$1(depth, "Account Resolve Recursion Limit Exceeded", {
                ix: ix,
                accounts: accounts
              });
              authorizations = [];
              _iterator = _createForOfIteratorHelper(accounts);
              _context2.prev = 4;
              _loop = /*#__PURE__*/regenerator.mark(function _loop() {
                var ax, resolve, dupList, payerAccts, multiAccts;
                return regenerator.wrap(function _loop$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        ax = _step.value;
                        resolve = ax.resolve;
                        ax.resolve = null;
                        old = last || ax;

                        if (!isFn(resolve)) {
                          _context.next = 8;
                          break;
                        }

                        _context.next = 7;
                        return resolve(ax, buildPreSignable(ax, ix));

                      case 7:
                        ax = _context.sent;

                      case 8:
                        if (!Array.isArray(ax)) {
                          _context.next = 13;
                          break;
                        }

                        _context.next = 11;
                        return collectAccounts(ix, ax, old, depth - 1);

                      case 11:
                        _context.next = 30;
                        break;

                      case 13:
                        if (ax.addr) {
                          ax.addr = sansPrefix(ax.addr);
                        }

                        if (ax.addr != null && ax.keyId != null) {
                          ax.tempId = idof$1(ax);
                        }

                        ix.accounts[ax.tempId] = ix.accounts[ax.tempId] || ax;
                        ix.accounts[ax.tempId].role.proposer = ix.accounts[ax.tempId].role.proposer || ax.role.proposer;
                        ix.accounts[ax.tempId].role.payer = ix.accounts[ax.tempId].role.payer || ax.role.payer;
                        ix.accounts[ax.tempId].role.authorizer = ix.accounts[ax.tempId].role.authorizer || ax.role.authorizer;

                        if (ix.accounts[ax.tempId].role.proposer && ix.proposer === old.tempId) {
                          ix.proposer = ax.tempId;
                        }

                        if (!ix.accounts[ax.tempId].role.payer) {
                          _context.next = 29;
                          break;
                        }

                        if (Array.isArray(ix.payer)) {
                          ix.payer = Array.from(new Set([].concat(_toConsumableArray(ix.payer), [ax.tempId]).map(function (d) {
                            return d === old.tempId ? ax.tempId : d;
                          })));
                        } else {
                          ix.payer = Array.from(new Set([ix.payer, ax.tempId].map(function (d) {
                            return d === old.tempId ? ax.tempId : d;
                          })));
                        }

                        if (!(ix.payer.length > 1)) {
                          _context.next = 29;
                          break;
                        }

                        // remove payer dups based on addr and keyId
                        dupList = [];
                        payerAccts = [];
                        ix.payer = ix.payer.reduce(function (g, tempId) {
                          var addr = ix.accounts[tempId].addr;
                          var key = idof$1(ix.accounts[tempId]);
                          payerAccts.push(addr);
                          if (dupList.includes(key)) return g;
                          dupList.push(key);
                          return [].concat(_toConsumableArray(g), [tempId]);
                        }, []);
                        multiAccts = Array.from(new Set(payerAccts));

                        if (!(multiAccts.length > 1)) {
                          _context.next = 29;
                          break;
                        }

                        throw new Error("Payer can not be different accounts");

                      case 29:
                        if (ix.accounts[ax.tempId].role.authorizer) {
                          if (last) {
                            // do group replacement
                            authorizations = Array.from(new Set([].concat(_toConsumableArray(authorizations), [ax.tempId])));
                          } else {
                            // do 1-1 replacement
                            ix.authorizations = ix.authorizations.map(function (d) {
                              return d === old.tempId ? ax.tempId : d;
                            });
                          }
                        }

                      case 30:
                        if (old.tempId != ax.tempId) delete ix.accounts[old.tempId];

                      case 31:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _loop);
              });

              _iterator.s();

            case 7:
              if ((_step = _iterator.n()).done) {
                _context2.next = 11;
                break;
              }

              return _context2.delegateYield(_loop(), "t0", 9);

            case 9:
              _context2.next = 7;
              break;

            case 11:
              _context2.next = 16;
              break;

            case 13:
              _context2.prev = 13;
              _context2.t1 = _context2["catch"](4);

              _iterator.e(_context2.t1);

            case 16:
              _context2.prev = 16;

              _iterator.f();

              return _context2.finish(16);

            case 19:
              if (last) {
                // complete (flatmap) group replacement
                ix.authorizations = ix.authorizations.map(function (d) {
                  return d === last.tempId ? authorizations : d;
                }).reduce(function (prev, curr) {
                  return Array.isArray(curr) ? [].concat(_toConsumableArray(prev), _toConsumableArray(curr)) : [].concat(_toConsumableArray(prev), [curr]);
                }, []);
              }

            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee, null, [[4, 13, 16, 19]]);
    }));
    return _collectAccounts.apply(this, arguments);
  }

  function resolveAccounts(_x4) {
    return _resolveAccounts.apply(this, arguments);
  }

  function _resolveAccounts() {
    _resolveAccounts = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix) {
      return regenerator.wrap(function _callee2$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!isTransaction(ix)) {
                _context3.next = 13;
                break;
              }

              if (!Array.isArray(ix.payer)) {
                log.deprecate({
                  pkg: "FCL",
                  subject: '"ix.payer" must be an array. Support for ix.payer as a singular',
                  message: "See changelog for more info."
                });
              }

              _context3.prev = 2;
              _context3.next = 5;
              return collectAccounts(ix, Object.values(ix.accounts));

            case 5:
              _context3.next = 7;
              return collectAccounts(ix, Object.values(ix.accounts));

            case 7:
              _context3.next = 13;
              break;

            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](2);
              console.error("=== SAD PANDA ===\n\n", _context3.t0, "\n\n=== SAD PANDA ===");
              throw _context3.t0;

            case 13:
              return _context3.abrupt("return", ix);

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee2, null, [[2, 9]]);
    }));
    return _resolveAccounts.apply(this, arguments);
  }

  function resolveSignatures(_x) {
    return _resolveSignatures.apply(this, arguments);
  }

  function _resolveSignatures() {
    _resolveSignatures = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix) {
      var insideSigners, insidePayload, outsideSigners, outsidePayload;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!isTransaction(ix)) {
                _context2.next = 16;
                break;
              }

              _context2.prev = 1;
              insideSigners = findInsideSigners(ix);
              insidePayload = encodeTransactionPayload(prepForEncoding(ix));
              _context2.next = 6;
              return Promise.all(insideSigners.map(fetchSignature(ix, insidePayload)));

            case 6:
              outsideSigners = findOutsideSigners(ix);
              outsidePayload = encodeTransactionEnvelope(_objectSpread2(_objectSpread2({}, prepForEncoding(ix)), {}, {
                payloadSigs: insideSigners.map(function (id) {
                  return {
                    address: ix.accounts[id].addr,
                    keyId: ix.accounts[id].keyId,
                    sig: ix.accounts[id].signature
                  };
                })
              }));
              _context2.next = 10;
              return Promise.all(outsideSigners.map(fetchSignature(ix, outsidePayload)));

            case 10:
              _context2.next = 16;
              break;

            case 12:
              _context2.prev = 12;
              _context2.t0 = _context2["catch"](1);
              console.error("Signatures", _context2.t0, {
                ix: ix
              });
              throw _context2.t0;

            case 16:
              return _context2.abrupt("return", ix);

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[1, 12]]);
    }));
    return _resolveSignatures.apply(this, arguments);
  }

  function fetchSignature(ix, payload) {
    return /*#__PURE__*/function () {
      var _innerFetchSignature = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(id) {
        var acct, _yield$acct$signingFu, signature;

        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                acct = ix.accounts[id];

                if (!(acct.signature != null)) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return");

              case 3:
                _context.next = 5;
                return acct.signingFunction(buildSignable(acct, payload, ix));

              case 5:
                _yield$acct$signingFu = _context.sent;
                signature = _yield$acct$signingFu.signature;
                ix.accounts[id].signature = signature;

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function innerFetchSignature(_x2) {
        return _innerFetchSignature.apply(this, arguments);
      }

      return innerFetchSignature;
    }();
  }

  function buildSignable(acct, message, ix) {
    try {
      return {
        f_type: "Signable",
        f_vsn: "1.0.1",
        message: message,
        addr: sansPrefix(acct.addr),
        keyId: acct.keyId,
        roles: acct.role,
        cadence: ix.message.cadence,
        args: ix.message.arguments.map(function (d) {
          return ix.arguments[d].asArgument;
        }),
        data: {},
        interaction: ix,
        voucher: createSignableVoucher(ix)
      };
    } catch (error) {
      console.error("buildSignable", error);
      throw error;
    }
  }

  function prepForEncoding(ix) {
    var payerAddress = sansPrefix((Array.isArray(ix.payer) ? ix.accounts[ix.payer[0]] : ix.accounts[ix.payer]).addr);
    return {
      cadence: ix.message.cadence,
      refBlock: ix.message.refBlock || null,
      computeLimit: ix.message.computeLimit,
      arguments: ix.message.arguments.map(function (id) {
        return ix.arguments[id].asArgument;
      }),
      proposalKey: {
        address: sansPrefix(ix.accounts[ix.proposer].addr),
        keyId: ix.accounts[ix.proposer].keyId,
        sequenceNum: ix.accounts[ix.proposer].sequenceNum
      },
      payer: payerAddress,
      authorizers: ix.authorizations.map(function (cid) {
        return sansPrefix(ix.accounts[cid].addr);
      }).reduce(function (prev, current) {
        return prev.find(function (item) {
          return item === current;
        }) ? prev : [].concat(_toConsumableArray(prev), [current]);
      }, [])
    };
  }

  function resolveValidators(_x) {
    return _resolveValidators.apply(this, arguments);
  }

  function _resolveValidators() {
    _resolveValidators = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var validators;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              validators = get(ix, "ix.validators", []);
              return _context.abrupt("return", pipe(ix, validators.map(function (cb) {
                return function (ix) {
                  return cb(ix, {
                    Ok: Ok,
                    Bad: Bad
                  });
                };
              })));

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolveValidators.apply(this, arguments);
  }

  function resolveFinalNormalization(_x) {
    return _resolveFinalNormalization.apply(this, arguments);
  }

  function _resolveFinalNormalization() {
    _resolveFinalNormalization = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var _i, _Object$keys, key;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              for (_i = 0, _Object$keys = Object.keys(ix.accounts); _i < _Object$keys.length; _i++) {
                key = _Object$keys[_i];
                ix.accounts[key].addr = sansPrefix(ix.accounts[key].addr);
              }

              return _context.abrupt("return", ix);

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolveFinalNormalization.apply(this, arguments);
  }

  function resolveVoucherIntercept(_x) {
    return _resolveVoucherIntercept.apply(this, arguments);
  }

  function _resolveVoucherIntercept() {
    _resolveVoucherIntercept = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var fn;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              fn = get(ix, "ix.voucher-intercept");

              if (!isFn$3(fn)) {
                _context.next = 4;
                break;
              }

              _context.next = 4;
              return fn(createSignableVoucher(ix));

            case 4:
              return _context.abrupt("return", ix);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolveVoucherIntercept.apply(this, arguments);
  }

  var DEFAULT_COMPUTE_LIMIT = 100;
  function resolveComputeLimit(_x) {
    return _resolveComputeLimit.apply(this, arguments);
  }

  function _resolveComputeLimit() {
    _resolveComputeLimit = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!isTransaction(ix)) {
                _context.next = 8;
                break;
              }

              _context.t0 = ix.message.computeLimit;

              if (_context.t0) {
                _context.next = 6;
                break;
              }

              _context.next = 5;
              return config.get("fcl.limit");

            case 5:
              _context.t0 = _context.sent;

            case 6:
              ix.message.computeLimit = _context.t0;

              if (!ix.message.computeLimit) {
                log.deprecate({
                  pkg: "FCL/SDK",
                  subject: "The built-in default compute limit (DEFAULT_COMPUTE_LIMIT=10)",
                  transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0009-deprecate-default-compute-limit"
                });
                ix.message.computeLimit = DEFAULT_COMPUTE_LIMIT;
              }

            case 8:
              return _context.abrupt("return", ix);

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolveComputeLimit.apply(this, arguments);
  }

  var noop = function noop(v) {
    return v;
  };

  var debug = function debug(key) {
    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
    return /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
        var accts, log;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:

                accts = function accts(ix) {
                  return ["\nAccounts:", {
                    proposer: ix.proposer,
                    authorizations: ix.authorizations,
                    payer: ix.payer
                  }, "\n\nDetails:", ix.accounts].filter(Boolean);
                };

                log = function log() {
                  var _console;

                  for (var _len = arguments.length, msg = new Array(_len), _key = 0; _key < _len; _key++) {
                    msg[_key] = arguments[_key];
                  }

                  (_console = console).log.apply(_console, ["debug[".concat(key, "] ---\n")].concat(msg, ["\n\n\n---"]));
                };

                _context.next = 5;
                return config.get("debug.".concat(key));

              case 5:
                if (!_context.sent) {
                  _context.next = 8;
                  break;
                }

                _context.next = 8;
                return fn(ix, log, accts);

              case 8:
                return _context.abrupt("return", ix);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
  };

  var resolve = pipe([resolveCadence, debug("cadence", function (ix, log) {
    return log(ix.message.cadence);
  }), resolveComputeLimit, debug("compute limit", function (ix, log) {
    return log(ix.message.computeLimit);
  }), resolveArguments, debug("arguments", function (ix, log) {
    return log(ix.message.arguments, ix.message);
  }), resolveAccounts, debug("accounts", function (ix, log, accts) {
    return log.apply(void 0, _toConsumableArray(accts(ix)));
  }),
  /* special */
  execFetchRef,
  /* special */
  execFetchSequenceNumber, resolveSignatures, debug("signatures", function (ix, log, accts) {
    return log.apply(void 0, _toConsumableArray(accts(ix)));
  }), resolveFinalNormalization, resolveValidators, resolveVoucherIntercept, debug("resolved", function (ix, log) {
    return log(ix);
  })]);

  function execFetchRef(_x2) {
    return _execFetchRef.apply(this, arguments);
  }

  function _execFetchRef() {
    _execFetchRef = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix) {
      var node, sendFn;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(isTransaction(ix) && ix.message.refBlock == null)) {
                _context2.next = 11;
                break;
              }

              _context2.next = 3;
              return config().get("accessNode.api");

            case 3:
              node = _context2.sent;
              _context2.next = 6;
              return config.first(["sdk.transport", "sdk.send"], send$1);

            case 6:
              sendFn = _context2.sent;
              invariant$1(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
              _context2.next = 10;
              return sendFn(build([getBlock()]), {
                config: config,
                response: response,
                Buffer: buffer.Buffer,
                ix: ixModule
              }, {
                node: node
              }).then(decodeResponse);

            case 10:
              ix.message.refBlock = _context2.sent.id;

            case 11:
              return _context2.abrupt("return", ix);

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _execFetchRef.apply(this, arguments);
  }

  function execFetchSequenceNumber(_x3) {
    return _execFetchSequenceNumber.apply(this, arguments);
  }

  function _execFetchSequenceNumber() {
    _execFetchSequenceNumber = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix) {
      var acct, node, sendFn;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!isTransaction(ix)) {
                _context3.next = 20;
                break;
              }

              acct = Object.values(ix.accounts).find(function (a) {
                return a.role.proposer;
              });
              invariant$1(acct, "Transactions require a proposer");

              if (!(acct.sequenceNum == null)) {
                _context3.next = 20;
                break;
              }

              _context3.next = 6;
              return config().get("accessNode.api");

            case 6:
              node = _context3.sent;
              _context3.next = 9;
              return config.first(["sdk.transport", "sdk.send"], send$1);

            case 9:
              sendFn = _context3.sent;
              invariant$1(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
              _context3.t0 = sendFn;
              _context3.next = 14;
              return build([getAccount(acct.addr)]);

            case 14:
              _context3.t1 = _context3.sent;
              _context3.t2 = {
                config: config,
                response: response,
                Buffer: buffer.Buffer,
                ix: ixModule
              };
              _context3.t3 = {
                node: node
              };
              _context3.next = 19;
              return (0, _context3.t0)(_context3.t1, _context3.t2, _context3.t3).then(decodeResponse).then(function (acct) {
                return acct.keys;
              }).then(function (keys) {
                return keys.find(function (key) {
                  return key.index === acct.keyId;
                });
              }).then(function (key) {
                return key.sequenceNumber;
              });

            case 19:
              ix.accounts[acct.tempId].sequenceNum = _context3.sent;

            case 20:
              return _context3.abrupt("return", ix);

            case 21:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _execFetchSequenceNumber.apply(this, arguments);
  }

  function invariant() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length > 1) {
      var predicate = args[0],
          message = args[1];
      return invariant(function (ix, _ref) {
        var Ok = _ref.Ok,
            Bad = _ref.Bad;
        return predicate ? Ok(ix) : Bad(ix, message);
      });
    }

    var fn = args[0];
    return function (ix) {
      return fn(ix, {
        Ok: Ok,
        Bad: Bad
      });
    };
  }

  var send = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
      var args,
          opts,
          sendFn,
          resolveFn,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              args = _args.length > 0 && _args[0] !== undefined ? _args[0] : [];
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              _context.next = 4;
              return config.first(["sdk.transport", "sdk.send"], opts.send || send$1);

            case 4:
              sendFn = _context.sent;
              invariant(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
              _context.next = 8;
              return config.first(["sdk.resolve"], opts.resolve || resolve);

            case 8:
              resolveFn = _context.sent;
              _context.t0 = opts.node;

              if (_context.t0) {
                _context.next = 14;
                break;
              }

              _context.next = 13;
              return config().get("accessNode.api");

            case 13:
              _context.t0 = _context.sent;

            case 14:
              opts.node = _context.t0;
              if (Array.isArray(args)) args = pipe(interaction(), args);
              _context.t1 = sendFn;
              _context.next = 19;
              return resolveFn(args);

            case 19:
              _context.t2 = _context.sent;
              _context.t3 = {
                config: config,
                response: response,
                ix: ixModule,
                Buffer: buffer.Buffer
              };
              _context.t4 = opts;
              return _context.abrupt("return", (0, _context.t1)(_context.t2, _context.t3, _context.t4));

            case 23:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function send() {
      return _ref.apply(this, arguments);
    };
  }();

  function decode(_x) {
    return _decode.apply(this, arguments);
  }

  function _decode() {
    _decode = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(response) {
      var decodersFromConfig, decoders;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return config().where(/^decoder\./);

            case 2:
              decodersFromConfig = _context.sent;
              decoders = Object.entries(decodersFromConfig).map(function (_ref) {
                var _ref2 = _slicedToArray(_ref, 2),
                    pattern = _ref2[0],
                    xform = _ref2[1];

                pattern = "/".concat(pattern.replace(/^decoder\./, ""), "$/");
                return [pattern, xform];
              });
              return _context.abrupt("return", decodeResponse(response, Object.fromEntries(decoders)));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _decode.apply(this, arguments);
  }

  var findPayloadSigners = function findPayloadSigners(voucher) {
    // Payload Signers Are: (authorizers + proposer) - payer
    var payload = new Set(voucher.authorizers);
    payload.add(voucher.proposalKey.address);
    payload["delete"](voucher.payer);
    return Array.from(payload).map(withPrefix$1);
  };

  var findEnvelopeSigners = function findEnvelopeSigners(voucher) {
    // Envelope Signers Are: (payer)
    var envelope = new Set([voucher.payer]);
    return Array.from(envelope).map(withPrefix$1);
  };

  var UnableToDetermineMessageEncodingTypeForSignerAddress = /*#__PURE__*/function (_Error) {
    _inherits(UnableToDetermineMessageEncodingTypeForSignerAddress, _Error);

    var _super = _createSuper(UnableToDetermineMessageEncodingTypeForSignerAddress);

    function UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress) {
      var _this;

      _classCallCheck(this, UnableToDetermineMessageEncodingTypeForSignerAddress);

      var msg = "\n        Encode Message From Signable Error: Unable to determine message encoding for signer addresss: ".concat(signerAddress, ". \n        Please ensure the address: ").concat(signerAddress, " is intended to sign the given transaction as specified by the transaction signable.\n      ").trim();
      _this = _super.call(this, msg);
      _this.name = "Unable To Determine Message Encoding For Signer Addresss";
      return _this;
    }

    return _createClass(UnableToDetermineMessageEncodingTypeForSignerAddress);
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  var encodeMessageFromSignable = function encodeMessageFromSignable(signable, signerAddress) {
    var payloadSigners = findPayloadSigners(signable.voucher);
    var envelopeSigners = findEnvelopeSigners(signable.voucher);
    var isPayloadSigner = payloadSigners.includes(withPrefix$1(signerAddress));
    var isEnvelopeSigner = envelopeSigners.includes(withPrefix$1(signerAddress));

    if (!isPayloadSigner && !isEnvelopeSigner) {
      throw new UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress);
    }

    var message = {
      cadence: signable.voucher.cadence,
      refBlock: signable.voucher.refBlock,
      computeLimit: signable.voucher.computeLimit,
      arguments: signable.voucher.arguments,
      proposalKey: _objectSpread2(_objectSpread2({}, signable.voucher.proposalKey), {}, {
        address: sansPrefix(signable.voucher.proposalKey.address)
      }),
      payer: sansPrefix(signable.voucher.payer),
      authorizers: signable.voucher.authorizers.map(sansPrefix),
      payloadSigs: signable.voucher.payloadSigs.map(function (ps) {
        return _objectSpread2(_objectSpread2({}, ps), {}, {
          address: sansPrefix(ps.address)
        });
      })
    };
    return isPayloadSigner ? encodeTransactionPayload(message) : encodeTransactionEnvelope(message);
  };

  function interleave() {
    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    if (!a.length && !b.length) return c;
    if (!a.length) return c;
    if (!b.length) return [].concat(_toConsumableArray(c), [a[0]]);

    var _a = _toArray(a),
        aHead = _a[0],
        aRest = _a.slice(1);

    var _b = _toArray(b),
        bHead = _b[0],
        bRest = _b.slice(1);

    if (aHead !== undefined) c.push(aHead);
    if (bHead !== undefined) c.push(bHead);
    return interleave(aRest, bRest, c);
  }

  function recApply(d) {
    return function (arg1) {
      if (typeof arg1 === "function") {
        log.deprecate({
          pkg: "FCL/SDK",
          subject: "Interopolation of functions into template literals",
          transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params"
        });
        return recApply(d)(arg1(d));
      }

      return String(arg1);
    };
  }

  function template(head) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    if (typeof head === "string") return function () {
      return head;
    };

    if (Array.isArray(head)) {
      return function (d) {
        return interleave(head, rest.map(recApply(d))).join("").trim();
      };
    }

    return head;
  }

  function validator(cb) {
    return update("ix.validators", function (validators) {
      return Array.isArray(validators) ? validators.push(cb) : [cb];
    });
  }

  function atBlockHeight(height) {
    return pipe([function (ix) {
      ix.block.height = height;
      return ix;
    }, validator(function (ix) {
      if (typeof ix.block.isSealed === "boolean") throw new Error("Unable to specify both block height and isSealed.");
      if (ix.block.id) throw new Error("Unable to specify both block height and block id.");
      return ix;
    })]);
  }

  function atBlockId(id) {
    return pipe([function (ix) {
      ix.block.id = id;
      return Ok(ix);
    }, validator(function (ix, _ref) {
      var Ok = _ref.Ok,
          Bad = _ref.Bad;
      if (isGetAccount(ix)) return Bad(ix, "Unable to specify a block id with a Get Account interaction.");
      if (typeof ix.block.isSealed === "boolean") return Bad(ix, "Unable to specify both block id and isSealed.");
      if (ix.block.height) return Bad(ix, "Unable to specify both block id and block height.");
      return Ok(ix);
    })]);
  }

  function account(address) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        height = _ref.height,
        id = _ref.id;

    var opts = arguments.length > 2 ? arguments[2] : undefined;
    invariant$1(!(id && height), "Method: account -- Cannot pass \"id\" and \"height\" simultaneously"); // Get account by ID

    if (id) return send([getAccount(address), atBlockId(id)], opts).then(decodeResponse); // Get account by height

    if (height) return send([getAccount(address), atBlockHeight(height)], opts).then(decodeResponse);
    return send([getAccount(address)], opts).then(decodeResponse);
  }

  function block() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$sealed = _ref.sealed,
        sealed = _ref$sealed === void 0 ? false : _ref$sealed,
        id = _ref.id,
        height = _ref.height;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    invariant$1(!(sealed && id || sealed && height), "Method: block -- Cannot pass \"sealed\" with \"id\" or \"height\"");
    invariant$1(!(id && height), "Method: block -- Cannot pass \"id\" and \"height\" simultaneously"); // Get block by ID

    if (id) return send([getBlock(), atBlockId(id)], opts).then(decodeResponse); // Get block by height

    if (height) return send([getBlock(), atBlockHeight(height)], opts).then(decodeResponse); // Get latest block

    return send([getBlock(sealed)], opts).then(decodeResponse);
  }

  function authorizations() {
    var ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return pipe(ax.map(function (authz) {
      return prepAccount(authz, {
        role: AUTHORIZER
      });
    }));
  }
  function authorization(addr, signingFunction, keyId, sequenceNum) {
    return {
      addr: addr,
      signingFunction: signingFunction,
      keyId: keyId,
      sequenceNum: sequenceNum
    };
  }

  function getEvents(eventType, start, end) {
    if (typeof start !== "undefined" || typeof end !== "undefined") {
      log.deprecate({
        pkg: "FCL/SDK",
        subject: "Passing a start and end into getEvents",
        transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0005-deprecate-start-end-get-events-builder"
      });
    }

    return pipe([makeGetEvents, function (ix) {
      ix.events.eventType = eventType;
      ix.events.start = start;
      ix.events.end = end;
      return Ok(ix);
    }]);
  }

  function getEventsAtBlockHeightRange(eventType, start, end) {
    return pipe([makeGetEvents, function (ix) {
      ix.events.eventType = eventType;
      ix.events.start = start;
      ix.events.end = end;
      return Ok(ix);
    }]);
  }

  function getEventsAtBlockIds(eventType) {
    var blockIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return pipe([makeGetEvents, function (ix) {
      ix.events.eventType = eventType;
      ix.events.blockIds = blockIds;
      return Ok(ix);
    }]);
  }

  function getBlockHeader() {
    var isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return pipe([makeGetBlockHeader, function (ix) {
      ix.block.isSealed = isSealed;
      return Ok(ix);
    }]);
  }

  function getCollection() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return pipe([makeGetCollection, function (ix) {
      ix.collection.id = id;
      return ix;
    }]);
  }

  function getTransactionStatus(transactionId) {
    return pipe([makeGetTransactionStatus, function (ix) {
      ix.transaction.id = transactionId;
      return Ok(ix);
    }]);
  }

  function getTransaction(transactionId) {
    return pipe([makeGetTransaction, function (ix) {
      ix.transaction.id = transactionId;
      return Ok(ix);
    }]);
  }

  function limit(computeLimit) {
    return function (ix) {
      ix.message.computeLimit = computeLimit;
      return ix;
    };
  }

  function args() {
    var ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return pipe(ax.map(makeArgument));
  }
  function arg(value, xform) {
    return {
      value: value,
      xform: xform
    };
  }

  function proposer(_x) {
    return _proposer.apply(this, arguments);
  }

  function _proposer() {
    _proposer = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(authz) {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", prepAccount(authz, {
                role: PROPOSER
              }));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _proposer.apply(this, arguments);
  }

  function payer(_x) {
    return _payer.apply(this, arguments);
  }

  function _payer() {
    _payer = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(authz) {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", prepAccount(authz, {
                role: PAYER
              }));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _payer.apply(this, arguments);
  }

  function ping() {
    return makePing;
  }

  function ref(refBlock) {
    return pipe([function (ix) {
      ix.message.refBlock = refBlock;
      return Ok(ix);
    }]);
  }

  function script() {
    return pipe([makeScript, put("ix.cadence", template.apply(void 0, arguments))]);
  }

  var DEFAULT_SCRIPT_ACCOUNTS = [];
  var DEFUALT_REF = null;
  function transaction() {
    return pipe([makeTransaction, put("ix.cadence", template.apply(void 0, arguments)), function (ix) {
      ix.message.refBlock = ix.message.refBlock || DEFUALT_REF;
      ix.authorizations = ix.authorizations || DEFAULT_SCRIPT_ACCOUNTS;
      return Ok(ix);
    }]);
  }

  function voucherIntercept(fn) {
    return put("ix.voucher-intercept", fn);
  }

  var resolveProposerSequenceNumber = function resolveProposerSequenceNumber(_ref) {
    var node = _ref.node;
    return /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
        var sendFn, response$1, decoded;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isTransaction(ix)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", Ok(ix));

              case 2:
                if (!ix.accounts[ix.proposer].sequenceNum) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", Ok(ix));

              case 4:
                _context.next = 6;
                return config.first(["sdk.transport", "sdk.send"], send$1);

              case 6:
                sendFn = _context.sent;
                invariant$1(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
                _context.t0 = sendFn;
                _context.next = 11;
                return build([getAccount(ix.accounts[ix.proposer].addr)]);

              case 11:
                _context.t1 = _context.sent;
                _context.t2 = {
                  config: config,
                  response: response,
                  Buffer: buffer.Buffer,
                  ix: ixModule
                };
                _context.t3 = {
                  node: node
                };
                _context.next = 16;
                return (0, _context.t0)(_context.t1, _context.t2, _context.t3);

              case 16:
                response$1 = _context.sent;
                _context.next = 19;
                return decodeResponse(response$1);

              case 19:
                decoded = _context.sent;
                ix.accounts[ix.proposer].sequenceNum = decoded.keys[ix.accounts[ix.proposer].keyId].sequenceNumber;
                return _context.abrupt("return", Ok(ix));

              case 22:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }();
  };

  function mockAccountResponse(ix) {
    var numberOfKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
    // prettier-ignore
    invariant$1(ix.account, "mockAccountResponse(ix) -- ix.account is missing", ix); // prettier-ignore

    invariant$1(ix.account.addr, "mockAccountResponse(ix) -- ix.account.addr is missing", ix);
    var address = ix.account.addr;
    return {
      account: {
        addr: address,
        keys: Array.from({
          length: numberOfKeys
        }, function (_, i) {
          return {
            index: i,
            sequenceNumber: 42
          };
        })
      }
    };
  }
  function mockGetBlockResponse(ix) {
    return {
      tag: "GET_BLOCK",
      block: {
        id: "32"
      }
    };
  }

  var identity = function identity(v) {
    return v;
  };

  function mockSend() {
    var fallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;
    return /*#__PURE__*/function () {
      var _execSend = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return ix;

              case 2:
                ix = _context.sent;
                _context.t0 = true;
                _context.next = _context.t0 === isGetAccount(ix) ? 6 : _context.t0 === isGetBlock(ix) ? 7 : 8;
                break;

              case 6:
                return _context.abrupt("return", mockAccountResponse(ix));

              case 7:
                return _context.abrupt("return", mockGetBlockResponse());

              case 8:
                return _context.abrupt("return", fallback(ix));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function execSend(_x) {
        return _execSend.apply(this, arguments);
      }

      return execSend;
    }();
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  var _excluded = ["tempId"];
  var idof = function idof(acct) {
    return "".concat(withPrefix$1(acct.addr), "-").concat(acct.keyId);
  };
  function sig(opts) {
    return ["SIGNATURE", opts.addr, opts.keyId].join(".");
  }
  function authzFn() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (account) {
      var acct = _objectSpread2(_objectSpread2(_objectSpread2({}, account), opts), {}, {
        signingFunction: opts.signingFunction || account.signingFunction || fallbackSigningFunction
      });

      return acct;

      function fallbackSigningFunction(signable) {
        return {
          addr: acct.addr,
          keyId: acct.keyId,
          signature: sig(acct)
        };
      }
    };
  }
  function authzResolve() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (account) {
      var tempId = opts.tempId,
          rest = _objectWithoutProperties(opts, _excluded);

      return _objectSpread2(_objectSpread2({}, account), {}, {
        tempId: tempId || "WITH_RESOLVE",
        resolve: authzFn(rest)
      });
    };
  }
  var ROLE = {
    proposer: false,
    authorizer: false,
    payer: false
  };

  function authzResolveMany() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (account) {
      var tempId = opts.tempId || "AUTHZ_RESOLVE_MANY";
      return _objectSpread2(_objectSpread2({}, account), {}, {
        tempId: tempId,
        resolve: function resolve() {
          return [opts.proposer && authzFn(opts.proposer)({
            role: _objectSpread2(_objectSpread2({}, ROLE), {}, {
              proposer: true
            })
          })].concat(_toConsumableArray(opts.authorizations.map(authzFn).map(function (d) {
            return d({
              role: _objectSpread2(_objectSpread2({}, ROLE), {}, {
                authorizer: true
              })
            });
          })), [opts.payer && authzFn(opts.payer)({
            role: _objectSpread2(_objectSpread2({}, ROLE), {}, {
              payer: true
            })
          })]).filter(Boolean);
        }
      });
    };
  }

  var run = function run() {
    var fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return build([ref("123")].concat(_toConsumableArray(fns))).then(resolve);
  };

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    mockSend: mockSend,
    authzFn: authzFn,
    authzResolve: authzResolve,
    authzResolveMany: authzResolveMany,
    sig: sig,
    idof: idof,
    run: run
  });

  var VERSION = "1.1.2" ;

  var params = function params(_params) {
    return log.deprecate({
      pkg: "FCL/SDK",
      message: "The params builder has been removed from the Flow JS-SDK/FCL.",
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params",
      level: LEVELS.error
    });
  };
  var param = function param(params) {
    return log.deprecate({
      pkg: "FCL/SDK",
      message: "The param builder has been removed from the Flow JS-SDK/FCL.",
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params",
      level: LEVELS.error
    });
  };

  exports.TestUtils = index;
  exports.VERSION = VERSION;
  exports.account = account;
  exports.arg = arg;
  exports.args = args;
  exports.atBlockHeight = atBlockHeight;
  exports.atBlockId = atBlockId;
  exports.authorization = authorization;
  exports.authorizations = authorizations;
  exports.block = block;
  exports.build = build;
  exports.cadence = template;
  exports.cdc = template;
  exports.config = config;
  exports.createSignableVoucher = createSignableVoucher;
  exports.decode = decode;
  exports.destroy = destroy;
  exports.encodeMessageFromSignable = encodeMessageFromSignable;
  exports.encodeTransactionEnvelope = encodeTransactionEnvelope;
  exports.encodeTransactionPayload = encodeTransactionPayload;
  exports.encodeTxIdFromVoucher = encodeTxIdFromVoucher;
  exports.get = get;
  exports.getAccount = getAccount;
  exports.getBlock = getBlock;
  exports.getBlockHeader = getBlockHeader;
  exports.getCollection = getCollection;
  exports.getEvents = getEvents;
  exports.getEventsAtBlockHeightRange = getEventsAtBlockHeightRange;
  exports.getEventsAtBlockIds = getEventsAtBlockIds;
  exports.getTransaction = getTransaction;
  exports.getTransactionStatus = getTransactionStatus;
  exports.interaction = interaction;
  exports.invariant = invariant;
  exports.isBad = isBad;
  exports.isGetAccount = isGetAccount;
  exports.isGetBlock = isGetBlock;
  exports.isGetBlockHeader = isGetBlockHeader;
  exports.isGetCollection = isGetCollection;
  exports.isGetEvents = isGetEvents;
  exports.isGetTransaction = isGetTransaction;
  exports.isGetTransactionStatus = isGetTransactionStatus;
  exports.isOk = isOk;
  exports.isPing = isPing;
  exports.isScript = isScript;
  exports.isTransaction = isTransaction;
  exports.isUnknown = isUnknown;
  exports.limit = limit;
  exports.param = param;
  exports.params = params;
  exports.payer = payer;
  exports.ping = ping;
  exports.pipe = pipe;
  exports.proposer = proposer;
  exports.put = put;
  exports.ref = ref;
  exports.resolve = resolve;
  exports.resolveAccounts = resolveAccounts;
  exports.resolveArguments = resolveArguments;
  exports.resolveCadence = resolveCadence;
  exports.resolveFinalNormalization = resolveFinalNormalization;
  exports.resolveProposerSequenceNumber = resolveProposerSequenceNumber;
  exports.resolveRefBlockId = resolveRefBlockId;
  exports.resolveSignatures = resolveSignatures;
  exports.resolveValidators = resolveValidators;
  exports.resolveVoucherIntercept = resolveVoucherIntercept;
  exports.script = script;
  exports.send = send;
  exports.transaction = transaction;
  exports.update = update;
  exports.validator = validator;
  exports.voucherIntercept = voucherIntercept;
  exports.voucherToTxId = voucherToTxId;
  exports.why = why;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=sdk.umd.js.map

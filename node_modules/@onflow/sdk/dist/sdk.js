'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var logger = require('@onflow/util-logger');
var _toArray = require('@babel/runtime/helpers/toArray');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _createForOfIteratorHelper = require('@babel/runtime/helpers/createForOfIteratorHelper');
var _typeof = require('@babel/runtime/helpers/typeof');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var utilInvariant = require('@onflow/util-invariant');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var config = require('@onflow/config');
var rlp = require('@onflow/rlp');
var transportHttp = require('@onflow/transport-http');
var utilAddress = require('@onflow/util-address');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var sha3 = require('sha3');
var _createClass = require('@babel/runtime/helpers/createClass');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _inherits = require('@babel/runtime/helpers/inherits');
var _createSuper = require('@babel/runtime/helpers/createSuper');
var _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');
var utilTemplate = require('@onflow/util-template');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var logger__namespace = /*#__PURE__*/_interopNamespace(logger);
var _toArray__default = /*#__PURE__*/_interopDefaultLegacy(_toArray);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _objectSpread__default = /*#__PURE__*/_interopDefaultLegacy(_objectSpread);
var _createForOfIteratorHelper__default = /*#__PURE__*/_interopDefaultLegacy(_createForOfIteratorHelper);
var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _createSuper__default = /*#__PURE__*/_interopDefaultLegacy(_createSuper);
var _wrapNativeSuper__default = /*#__PURE__*/_interopDefaultLegacy(_wrapNativeSuper);
var _objectWithoutProperties__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutProperties);

var UNKNOWN
/*                       */
= "UNKNOWN";
var SCRIPT
/*                        */
= "SCRIPT";
var TRANSACTION
/*                   */
= "TRANSACTION";
var GET_TRANSACTION_STATUS
/*        */
= "GET_TRANSACTION_STATUS";
var GET_ACCOUNT
/*                   */
= "GET_ACCOUNT";
var GET_EVENTS
/*                    */
= "GET_EVENTS";
var PING
/*                          */
= "PING";
var GET_TRANSACTION
/*               */
= "GET_TRANSACTION";
var GET_BLOCK
/*                     */
= "GET_BLOCK";
var GET_BLOCK_HEADER
/*              */
= "GET_BLOCK_HEADER";
var GET_COLLECTION
/*                */
= "GET_COLLECTION";
var BAD
/* */
= "BAD";
var OK
/*  */
= "OK";
var ACCOUNT
/*  */
= "ACCOUNT";
var PARAM
/*    */
= "PARAM";
var ARGUMENT
/* */
= "ARGUMENT";
var AUTHORIZER
/* */
= "authorizer";
var PAYER
/*      */
= "payer";
var PROPOSER
/*   */
= "proposer";
var ACCT = "{\n  \"kind\":\"".concat(ACCOUNT, "\",\n  \"tempId\":null,\n  \"addr\":null,\n  \"keyId\":null,\n  \"sequenceNum\":null,\n  \"signature\":null,\n  \"signingFunction\":null,\n  \"resolve\":null,\n  \"role\": {\n    \"proposer\":false,\n    \"authorizer\":false,\n    \"payer\":false,\n    \"param\":false\n  }\n}");
var ARG = "{\n  \"kind\":\"".concat(ARGUMENT, "\",\n  \"tempId\":null,\n  \"value\":null,\n  \"asArgument\":null,\n  \"xform\":null,\n  \"resolve\": null,\n  \"resolveArgument\": null\n}");
var IX = "{\n  \"tag\":\"".concat(UNKNOWN, "\",\n  \"assigns\":{},\n  \"status\":\"").concat(OK, "\",\n  \"reason\":null,\n  \"accounts\":{},\n  \"params\":{},\n  \"arguments\":{},\n  \"message\": {\n    \"cadence\":null,\n    \"refBlock\":null,\n    \"computeLimit\":null,\n    \"proposer\":null,\n    \"payer\":null,\n    \"authorizations\":[],\n    \"params\":[],\n    \"arguments\":[]\n  },\n  \"proposer\":null,\n  \"authorizations\":[],\n  \"payer\":[],\n  \"events\": {\n    \"eventType\":null,\n    \"start\":null,\n    \"end\":null,\n    \"blockIds\":[]\n  },\n  \"transaction\": {\n    \"id\":null\n  },\n  \"block\": {\n    \"id\":null,\n    \"height\":null,\n    \"isSealed\":null\n  },\n  \"account\": {\n    \"addr\":null\n  },\n  \"collection\": {\n    \"id\":null\n  }\n}");
var KEYS = new Set(Object.keys(JSON.parse(IX)));
var interaction = function interaction() {
  return JSON.parse(IX);
};
var CHARS = "abcdefghijklmnopqrstuvwxyz0123456789".split("");

var randChar = function randChar() {
  return CHARS[~~(Math.random() * CHARS.length)];
};

var uuid = function uuid() {
  return Array.from({
    length: 10
  }, randChar).join("");
};
var isNumber$1 = function isNumber(d) {
  return typeof d === "number";
};
var isArray$1 = function isArray(d) {
  return Array.isArray(d);
};
var isObj = function isObj(d) {
  return d !== null && _typeof__default["default"](d) === "object";
};
var isNull = function isNull(d) {
  return d == null;
};
var isFn$3 = function isFn(d) {
  return typeof d === "function";
};
var isInteraction = function isInteraction(ix) {
  if (!isObj(ix) || isNull(ix) || isNumber$1(ix)) return false;

  var _iterator = _createForOfIteratorHelper__default["default"](KEYS),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      if (!ix.hasOwnProperty(key)) return false;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return true;
};
var Ok = function Ok(ix) {
  ix.status = OK;
  return ix;
};
var Bad = function Bad(ix, reason) {
  ix.status = BAD;
  ix.reason = reason;
  return ix;
};

var makeIx = function makeIx(wat) {
  return function (ix) {
    ix.tag = wat;
    return Ok(ix);
  };
};

var prepAccountKeyId = function prepAccountKeyId(acct) {
  if (acct.keyId == null) return acct;
  utilInvariant.invariant(!isNaN(parseInt(acct.keyId)), "account.keyId must be an integer");
  return _objectSpread__default["default"](_objectSpread__default["default"]({}, acct), {}, {
    keyId: parseInt(acct.keyId)
  });
};

var prepAccount = function prepAccount(acct) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (ix) {
    utilInvariant.invariant(typeof acct === "function" || _typeof__default["default"](acct) === "object", "prepAccount must be passed an authorization function or an account object");
    utilInvariant.invariant(opts.role != null, "Account must have a role");
    var ACCOUNT = JSON.parse(ACCT);
    var role = opts.role;
    var tempId = uuid();
    if (acct.authorization && isFn$3(acct.authorization)) acct = {
      resolve: acct.authorization
    };
    if (!acct.authorization && isFn$3(acct)) acct = {
      resolve: acct
    };
    var resolve = acct.resolve;
    if (resolve) acct.resolve = function (acct) {
      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        rest[_key - 1] = arguments[_key];
      }

      return [resolve, prepAccountKeyId].reduce( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(d, fn) {
          return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.t0 = fn;
                  _context.t1 = void 0;
                  _context.next = 4;
                  return d;

                case 4:
                  _context.t2 = _context.sent;
                  _context.t3 = [_context.t2].concat(rest);
                  return _context.abrupt("return", _context.t0.apply.call(_context.t0, _context.t1, _context.t3));

                case 7:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }(), acct);
    };
    acct = prepAccountKeyId(acct);
    ix.accounts[tempId] = _objectSpread__default["default"](_objectSpread__default["default"](_objectSpread__default["default"]({}, ACCOUNT), {}, {
      tempId: tempId
    }, acct), {}, {
      role: _objectSpread__default["default"](_objectSpread__default["default"](_objectSpread__default["default"]({}, ACCOUNT.role), _typeof__default["default"](acct.role) === "object" ? acct.role : {}), {}, _defineProperty__default["default"]({}, role, true))
    });

    if (role === AUTHORIZER) {
      ix.authorizations.push(tempId);
    } else if (role === PAYER) {
      ix.payer.push(tempId);
    } else {
      ix[role] = tempId;
    }

    return ix;
  };
};
var makeArgument = function makeArgument(arg) {
  return function (ix) {
    var tempId = uuid();
    ix.message.arguments.push(tempId);
    ix.arguments[tempId] = JSON.parse(ARG);
    ix.arguments[tempId].tempId = tempId;
    ix.arguments[tempId].value = arg.value;
    ix.arguments[tempId].asArgument = arg.asArgument;
    ix.arguments[tempId].xform = arg.xform;
    ix.arguments[tempId].resolve = arg.resolve;
    ix.arguments[tempId].resolveArgument = isFn$3(arg.resolveArgument) ? arg.resolveArgument.bind(arg) : arg.resolveArgument;
    return Ok(ix);
  };
};
var makeUnknown
/*                 */
= makeIx(UNKNOWN);
var makeScript
/*                  */
= makeIx(SCRIPT);
var makeTransaction
/*             */
= makeIx(TRANSACTION);
var makeGetTransactionStatus
/*    */
= makeIx(GET_TRANSACTION_STATUS);
var makeGetTransaction
/*          */
= makeIx(GET_TRANSACTION);
var makeGetAccount
/*              */
= makeIx(GET_ACCOUNT);
var makeGetEvents
/*               */
= makeIx(GET_EVENTS);
var makePing
/*                    */
= makeIx(PING);
var makeGetBlock
/*                */
= makeIx(GET_BLOCK);
var makeGetBlockHeader
/*          */
= makeIx(GET_BLOCK_HEADER);
var makeGetCollection
/*           */
= makeIx(GET_COLLECTION);

var is = function is(wat) {
  return function (ix) {
    return ix.tag === wat;
  };
};

var isUnknown
/*                 */
= is(UNKNOWN);
var isScript
/*                  */
= is(SCRIPT);
var isTransaction
/*             */
= is(TRANSACTION);
var isGetTransactionStatus
/*    */
= is(GET_TRANSACTION_STATUS);
var isGetTransaction
/*          */
= is(GET_TRANSACTION);
var isGetAccount
/*              */
= is(GET_ACCOUNT);
var isGetEvents
/*               */
= is(GET_EVENTS);
var isPing
/*                    */
= is(PING);
var isGetBlock
/*                */
= is(GET_BLOCK);
var isGetBlockHeader
/*          */
= is(GET_BLOCK_HEADER);
var isGetCollection
/*           */
= is(GET_COLLECTION);
var isOk
/*  */
= function isOk
/*  */
(ix) {
  return ix.status === OK;
};
var isBad
/* */
= function isBad
/* */
(ix) {
  return ix.status === BAD;
};
var why
/*   */
= function why
/*   */
(ix) {
  return ix.reason;
};
var isAccount
/*  */
= function isAccount
/*  */
(account) {
  return account.kind === ACCOUNT;
};
var isParam
/*    */
= function isParam
/*    */
(param) {
  return param.kind === PARAM;
};
var isArgument
/* */
= function isArgument
/* */
(argument) {
  return argument.kind === ARGUMENT;
};

var hardMode = function hardMode(ix) {
  for (var _i = 0, _Object$keys = Object.keys(ix); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    if (!KEYS.has(key)) throw new Error("\"".concat(key, "\" is an invalid root level Interaction property."));
  }

  return ix;
};

var recPipe = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(ix) {
    var fns,
        _fns,
        hd,
        rest,
        cur,
        _args2 = arguments;

    return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            fns = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : [];
            _context2.prev = 1;
            _context2.t0 = hardMode;
            _context2.next = 5;
            return ix;

          case 5:
            _context2.t1 = _context2.sent;
            ix = (0, _context2.t0)(_context2.t1);

            if (!isBad(ix)) {
              _context2.next = 9;
              break;
            }

            throw new Error("Interaction Error: ".concat(ix.reason));

          case 9:
            if (fns.length) {
              _context2.next = 11;
              break;
            }

            return _context2.abrupt("return", ix);

          case 11:
            _fns = _toArray__default["default"](fns), hd = _fns[0], rest = _fns.slice(1);
            _context2.next = 14;
            return hd;

          case 14:
            cur = _context2.sent;

            if (!isFn$3(cur)) {
              _context2.next = 17;
              break;
            }

            return _context2.abrupt("return", recPipe(cur(ix), rest));

          case 17:
            if (!(isNull(cur) || !cur)) {
              _context2.next = 19;
              break;
            }

            return _context2.abrupt("return", recPipe(ix, rest));

          case 19:
            if (!isInteraction(cur)) {
              _context2.next = 21;
              break;
            }

            return _context2.abrupt("return", recPipe(cur, rest));

          case 21:
            throw new Error("Invalid Interaction Composition");

          case 24:
            _context2.prev = 24;
            _context2.t2 = _context2["catch"](1);
            throw _context2.t2;

          case 27:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[1, 24]]);
  }));

  return function recPipe(_x3) {
    return _ref2.apply(this, arguments);
  };
}();

var pipe = function pipe() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  var arg1 = args[0],
      arg2 = args[1];
  if (isArray$1(arg1) && arg2 == null) return function (d) {
    return pipe(d, arg1);
  };
  return recPipe(arg1, arg2);
};

var identity$1 = function identity(v) {
  return v;
};

var get = function get(ix, key, fallback) {
  return ix.assigns[key] == null ? fallback : ix.assigns[key];
};
var put = function put(key, value) {
  return function (ix) {
    ix.assigns[key] = value;
    return Ok(ix);
  };
};
var update = function update(key) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;
  return function (ix) {
    ix.assigns[key] = fn(ix.assigns[key], ix);
    return Ok(ix);
  };
};
var destroy = function destroy(key) {
  return function (ix) {
    delete ix.assigns[key];
    return Ok(ix);
  };
};

var ixModule = /*#__PURE__*/Object.freeze({
  __proto__: null,
  UNKNOWN: UNKNOWN,
  SCRIPT: SCRIPT,
  TRANSACTION: TRANSACTION,
  GET_TRANSACTION_STATUS: GET_TRANSACTION_STATUS,
  GET_ACCOUNT: GET_ACCOUNT,
  GET_EVENTS: GET_EVENTS,
  PING: PING,
  GET_TRANSACTION: GET_TRANSACTION,
  GET_BLOCK: GET_BLOCK,
  GET_BLOCK_HEADER: GET_BLOCK_HEADER,
  GET_COLLECTION: GET_COLLECTION,
  BAD: BAD,
  OK: OK,
  ACCOUNT: ACCOUNT,
  PARAM: PARAM,
  ARGUMENT: ARGUMENT,
  AUTHORIZER: AUTHORIZER,
  PAYER: PAYER,
  PROPOSER: PROPOSER,
  interaction: interaction,
  uuid: uuid,
  isNumber: isNumber$1,
  isArray: isArray$1,
  isObj: isObj,
  isNull: isNull,
  isFn: isFn$3,
  isInteraction: isInteraction,
  Ok: Ok,
  Bad: Bad,
  prepAccount: prepAccount,
  makeArgument: makeArgument,
  makeUnknown: makeUnknown,
  makeScript: makeScript,
  makeTransaction: makeTransaction,
  makeGetTransactionStatus: makeGetTransactionStatus,
  makeGetTransaction: makeGetTransaction,
  makeGetAccount: makeGetAccount,
  makeGetEvents: makeGetEvents,
  makePing: makePing,
  makeGetBlock: makeGetBlock,
  makeGetBlockHeader: makeGetBlockHeader,
  makeGetCollection: makeGetCollection,
  isUnknown: isUnknown,
  isScript: isScript,
  isTransaction: isTransaction,
  isGetTransactionStatus: isGetTransactionStatus,
  isGetTransaction: isGetTransaction,
  isGetAccount: isGetAccount,
  isGetEvents: isGetEvents,
  isPing: isPing,
  isGetBlock: isGetBlock,
  isGetBlockHeader: isGetBlockHeader,
  isGetCollection: isGetCollection,
  isOk: isOk,
  isBad: isBad,
  why: why,
  isAccount: isAccount,
  isParam: isParam,
  isArgument: isArgument,
  pipe: pipe,
  get: get,
  put: put,
  update: update,
  destroy: destroy
});

function build() {
  var fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return pipe(interaction(), fns);
}

var DEFAULT_RESPONSE = "{\n    \"tag\":null,\n    \"transaction\":null,\n    \"transactionStatus\":null,\n    \"transactionId\":null,\n    \"encodedData\":null,\n    \"events\":null,\n    \"account\":null,\n    \"block\":null,\n    \"blockHeader\":null,\n    \"latestBlock\":null,\n    \"collection\":null\n}";
var response = function response() {
  return JSON.parse(DEFAULT_RESPONSE);
};

function getBlock() {
  var isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return pipe([makeGetBlock, function (ix) {
    ix.block.isSealed = isSealed;
    return Ok(ix);
  }]);
}

function getAccount(addr) {
  return pipe([makeGetAccount, function (ix) {
    ix.account.addr = utilAddress.sansPrefix(addr);
    return Ok(ix);
  }]);
}

var latestBlockDeprecationNotice = function latestBlockDeprecationNotice() {
  logger.log.deprecate({
    pkg: "@onflow/decode",
    subject: "Operating upon data of the latestBlock field of the response object",
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field"
  });
};

var decodeImplicit = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(i) {
    return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", i);

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function decodeImplicit(_x4) {
    return _ref2.apply(this, arguments);
  };
}();

var decodeVoid = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3() {
    return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", null);

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function decodeVoid() {
    return _ref3.apply(this, arguments);
  };
}();

var decodeType = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4(type) {
    return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", type.staticType);

          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function decodeType(_x5) {
    return _ref4.apply(this, arguments);
  };
}();

var decodePath = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee5(path) {
    return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            return _context5.abrupt("return", {
              domain: path.domain,
              identifier: path.identifier
            });

          case 1:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function decodePath(_x6) {
    return _ref5.apply(this, arguments);
  };
}();

var decodeCapability = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee6(cap) {
    return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", {
              path: cap.path,
              address: cap.address,
              borrowType: cap.borrowType
            });

          case 1:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));

  return function decodeCapability(_x7) {
    return _ref6.apply(this, arguments);
  };
}();

var decodeOptional = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee7(optional, decoders, stack) {
    return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (!optional) {
              _context7.next = 6;
              break;
            }

            _context7.next = 3;
            return recurseDecode(optional, decoders, stack);

          case 3:
            _context7.t0 = _context7.sent;
            _context7.next = 7;
            break;

          case 6:
            _context7.t0 = null;

          case 7:
            return _context7.abrupt("return", _context7.t0);

          case 8:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7);
  }));

  return function decodeOptional(_x8, _x9, _x10) {
    return _ref7.apply(this, arguments);
  };
}();

var decodeReference = /*#__PURE__*/function () {
  var _ref8 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee8(v) {
    return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            return _context8.abrupt("return", {
              address: v.address,
              type: v.type
            });

          case 1:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));

  return function decodeReference(_x11) {
    return _ref8.apply(this, arguments);
  };
}();

var decodeArray = /*#__PURE__*/function () {
  var _ref9 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee10(array, decoders, stack) {
    return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return Promise.all(array.map(function (v) {
              return new Promise( /*#__PURE__*/function () {
                var _ref10 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee9(res) {
                  return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
                    while (1) {
                      switch (_context9.prev = _context9.next) {
                        case 0:
                          _context9.t0 = res;
                          _context9.next = 3;
                          return recurseDecode(v, decoders, [].concat(_toConsumableArray__default["default"](stack), [v.type]));

                        case 3:
                          _context9.t1 = _context9.sent;
                          return _context9.abrupt("return", (0, _context9.t0)(_context9.t1));

                        case 5:
                        case "end":
                          return _context9.stop();
                      }
                    }
                  }, _callee9);
                }));

                return function (_x15) {
                  return _ref10.apply(this, arguments);
                };
              }());
            }));

          case 2:
            return _context10.abrupt("return", _context10.sent);

          case 3:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));

  return function decodeArray(_x12, _x13, _x14) {
    return _ref9.apply(this, arguments);
  };
}();

var decodeDictionary = /*#__PURE__*/function () {
  var _ref11 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee12(dictionary, decoders, stack) {
    return _regeneratorRuntime__default["default"].wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            _context12.next = 2;
            return dictionary.reduce( /*#__PURE__*/function () {
              var _ref12 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee11(acc, v) {
                return _regeneratorRuntime__default["default"].wrap(function _callee11$(_context11) {
                  while (1) {
                    switch (_context11.prev = _context11.next) {
                      case 0:
                        _context11.next = 2;
                        return acc;

                      case 2:
                        acc = _context11.sent;
                        _context11.next = 5;
                        return recurseDecode(v.key, decoders, [].concat(_toConsumableArray__default["default"](stack), [v.key]));

                      case 5:
                        _context11.t0 = _context11.sent;
                        _context11.next = 8;
                        return recurseDecode(v.value, decoders, [].concat(_toConsumableArray__default["default"](stack), [v.key]));

                      case 8:
                        acc[_context11.t0] = _context11.sent;
                        return _context11.abrupt("return", acc);

                      case 10:
                      case "end":
                        return _context11.stop();
                    }
                  }
                }, _callee11);
              }));

              return function (_x19, _x20) {
                return _ref12.apply(this, arguments);
              };
            }(), Promise.resolve({}));

          case 2:
            return _context12.abrupt("return", _context12.sent);

          case 3:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));

  return function decodeDictionary(_x16, _x17, _x18) {
    return _ref11.apply(this, arguments);
  };
}();

var decodeComposite = /*#__PURE__*/function () {
  var _ref13 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee14(composite, decoders, stack) {
    var decoded, decoder;
    return _regeneratorRuntime__default["default"].wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            _context14.next = 2;
            return composite.fields.reduce( /*#__PURE__*/function () {
              var _ref14 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee13(acc, v) {
                return _regeneratorRuntime__default["default"].wrap(function _callee13$(_context13) {
                  while (1) {
                    switch (_context13.prev = _context13.next) {
                      case 0:
                        _context13.next = 2;
                        return acc;

                      case 2:
                        acc = _context13.sent;
                        _context13.next = 5;
                        return recurseDecode(v.value, decoders, [].concat(_toConsumableArray__default["default"](stack), [v.name]));

                      case 5:
                        acc[v.name] = _context13.sent;
                        return _context13.abrupt("return", acc);

                      case 7:
                      case "end":
                        return _context13.stop();
                    }
                  }
                }, _callee13);
              }));

              return function (_x24, _x25) {
                return _ref14.apply(this, arguments);
              };
            }(), Promise.resolve({}));

          case 2:
            decoded = _context14.sent;
            decoder = composite.id && decoderLookup(decoders, composite.id);

            if (!decoder) {
              _context14.next = 10;
              break;
            }

            _context14.next = 7;
            return decoder(decoded);

          case 7:
            _context14.t0 = _context14.sent;
            _context14.next = 11;
            break;

          case 10:
            _context14.t0 = decoded;

          case 11:
            return _context14.abrupt("return", _context14.t0);

          case 12:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14);
  }));

  return function decodeComposite(_x21, _x22, _x23) {
    return _ref13.apply(this, arguments);
  };
}();

var defaultDecoders = {
  UInt: decodeImplicit,
  Int: decodeImplicit,
  UInt8: decodeImplicit,
  Int8: decodeImplicit,
  UInt16: decodeImplicit,
  Int16: decodeImplicit,
  UInt32: decodeImplicit,
  Int32: decodeImplicit,
  UInt64: decodeImplicit,
  Int64: decodeImplicit,
  UInt128: decodeImplicit,
  Int128: decodeImplicit,
  UInt256: decodeImplicit,
  Int256: decodeImplicit,
  Word8: decodeImplicit,
  Word16: decodeImplicit,
  Word32: decodeImplicit,
  Word64: decodeImplicit,
  UFix64: decodeImplicit,
  Fix64: decodeImplicit,
  String: decodeImplicit,
  Character: decodeImplicit,
  Bool: decodeImplicit,
  Address: decodeImplicit,
  Void: decodeVoid,
  Optional: decodeOptional,
  Reference: decodeReference,
  Array: decodeArray,
  Dictionary: decodeDictionary,
  Event: decodeComposite,
  Resource: decodeComposite,
  Struct: decodeComposite,
  Enum: decodeComposite,
  Type: decodeType,
  Path: decodePath,
  Capability: decodeCapability
};

var decoderLookup = function decoderLookup(decoders, lookup) {
  var found = Object.keys(decoders).find(function (decoder) {
    if (/^\/.*\/$/.test(decoder)) {
      var reg = new RegExp(decoder.substring(1, decoder.length - 1));
      return reg.test(lookup);
    }

    return decoder === lookup;
  });
  return lookup && found && decoders[found];
};

var recurseDecode = /*#__PURE__*/function () {
  var _ref15 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee15(decodeInstructions, decoders, stack) {
    var decoder;
    return _regeneratorRuntime__default["default"].wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            decoder = decoderLookup(decoders, decodeInstructions.type);

            if (decoder) {
              _context15.next = 3;
              break;
            }

            throw new Error("Undefined Decoder Error: ".concat(decodeInstructions.type, "@").concat(stack.join(".")));

          case 3:
            _context15.next = 5;
            return decoder(decodeInstructions.value, decoders, stack);

          case 5:
            return _context15.abrupt("return", _context15.sent);

          case 6:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee15);
  }));

  return function recurseDecode(_x26, _x27, _x28) {
    return _ref15.apply(this, arguments);
  };
}();

var decode$1 = /*#__PURE__*/function () {
  var _ref16 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee16(decodeInstructions) {
    var customDecoders,
        stack,
        filteredDecoders,
        decoders,
        _args16 = arguments;
    return _regeneratorRuntime__default["default"].wrap(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            customDecoders = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : {};
            stack = _args16.length > 2 && _args16[2] !== undefined ? _args16[2] : [];
            // Filter out all default decoders which are overridden by a custom decoder regex
            filteredDecoders = Object.keys(defaultDecoders).filter(function (decoder) {
              return !Object.keys(customDecoders).find(function (customDecoder) {
                return new RegExp(customDecoder).test(decoder);
              });
            }).reduce(function (decoders, decoderKey) {
              decoders[decoderKey] = defaultDecoders[decoderKey];
              return decoders;
            }, customDecoders);
            decoders = _objectSpread__default["default"](_objectSpread__default["default"]({}, filteredDecoders), customDecoders);
            return _context16.abrupt("return", recurseDecode(decodeInstructions, decoders, stack));

          case 5:
          case "end":
            return _context16.stop();
        }
      }
    }, _callee16);
  }));

  return function decode(_x29) {
    return _ref16.apply(this, arguments);
  };
}();
var decodeResponse = /*#__PURE__*/function () {
  var _ref17 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee19(response) {
    var customDecoders,
        _args19 = arguments;
    return _regeneratorRuntime__default["default"].wrap(function _callee19$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            customDecoders = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : {};

            if (!response.encodedData) {
              _context19.next = 5;
              break;
            }

            return _context19.abrupt("return", decode$1(response.encodedData, customDecoders));

          case 5:
            if (!response.transactionStatus) {
              _context19.next = 16;
              break;
            }

            _context19.t0 = _objectSpread__default["default"];
            _context19.t1 = _objectSpread__default["default"]({}, response.transactionStatus);
            _context19.t2 = {};
            _context19.next = 11;
            return Promise.all(response.transactionStatus.events.map( /*#__PURE__*/function () {
              var _decodeEvents = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee17(e) {
                return _regeneratorRuntime__default["default"].wrap(function _callee17$(_context17) {
                  while (1) {
                    switch (_context17.prev = _context17.next) {
                      case 0:
                        _context17.t0 = e.type;
                        _context17.t1 = e.transactionId;
                        _context17.t2 = e.transactionIndex;
                        _context17.t3 = e.eventIndex;
                        _context17.next = 6;
                        return decode$1(e.payload, customDecoders);

                      case 6:
                        _context17.t4 = _context17.sent;
                        return _context17.abrupt("return", {
                          type: _context17.t0,
                          transactionId: _context17.t1,
                          transactionIndex: _context17.t2,
                          eventIndex: _context17.t3,
                          data: _context17.t4
                        });

                      case 8:
                      case "end":
                        return _context17.stop();
                    }
                  }
                }, _callee17);
              }));

              function decodeEvents(_x31) {
                return _decodeEvents.apply(this, arguments);
              }

              return decodeEvents;
            }()));

          case 11:
            _context19.t3 = _context19.sent;
            _context19.t4 = {
              events: _context19.t3
            };
            return _context19.abrupt("return", (0, _context19.t0)(_context19.t1, _context19.t2, _context19.t4));

          case 16:
            if (!response.transaction) {
              _context19.next = 20;
              break;
            }

            return _context19.abrupt("return", response.transaction);

          case 20:
            if (!response.events) {
              _context19.next = 26;
              break;
            }

            _context19.next = 23;
            return Promise.all(response.events.map( /*#__PURE__*/function () {
              var _decodeEvents2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee18(e) {
                return _regeneratorRuntime__default["default"].wrap(function _callee18$(_context18) {
                  while (1) {
                    switch (_context18.prev = _context18.next) {
                      case 0:
                        _context18.t0 = e.blockId;
                        _context18.t1 = e.blockHeight;
                        _context18.t2 = e.blockTimestamp;
                        _context18.t3 = e.type;
                        _context18.t4 = e.transactionId;
                        _context18.t5 = e.transactionIndex;
                        _context18.t6 = e.eventIndex;
                        _context18.next = 9;
                        return decode$1(e.payload, customDecoders);

                      case 9:
                        _context18.t7 = _context18.sent;
                        return _context18.abrupt("return", {
                          blockId: _context18.t0,
                          blockHeight: _context18.t1,
                          blockTimestamp: _context18.t2,
                          type: _context18.t3,
                          transactionId: _context18.t4,
                          transactionIndex: _context18.t5,
                          eventIndex: _context18.t6,
                          data: _context18.t7
                        });

                      case 11:
                      case "end":
                        return _context18.stop();
                    }
                  }
                }, _callee18);
              }));

              function decodeEvents(_x32) {
                return _decodeEvents2.apply(this, arguments);
              }

              return decodeEvents;
            }()));

          case 23:
            return _context19.abrupt("return", _context19.sent);

          case 26:
            if (!response.account) {
              _context19.next = 30;
              break;
            }

            return _context19.abrupt("return", response.account);

          case 30:
            if (!response.block) {
              _context19.next = 34;
              break;
            }

            return _context19.abrupt("return", response.block);

          case 34:
            if (!response.blockHeader) {
              _context19.next = 38;
              break;
            }

            return _context19.abrupt("return", response.blockHeader);

          case 38:
            if (!response.latestBlock) {
              _context19.next = 43;
              break;
            }

            latestBlockDeprecationNotice();
            return _context19.abrupt("return", response.latestBlock);

          case 43:
            if (!response.transactionId) {
              _context19.next = 47;
              break;
            }

            return _context19.abrupt("return", response.transactionId);

          case 47:
            if (!response.collection) {
              _context19.next = 49;
              break;
            }

            return _context19.abrupt("return", response.collection);

          case 49:
            return _context19.abrupt("return", null);

          case 50:
          case "end":
            return _context19.stop();
        }
      }
    }, _callee19);
  }));

  return function decodeResponse(_x30) {
    return _ref17.apply(this, arguments);
  };
}();

function getRefId(_x) {
  return _getRefId.apply(this, arguments);
}

function _getRefId() {
  _getRefId = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(opts) {
    var node, sendFn, ix;
    return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return config.config().get("accessNode.api");

          case 2:
            node = _context2.sent;
            _context2.next = 5;
            return config.config.first(["sdk.transport", "sdk.send"], transportHttp.send);

          case 5:
            sendFn = _context2.sent;
            utilInvariant.invariant(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
            _context2.next = 9;
            return pipe(interaction(), [getBlock()]);

          case 9:
            ix = _context2.sent;
            _context2.next = 12;
            return sendFn(ix, {
              config: config.config,
              response: response,
              Buffer: rlp.Buffer,
              ix: ixModule
            }, {
              node: node
            });

          case 12:
            ix = _context2.sent;
            _context2.next = 15;
            return decodeResponse(ix);

          case 15:
            ix = _context2.sent;
            return _context2.abrupt("return", ix.id);

          case 17:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getRefId.apply(this, arguments);
}

function resolveRefBlockId(opts) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(ix) {
      return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (isTransaction(ix)) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", Ok(ix));

            case 2:
              if (!ix.message.refBlock) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return", Ok(ix));

            case 4:
              _context.next = 6;
              return getRefId(opts);

            case 6:
              ix.message.refBlock = _context.sent;
              return _context.abrupt("return", Ok(ix));

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x2) {
      return _ref.apply(this, arguments);
    };
  }();
}

var isFn$2 = function isFn(v) {
  return typeof v === "function";
};

var isString$1 = function isString(v) {
  return typeof v === "string";
};

function resolveCadence(_x) {
  return _resolveCadence.apply(this, arguments);
}

function _resolveCadence() {
  _resolveCadence = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(ix) {
    var cadence;
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(isTransaction(ix) || isScript(ix))) {
              _context.next = 11;
              break;
            }

            cadence = get(ix, "ix.cadence");
            utilInvariant.invariant(isFn$2(cadence) || isString$1(cadence), "Cadence needs to be a function or a string.");

            if (!isFn$2(cadence)) {
              _context.next = 7;
              break;
            }

            _context.next = 6;
            return cadence({});

          case 6:
            cadence = _context.sent;

          case 7:
            utilInvariant.invariant(isString$1(cadence), "Cadence needs to be a string at this point.");
            _context.next = 10;
            return config.config().where(/^0x/).then(function (d) {
              return Object.entries(d).reduce(function (cadence, _ref) {
                var _ref2 = _slicedToArray__default["default"](_ref, 2),
                    key = _ref2[0],
                    value = _ref2[1];

                var regex = new RegExp("(\\b" + key + "\\b)", "g");
                return cadence.replace(regex, value);
              }, cadence);
            });

          case 10:
            ix.message.cadence = _context.sent;

          case 11:
            return _context.abrupt("return", ix);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _resolveCadence.apply(this, arguments);
}

var isFn$1 = function isFn(v) {
  return typeof v === "function";
};

function cast(arg) {
  // prettier-ignore
  utilInvariant.invariant(_typeof__default["default"](arg.xform) != null, "No type specified for argument: ".concat(arg.value));
  if (isFn$1(arg.xform)) return arg.xform(arg.value);
  if (isFn$1(arg.xform.asArgument)) return arg.xform.asArgument(arg.value); // prettier-ignore

  utilInvariant.invariant(false, "Invalid Argument", arg);
}

function handleArgResolution(_x) {
  return _handleArgResolution.apply(this, arguments);
}

function _handleArgResolution() {
  _handleArgResolution = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(arg) {
    var depth,
        resolvedArg,
        _args = arguments;
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            depth = _args.length > 1 && _args[1] !== undefined ? _args[1] : 3;
            utilInvariant.invariant(depth > 0, "Argument Resolve Recursion Limit Exceeded for Arg: ".concat(arg.tempId));

            if (!isFn$1(arg.resolveArgument)) {
              _context.next = 9;
              break;
            }

            _context.next = 5;
            return arg.resolveArgument();

          case 5:
            resolvedArg = _context.sent;
            return _context.abrupt("return", handleArgResolution(resolvedArg, depth - 1));

          case 9:
            return _context.abrupt("return", arg);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _handleArgResolution.apply(this, arguments);
}

function resolveArguments(_x2) {
  return _resolveArguments.apply(this, arguments);
}

function _resolveArguments() {
  _resolveArguments = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(ix) {
    var _i, _Object$entries, _Object$entries$_i, id, arg, res;

    return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(isTransaction(ix) || isScript(ix))) {
              _context2.next = 11;
              break;
            }

            _i = 0, _Object$entries = Object.entries(ix.arguments);

          case 2:
            if (!(_i < _Object$entries.length)) {
              _context2.next = 11;
              break;
            }

            _Object$entries$_i = _slicedToArray__default["default"](_Object$entries[_i], 2), id = _Object$entries$_i[0], arg = _Object$entries$_i[1];
            _context2.next = 6;
            return handleArgResolution(arg);

          case 6:
            res = _context2.sent;
            ix.arguments[id].asArgument = cast(res);

          case 8:
            _i++;
            _context2.next = 2;
            break;

          case 11:
            return _context2.abrupt("return", ix);

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _resolveArguments.apply(this, arguments);
}

var encodeTransactionPayload = function encodeTransactionPayload(tx) {
  return prependTransactionDomainTag(rlpEncode(preparePayload(tx)));
};
var encodeTransactionEnvelope = function encodeTransactionEnvelope(tx) {
  return prependTransactionDomainTag(rlpEncode(prepareEnvelope(tx)));
};
var encodeTxIdFromVoucher = function encodeTxIdFromVoucher(voucher) {
  return sha3_256(rlpEncode(prepareVoucher(voucher)));
};

var rightPaddedHexBuffer = function rightPaddedHexBuffer(value, pad) {
  return rlp.Buffer.from(value.padEnd(pad * 2, 0), "hex");
};

var leftPaddedHexBuffer = function leftPaddedHexBuffer(value, pad) {
  return rlp.Buffer.from(value.padStart(pad * 2, 0), "hex");
};

var TRANSACTION_DOMAIN_TAG = rightPaddedHexBuffer(rlp.Buffer.from("FLOW-V0.0-transaction").toString("hex"), 32).toString("hex");

var prependTransactionDomainTag = function prependTransactionDomainTag(tx) {
  return TRANSACTION_DOMAIN_TAG + tx;
};

var addressBuffer = function addressBuffer(addr) {
  return leftPaddedHexBuffer(addr, 8);
};

var blockBuffer = function blockBuffer(block) {
  return leftPaddedHexBuffer(block, 32);
};

var argumentToString = function argumentToString(arg) {
  return rlp.Buffer.from(JSON.stringify(arg), "utf8");
};

var scriptBuffer = function scriptBuffer(script) {
  return rlp.Buffer.from(script, "utf8");
};

var signatureBuffer = function signatureBuffer(signature) {
  return rlp.Buffer.from(signature, "hex");
};

var rlpEncode = function rlpEncode(v) {
  return rlp.encode(v).toString("hex");
};

var sha3_256 = function sha3_256(msg) {
  var sha = new sha3.SHA3(256);
  sha.update(rlp.Buffer.from(msg, "hex"));
  return sha.digest().toString("hex");
};

var preparePayload = function preparePayload(tx) {
  validatePayload(tx);
  return [scriptBuffer(tx.cadence), tx.arguments.map(argumentToString), blockBuffer(tx.refBlock), tx.computeLimit, addressBuffer(utilAddress.sansPrefix(tx.proposalKey.address)), tx.proposalKey.keyId, tx.proposalKey.sequenceNum, addressBuffer(utilAddress.sansPrefix(tx.payer)), tx.authorizers.map(function (authorizer) {
    return addressBuffer(utilAddress.sansPrefix(authorizer));
  })];
};

var prepareEnvelope = function prepareEnvelope(tx) {
  validateEnvelope(tx);
  return [preparePayload(tx), preparePayloadSignatures(tx)];
};

var preparePayloadSignatures = function preparePayloadSignatures(tx) {
  var signers = collectSigners(tx);
  return tx.payloadSigs.map(function (sig) {
    return {
      signerIndex: signers.get(sig.address),
      keyId: sig.keyId,
      sig: sig.sig
    };
  }).sort(function (a, b) {
    if (a.signerIndex > b.signerIndex) return 1;
    if (a.signerIndex < b.signerIndex) return -1;
    if (a.keyId > b.keyId) return 1;
    if (a.keyId < b.keyId) return -1;
  }).map(function (sig) {
    return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
  });
};

var collectSigners = function collectSigners(tx) {
  var signers = new Map();
  var i = 0;

  var addSigner = function addSigner(addr) {
    if (!signers.has(addr)) {
      signers.set(addr, i);
      i++;
    }
  };

  addSigner(tx.proposalKey.address);
  addSigner(tx.payer);
  tx.authorizers.forEach(addSigner);
  return signers;
};

var prepareVoucher = function prepareVoucher(voucher) {
  validateVoucher(voucher);
  var signers = collectSigners(voucher);

  var prepareSigs = function prepareSigs(sigs) {
    return sigs.map(function (_ref) {
      var address = _ref.address,
          keyId = _ref.keyId,
          sig = _ref.sig;
      return {
        signerIndex: signers.get(address),
        keyId: keyId,
        sig: sig
      };
    }).sort(function (a, b) {
      if (a.signerIndex > b.signerIndex) return 1;
      if (a.signerIndex < b.signerIndex) return -1;
      if (a.keyId > b.keyId) return 1;
      if (a.keyId < b.keyId) return -1;
    }).map(function (sig) {
      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
    });
  };

  return [[scriptBuffer(voucher.cadence), voucher.arguments.map(argumentToString), blockBuffer(voucher.refBlock), voucher.computeLimit, addressBuffer(utilAddress.sansPrefix(voucher.proposalKey.address)), voucher.proposalKey.keyId, voucher.proposalKey.sequenceNum, addressBuffer(utilAddress.sansPrefix(voucher.payer)), voucher.authorizers.map(function (authorizer) {
    return addressBuffer(utilAddress.sansPrefix(authorizer));
  })], prepareSigs(voucher.payloadSigs), prepareSigs(voucher.envelopeSigs)];
};

var validatePayload = function validatePayload(tx) {
  payloadFields.forEach(function (field) {
    return checkField(tx, field);
  });
  proposalKeyFields.forEach(function (field) {
    return checkField(tx.proposalKey, field, "proposalKey");
  });
};

var validateEnvelope = function validateEnvelope(tx) {
  payloadSigsFields.forEach(function (field) {
    return checkField(tx, field);
  });
  tx.payloadSigs.forEach(function (sig, index) {
    payloadSigFields.forEach(function (field) {
      return checkField(sig, field, "payloadSigs", index);
    });
  });
};

var validateVoucher = function validateVoucher(voucher) {
  payloadFields.forEach(function (field) {
    return checkField(voucher, field);
  });
  proposalKeyFields.forEach(function (field) {
    return checkField(voucher.proposalKey, field, "proposalKey");
  });
  payloadSigsFields.forEach(function (field) {
    return checkField(voucher, field);
  });
  voucher.payloadSigs.forEach(function (sig, index) {
    payloadSigFields.forEach(function (field) {
      return checkField(sig, field, "payloadSigs", index);
    });
  });
  envelopeSigsFields.forEach(function (field) {
    return checkField(voucher, field);
  });
  voucher.envelopeSigs.forEach(function (sig, index) {
    envelopeSigFields.forEach(function (field) {
      return checkField(sig, field, "envelopeSigs", index);
    });
  });
};

var isNumber = function isNumber(v) {
  return typeof v === "number";
};

var isString = function isString(v) {
  return typeof v === "string";
};

var isObject = function isObject(v) {
  return v !== null && _typeof__default["default"](v) === "object";
};

var isArray = function isArray(v) {
  return isObject(v) && v instanceof Array;
};

var payloadFields = [{
  name: "cadence",
  check: isString
}, {
  name: "arguments",
  check: isArray
}, {
  name: "refBlock",
  check: isString,
  defaultVal: "0"
}, {
  name: "computeLimit",
  check: isNumber
}, {
  name: "proposalKey",
  check: isObject
}, {
  name: "payer",
  check: isString
}, {
  name: "authorizers",
  check: isArray
}];
var proposalKeyFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sequenceNum",
  check: isNumber
}];
var payloadSigsFields = [{
  name: "payloadSigs",
  check: isArray
}];
var payloadSigFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sig",
  check: isString
}];
var envelopeSigsFields = [{
  name: "envelopeSigs",
  check: isArray
}];
var envelopeSigFields = [{
  name: "address",
  check: isString
}, {
  name: "keyId",
  check: isNumber
}, {
  name: "sig",
  check: isString
}];

var checkField = function checkField(obj, field, base, index) {
  var name = field.name,
      check = field.check,
      defaultVal = field.defaultVal;
  if (obj[name] == null && defaultVal != null) obj[name] = defaultVal;
  if (obj[name] == null) throw missingFieldError(name, base, index);
  if (!check(obj[name])) throw invalidFieldError(name, base, index);
};

var printFieldName = function printFieldName(field, base, index) {
  if (!!base) return index == null ? "".concat(base, ".").concat(field) : "".concat(base, ".").concat(index, ".").concat(field);
  return field;
};

var missingFieldError = function missingFieldError(field, base, index) {
  return new Error("Missing field ".concat(printFieldName(field, base, index)));
};

var invalidFieldError = function invalidFieldError(field, base, index) {
  return new Error("Invalid field ".concat(printFieldName(field, base, index)));
};

function findInsideSigners(ix) {
  // Inside Signers Are: (authorizers + proposer) - payer
  var inside = new Set(ix.authorizations);
  inside.add(ix.proposer);

  if (Array.isArray(ix.payer)) {
    ix.payer.forEach(function (p) {
      return inside["delete"](p);
    });
  } else {
    inside["delete"](ix.payer);
  }

  return Array.from(inside);
}
function findOutsideSigners(ix) {
  // Outside Signers Are: (payer)
  var outside = new Set(Array.isArray(ix.payer) ? ix.payer : [ix.payer]);
  return Array.from(outside);
}
var createSignableVoucher = function createSignableVoucher(ix) {
  var buildAuthorizers = function buildAuthorizers() {
    var authorizations = ix.authorizations.map(function (cid) {
      return utilAddress.withPrefix(ix.accounts[cid].addr);
    }).reduce(function (prev, current) {
      return prev.find(function (item) {
        return item === current;
      }) ? prev : [].concat(_toConsumableArray__default["default"](prev), [current]);
    }, []);
    return authorizations[0] ? authorizations : [];
  };

  var buildInsideSigners = function buildInsideSigners() {
    return findInsideSigners(ix).map(function (id) {
      return {
        address: utilAddress.withPrefix(ix.accounts[id].addr),
        keyId: ix.accounts[id].keyId,
        sig: ix.accounts[id].signature
      };
    });
  };

  var buildOutsideSigners = function buildOutsideSigners() {
    return findOutsideSigners(ix).map(function (id) {
      return {
        address: utilAddress.withPrefix(ix.accounts[id].addr),
        keyId: ix.accounts[id].keyId,
        sig: ix.accounts[id].signature
      };
    });
  };

  return {
    cadence: ix.message.cadence,
    refBlock: ix.message.refBlock || null,
    computeLimit: ix.message.computeLimit,
    arguments: ix.message.arguments.map(function (id) {
      return ix.arguments[id].asArgument;
    }),
    proposalKey: {
      address: utilAddress.withPrefix(ix.accounts[ix.proposer].addr),
      keyId: ix.accounts[ix.proposer].keyId,
      sequenceNum: ix.accounts[ix.proposer].sequenceNum
    },
    payer: utilAddress.withPrefix(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
    authorizers: buildAuthorizers(),
    payloadSigs: buildInsideSigners(),
    envelopeSigs: buildOutsideSigners()
  };
};
var voucherToTxId = function voucherToTxId(voucher) {
  return encodeTxIdFromVoucher(voucher);
};

var idof$1 = function idof(acct) {
  return "".concat(utilAddress.withPrefix(acct.addr), "-").concat(acct.keyId);
};

var isFn = function isFn(v) {
  return typeof v === "function";
};

function buildPreSignable(acct, ix) {
  try {
    return {
      f_type: "PreSignable",
      f_vsn: "1.0.1",
      roles: acct.role,
      cadence: ix.message.cadence,
      args: ix.message.arguments.map(function (d) {
        return ix.arguments[d].asArgument;
      }),
      data: {},
      interaction: ix,
      voucher: createSignableVoucher(ix)
    };
  } catch (error) {
    console.error("buildPreSignable", error);
    throw error;
  }
}

function collectAccounts(_x, _x2, _x3) {
  return _collectAccounts.apply(this, arguments);
}

function _collectAccounts() {
  _collectAccounts = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(ix, accounts, last) {
    var depth,
        authorizations,
        _iterator,
        _step,
        _loop,
        old,
        _args2 = arguments;

    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            depth = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 3;
            utilInvariant.invariant(depth, "Account Resolve Recursion Limit Exceeded", {
              ix: ix,
              accounts: accounts
            });
            authorizations = [];
            _iterator = _createForOfIteratorHelper__default["default"](accounts);
            _context2.prev = 4;
            _loop = /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _loop() {
              var ax, resolve, dupList, payerAccts, multiAccts;
              return _regeneratorRuntime__default["default"].wrap(function _loop$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      ax = _step.value;
                      resolve = ax.resolve;
                      ax.resolve = null;
                      old = last || ax;

                      if (!isFn(resolve)) {
                        _context.next = 8;
                        break;
                      }

                      _context.next = 7;
                      return resolve(ax, buildPreSignable(ax, ix));

                    case 7:
                      ax = _context.sent;

                    case 8:
                      if (!Array.isArray(ax)) {
                        _context.next = 13;
                        break;
                      }

                      _context.next = 11;
                      return collectAccounts(ix, ax, old, depth - 1);

                    case 11:
                      _context.next = 30;
                      break;

                    case 13:
                      if (ax.addr) {
                        ax.addr = utilAddress.sansPrefix(ax.addr);
                      }

                      if (ax.addr != null && ax.keyId != null) {
                        ax.tempId = idof$1(ax);
                      }

                      ix.accounts[ax.tempId] = ix.accounts[ax.tempId] || ax;
                      ix.accounts[ax.tempId].role.proposer = ix.accounts[ax.tempId].role.proposer || ax.role.proposer;
                      ix.accounts[ax.tempId].role.payer = ix.accounts[ax.tempId].role.payer || ax.role.payer;
                      ix.accounts[ax.tempId].role.authorizer = ix.accounts[ax.tempId].role.authorizer || ax.role.authorizer;

                      if (ix.accounts[ax.tempId].role.proposer && ix.proposer === old.tempId) {
                        ix.proposer = ax.tempId;
                      }

                      if (!ix.accounts[ax.tempId].role.payer) {
                        _context.next = 29;
                        break;
                      }

                      if (Array.isArray(ix.payer)) {
                        ix.payer = Array.from(new Set([].concat(_toConsumableArray__default["default"](ix.payer), [ax.tempId]).map(function (d) {
                          return d === old.tempId ? ax.tempId : d;
                        })));
                      } else {
                        ix.payer = Array.from(new Set([ix.payer, ax.tempId].map(function (d) {
                          return d === old.tempId ? ax.tempId : d;
                        })));
                      }

                      if (!(ix.payer.length > 1)) {
                        _context.next = 29;
                        break;
                      }

                      // remove payer dups based on addr and keyId
                      dupList = [];
                      payerAccts = [];
                      ix.payer = ix.payer.reduce(function (g, tempId) {
                        var addr = ix.accounts[tempId].addr;
                        var key = idof$1(ix.accounts[tempId]);
                        payerAccts.push(addr);
                        if (dupList.includes(key)) return g;
                        dupList.push(key);
                        return [].concat(_toConsumableArray__default["default"](g), [tempId]);
                      }, []);
                      multiAccts = Array.from(new Set(payerAccts));

                      if (!(multiAccts.length > 1)) {
                        _context.next = 29;
                        break;
                      }

                      throw new Error("Payer can not be different accounts");

                    case 29:
                      if (ix.accounts[ax.tempId].role.authorizer) {
                        if (last) {
                          // do group replacement
                          authorizations = Array.from(new Set([].concat(_toConsumableArray__default["default"](authorizations), [ax.tempId])));
                        } else {
                          // do 1-1 replacement
                          ix.authorizations = ix.authorizations.map(function (d) {
                            return d === old.tempId ? ax.tempId : d;
                          });
                        }
                      }

                    case 30:
                      if (old.tempId != ax.tempId) delete ix.accounts[old.tempId];

                    case 31:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _loop);
            });

            _iterator.s();

          case 7:
            if ((_step = _iterator.n()).done) {
              _context2.next = 11;
              break;
            }

            return _context2.delegateYield(_loop(), "t0", 9);

          case 9:
            _context2.next = 7;
            break;

          case 11:
            _context2.next = 16;
            break;

          case 13:
            _context2.prev = 13;
            _context2.t1 = _context2["catch"](4);

            _iterator.e(_context2.t1);

          case 16:
            _context2.prev = 16;

            _iterator.f();

            return _context2.finish(16);

          case 19:
            if (last) {
              // complete (flatmap) group replacement
              ix.authorizations = ix.authorizations.map(function (d) {
                return d === last.tempId ? authorizations : d;
              }).reduce(function (prev, curr) {
                return Array.isArray(curr) ? [].concat(_toConsumableArray__default["default"](prev), _toConsumableArray__default["default"](curr)) : [].concat(_toConsumableArray__default["default"](prev), [curr]);
              }, []);
            }

          case 20:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee, null, [[4, 13, 16, 19]]);
  }));
  return _collectAccounts.apply(this, arguments);
}

function resolveAccounts(_x4) {
  return _resolveAccounts.apply(this, arguments);
}

function _resolveAccounts() {
  _resolveAccounts = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(ix) {
    return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!isTransaction(ix)) {
              _context3.next = 13;
              break;
            }

            if (!Array.isArray(ix.payer)) {
              logger.log.deprecate({
                pkg: "FCL",
                subject: '"ix.payer" must be an array. Support for ix.payer as a singular',
                message: "See changelog for more info."
              });
            }

            _context3.prev = 2;
            _context3.next = 5;
            return collectAccounts(ix, Object.values(ix.accounts));

          case 5:
            _context3.next = 7;
            return collectAccounts(ix, Object.values(ix.accounts));

          case 7:
            _context3.next = 13;
            break;

          case 9:
            _context3.prev = 9;
            _context3.t0 = _context3["catch"](2);
            console.error("=== SAD PANDA ===\n\n", _context3.t0, "\n\n=== SAD PANDA ===");
            throw _context3.t0;

          case 13:
            return _context3.abrupt("return", ix);

          case 14:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee2, null, [[2, 9]]);
  }));
  return _resolveAccounts.apply(this, arguments);
}

function resolveSignatures(_x) {
  return _resolveSignatures.apply(this, arguments);
}

function _resolveSignatures() {
  _resolveSignatures = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(ix) {
    var insideSigners, insidePayload, outsideSigners, outsidePayload;
    return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!isTransaction(ix)) {
              _context2.next = 16;
              break;
            }

            _context2.prev = 1;
            insideSigners = findInsideSigners(ix);
            insidePayload = encodeTransactionPayload(prepForEncoding(ix));
            _context2.next = 6;
            return Promise.all(insideSigners.map(fetchSignature(ix, insidePayload)));

          case 6:
            outsideSigners = findOutsideSigners(ix);
            outsidePayload = encodeTransactionEnvelope(_objectSpread__default["default"](_objectSpread__default["default"]({}, prepForEncoding(ix)), {}, {
              payloadSigs: insideSigners.map(function (id) {
                return {
                  address: ix.accounts[id].addr,
                  keyId: ix.accounts[id].keyId,
                  sig: ix.accounts[id].signature
                };
              })
            }));
            _context2.next = 10;
            return Promise.all(outsideSigners.map(fetchSignature(ix, outsidePayload)));

          case 10:
            _context2.next = 16;
            break;

          case 12:
            _context2.prev = 12;
            _context2.t0 = _context2["catch"](1);
            console.error("Signatures", _context2.t0, {
              ix: ix
            });
            throw _context2.t0;

          case 16:
            return _context2.abrupt("return", ix);

          case 17:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[1, 12]]);
  }));
  return _resolveSignatures.apply(this, arguments);
}

function fetchSignature(ix, payload) {
  return /*#__PURE__*/function () {
    var _innerFetchSignature = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(id) {
      var acct, _yield$acct$signingFu, signature;

      return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              acct = ix.accounts[id];

              if (!(acct.signature != null)) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return");

            case 3:
              _context.next = 5;
              return acct.signingFunction(buildSignable(acct, payload, ix));

            case 5:
              _yield$acct$signingFu = _context.sent;
              signature = _yield$acct$signingFu.signature;
              ix.accounts[id].signature = signature;

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function innerFetchSignature(_x2) {
      return _innerFetchSignature.apply(this, arguments);
    }

    return innerFetchSignature;
  }();
}

function buildSignable(acct, message, ix) {
  try {
    return {
      f_type: "Signable",
      f_vsn: "1.0.1",
      message: message,
      addr: utilAddress.sansPrefix(acct.addr),
      keyId: acct.keyId,
      roles: acct.role,
      cadence: ix.message.cadence,
      args: ix.message.arguments.map(function (d) {
        return ix.arguments[d].asArgument;
      }),
      data: {},
      interaction: ix,
      voucher: createSignableVoucher(ix)
    };
  } catch (error) {
    console.error("buildSignable", error);
    throw error;
  }
}

function prepForEncoding(ix) {
  var payerAddress = utilAddress.sansPrefix((Array.isArray(ix.payer) ? ix.accounts[ix.payer[0]] : ix.accounts[ix.payer]).addr);
  return {
    cadence: ix.message.cadence,
    refBlock: ix.message.refBlock || null,
    computeLimit: ix.message.computeLimit,
    arguments: ix.message.arguments.map(function (id) {
      return ix.arguments[id].asArgument;
    }),
    proposalKey: {
      address: utilAddress.sansPrefix(ix.accounts[ix.proposer].addr),
      keyId: ix.accounts[ix.proposer].keyId,
      sequenceNum: ix.accounts[ix.proposer].sequenceNum
    },
    payer: payerAddress,
    authorizers: ix.authorizations.map(function (cid) {
      return utilAddress.sansPrefix(ix.accounts[cid].addr);
    }).reduce(function (prev, current) {
      return prev.find(function (item) {
        return item === current;
      }) ? prev : [].concat(_toConsumableArray__default["default"](prev), [current]);
    }, [])
  };
}

function resolveValidators(_x) {
  return _resolveValidators.apply(this, arguments);
}

function _resolveValidators() {
  _resolveValidators = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(ix) {
    var validators;
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            validators = get(ix, "ix.validators", []);
            return _context.abrupt("return", pipe(ix, validators.map(function (cb) {
              return function (ix) {
                return cb(ix, {
                  Ok: Ok,
                  Bad: Bad
                });
              };
            })));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _resolveValidators.apply(this, arguments);
}

function resolveFinalNormalization(_x) {
  return _resolveFinalNormalization.apply(this, arguments);
}

function _resolveFinalNormalization() {
  _resolveFinalNormalization = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(ix) {
    var _i, _Object$keys, key;

    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            for (_i = 0, _Object$keys = Object.keys(ix.accounts); _i < _Object$keys.length; _i++) {
              key = _Object$keys[_i];
              ix.accounts[key].addr = utilAddress.sansPrefix(ix.accounts[key].addr);
            }

            return _context.abrupt("return", ix);

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _resolveFinalNormalization.apply(this, arguments);
}

function resolveVoucherIntercept(_x) {
  return _resolveVoucherIntercept.apply(this, arguments);
}

function _resolveVoucherIntercept() {
  _resolveVoucherIntercept = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(ix) {
    var fn;
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            fn = get(ix, "ix.voucher-intercept");

            if (!isFn$3(fn)) {
              _context.next = 4;
              break;
            }

            _context.next = 4;
            return fn(createSignableVoucher(ix));

          case 4:
            return _context.abrupt("return", ix);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _resolveVoucherIntercept.apply(this, arguments);
}

var DEFAULT_COMPUTE_LIMIT = 100;
function resolveComputeLimit(_x) {
  return _resolveComputeLimit.apply(this, arguments);
}

function _resolveComputeLimit() {
  _resolveComputeLimit = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(ix) {
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!isTransaction(ix)) {
              _context.next = 8;
              break;
            }

            _context.t0 = ix.message.computeLimit;

            if (_context.t0) {
              _context.next = 6;
              break;
            }

            _context.next = 5;
            return config.config.get("fcl.limit");

          case 5:
            _context.t0 = _context.sent;

          case 6:
            ix.message.computeLimit = _context.t0;

            if (!ix.message.computeLimit) {
              logger__namespace.log.deprecate({
                pkg: "FCL/SDK",
                subject: "The built-in default compute limit (DEFAULT_COMPUTE_LIMIT=10)",
                transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0009-deprecate-default-compute-limit"
              });
              ix.message.computeLimit = DEFAULT_COMPUTE_LIMIT;
            }

          case 8:
            return _context.abrupt("return", ix);

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _resolveComputeLimit.apply(this, arguments);
}

var noop = function noop(v) {
  return v;
};

var debug = function debug(key) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(ix) {
      var accts, log;
      return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:

              accts = function accts(ix) {
                return ["\nAccounts:", {
                  proposer: ix.proposer,
                  authorizations: ix.authorizations,
                  payer: ix.payer
                }, "\n\nDetails:", ix.accounts].filter(Boolean);
              };

              log = function log() {
                var _console;

                for (var _len = arguments.length, msg = new Array(_len), _key = 0; _key < _len; _key++) {
                  msg[_key] = arguments[_key];
                }

                (_console = console).log.apply(_console, ["debug[".concat(key, "] ---\n")].concat(msg, ["\n\n\n---"]));
              };

              _context.next = 5;
              return config.config.get("debug.".concat(key));

            case 5:
              if (!_context.sent) {
                _context.next = 8;
                break;
              }

              _context.next = 8;
              return fn(ix, log, accts);

            case 8:
              return _context.abrupt("return", ix);

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

var resolve = pipe([resolveCadence, debug("cadence", function (ix, log) {
  return log(ix.message.cadence);
}), resolveComputeLimit, debug("compute limit", function (ix, log) {
  return log(ix.message.computeLimit);
}), resolveArguments, debug("arguments", function (ix, log) {
  return log(ix.message.arguments, ix.message);
}), resolveAccounts, debug("accounts", function (ix, log, accts) {
  return log.apply(void 0, _toConsumableArray__default["default"](accts(ix)));
}),
/* special */
execFetchRef,
/* special */
execFetchSequenceNumber, resolveSignatures, debug("signatures", function (ix, log, accts) {
  return log.apply(void 0, _toConsumableArray__default["default"](accts(ix)));
}), resolveFinalNormalization, resolveValidators, resolveVoucherIntercept, debug("resolved", function (ix, log) {
  return log(ix);
})]);

function execFetchRef(_x2) {
  return _execFetchRef.apply(this, arguments);
}

function _execFetchRef() {
  _execFetchRef = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(ix) {
    var node, sendFn;
    return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(isTransaction(ix) && ix.message.refBlock == null)) {
              _context2.next = 11;
              break;
            }

            _context2.next = 3;
            return config.config().get("accessNode.api");

          case 3:
            node = _context2.sent;
            _context2.next = 6;
            return config.config.first(["sdk.transport", "sdk.send"], transportHttp.send);

          case 6:
            sendFn = _context2.sent;
            utilInvariant.invariant(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
            _context2.next = 10;
            return sendFn(build([getBlock()]), {
              config: config.config,
              response: response,
              Buffer: rlp.Buffer,
              ix: ixModule
            }, {
              node: node
            }).then(decodeResponse);

          case 10:
            ix.message.refBlock = _context2.sent.id;

          case 11:
            return _context2.abrupt("return", ix);

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _execFetchRef.apply(this, arguments);
}

function execFetchSequenceNumber(_x3) {
  return _execFetchSequenceNumber.apply(this, arguments);
}

function _execFetchSequenceNumber() {
  _execFetchSequenceNumber = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(ix) {
    var acct, node, sendFn;
    return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!isTransaction(ix)) {
              _context3.next = 20;
              break;
            }

            acct = Object.values(ix.accounts).find(function (a) {
              return a.role.proposer;
            });
            utilInvariant.invariant(acct, "Transactions require a proposer");

            if (!(acct.sequenceNum == null)) {
              _context3.next = 20;
              break;
            }

            _context3.next = 6;
            return config.config().get("accessNode.api");

          case 6:
            node = _context3.sent;
            _context3.next = 9;
            return config.config.first(["sdk.transport", "sdk.send"], transportHttp.send);

          case 9:
            sendFn = _context3.sent;
            utilInvariant.invariant(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
            _context3.t0 = sendFn;
            _context3.next = 14;
            return build([getAccount(acct.addr)]);

          case 14:
            _context3.t1 = _context3.sent;
            _context3.t2 = {
              config: config.config,
              response: response,
              Buffer: rlp.Buffer,
              ix: ixModule
            };
            _context3.t3 = {
              node: node
            };
            _context3.next = 19;
            return (0, _context3.t0)(_context3.t1, _context3.t2, _context3.t3).then(decodeResponse).then(function (acct) {
              return acct.keys;
            }).then(function (keys) {
              return keys.find(function (key) {
                return key.index === acct.keyId;
              });
            }).then(function (key) {
              return key.sequenceNumber;
            });

          case 19:
            ix.accounts[acct.tempId].sequenceNum = _context3.sent;

          case 20:
            return _context3.abrupt("return", ix);

          case 21:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _execFetchSequenceNumber.apply(this, arguments);
}

function invariant() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length > 1) {
    var predicate = args[0],
        message = args[1];
    return invariant(function (ix, _ref) {
      var Ok = _ref.Ok,
          Bad = _ref.Bad;
      return predicate ? Ok(ix) : Bad(ix, message);
    });
  }

  var fn = args[0];
  return function (ix) {
    return fn(ix, {
      Ok: Ok,
      Bad: Bad
    });
  };
}

var send = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee() {
    var args,
        opts,
        sendFn,
        resolveFn,
        _args = arguments;
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            args = _args.length > 0 && _args[0] !== undefined ? _args[0] : [];
            opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            _context.next = 4;
            return config.config.first(["sdk.transport", "sdk.send"], opts.send || transportHttp.send);

          case 4:
            sendFn = _context.sent;
            invariant(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
            _context.next = 8;
            return config.config.first(["sdk.resolve"], opts.resolve || resolve);

          case 8:
            resolveFn = _context.sent;
            _context.t0 = opts.node;

            if (_context.t0) {
              _context.next = 14;
              break;
            }

            _context.next = 13;
            return config.config().get("accessNode.api");

          case 13:
            _context.t0 = _context.sent;

          case 14:
            opts.node = _context.t0;
            if (Array.isArray(args)) args = pipe(interaction(), args);
            _context.t1 = sendFn;
            _context.next = 19;
            return resolveFn(args);

          case 19:
            _context.t2 = _context.sent;
            _context.t3 = {
              config: config.config,
              response: response,
              ix: ixModule,
              Buffer: rlp.Buffer
            };
            _context.t4 = opts;
            return _context.abrupt("return", (0, _context.t1)(_context.t2, _context.t3, _context.t4));

          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function send() {
    return _ref.apply(this, arguments);
  };
}();

function decode(_x) {
  return _decode.apply(this, arguments);
}

function _decode() {
  _decode = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(response) {
    var decodersFromConfig, decoders;
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return config.config().where(/^decoder\./);

          case 2:
            decodersFromConfig = _context.sent;
            decoders = Object.entries(decodersFromConfig).map(function (_ref) {
              var _ref2 = _slicedToArray__default["default"](_ref, 2),
                  pattern = _ref2[0],
                  xform = _ref2[1];

              pattern = "/".concat(pattern.replace(/^decoder\./, ""), "$/");
              return [pattern, xform];
            });
            return _context.abrupt("return", decodeResponse(response, Object.fromEntries(decoders)));

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _decode.apply(this, arguments);
}

var findPayloadSigners = function findPayloadSigners(voucher) {
  // Payload Signers Are: (authorizers + proposer) - payer
  var payload = new Set(voucher.authorizers);
  payload.add(voucher.proposalKey.address);
  payload["delete"](voucher.payer);
  return Array.from(payload).map(utilAddress.withPrefix);
};

var findEnvelopeSigners = function findEnvelopeSigners(voucher) {
  // Envelope Signers Are: (payer)
  var envelope = new Set([voucher.payer]);
  return Array.from(envelope).map(utilAddress.withPrefix);
};

var UnableToDetermineMessageEncodingTypeForSignerAddress = /*#__PURE__*/function (_Error) {
  _inherits__default["default"](UnableToDetermineMessageEncodingTypeForSignerAddress, _Error);

  var _super = _createSuper__default["default"](UnableToDetermineMessageEncodingTypeForSignerAddress);

  function UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress) {
    var _this;

    _classCallCheck__default["default"](this, UnableToDetermineMessageEncodingTypeForSignerAddress);

    var msg = "\n        Encode Message From Signable Error: Unable to determine message encoding for signer addresss: ".concat(signerAddress, ". \n        Please ensure the address: ").concat(signerAddress, " is intended to sign the given transaction as specified by the transaction signable.\n      ").trim();
    _this = _super.call(this, msg);
    _this.name = "Unable To Determine Message Encoding For Signer Addresss";
    return _this;
  }

  return _createClass__default["default"](UnableToDetermineMessageEncodingTypeForSignerAddress);
}( /*#__PURE__*/_wrapNativeSuper__default["default"](Error));
var encodeMessageFromSignable = function encodeMessageFromSignable(signable, signerAddress) {
  var payloadSigners = findPayloadSigners(signable.voucher);
  var envelopeSigners = findEnvelopeSigners(signable.voucher);
  var isPayloadSigner = payloadSigners.includes(utilAddress.withPrefix(signerAddress));
  var isEnvelopeSigner = envelopeSigners.includes(utilAddress.withPrefix(signerAddress));

  if (!isPayloadSigner && !isEnvelopeSigner) {
    throw new UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress);
  }

  var message = {
    cadence: signable.voucher.cadence,
    refBlock: signable.voucher.refBlock,
    computeLimit: signable.voucher.computeLimit,
    arguments: signable.voucher.arguments,
    proposalKey: _objectSpread__default["default"](_objectSpread__default["default"]({}, signable.voucher.proposalKey), {}, {
      address: utilAddress.sansPrefix(signable.voucher.proposalKey.address)
    }),
    payer: utilAddress.sansPrefix(signable.voucher.payer),
    authorizers: signable.voucher.authorizers.map(utilAddress.sansPrefix),
    payloadSigs: signable.voucher.payloadSigs.map(function (ps) {
      return _objectSpread__default["default"](_objectSpread__default["default"]({}, ps), {}, {
        address: utilAddress.sansPrefix(ps.address)
      });
    })
  };
  return isPayloadSigner ? encodeTransactionPayload(message) : encodeTransactionEnvelope(message);
};

function validator(cb) {
  return update("ix.validators", function (validators) {
    return Array.isArray(validators) ? validators.push(cb) : [cb];
  });
}

function atBlockHeight(height) {
  return pipe([function (ix) {
    ix.block.height = height;
    return ix;
  }, validator(function (ix) {
    if (typeof ix.block.isSealed === "boolean") throw new Error("Unable to specify both block height and isSealed.");
    if (ix.block.id) throw new Error("Unable to specify both block height and block id.");
    return ix;
  })]);
}

function atBlockId(id) {
  return pipe([function (ix) {
    ix.block.id = id;
    return Ok(ix);
  }, validator(function (ix, _ref) {
    var Ok = _ref.Ok,
        Bad = _ref.Bad;
    if (isGetAccount(ix)) return Bad(ix, "Unable to specify a block id with a Get Account interaction.");
    if (typeof ix.block.isSealed === "boolean") return Bad(ix, "Unable to specify both block id and isSealed.");
    if (ix.block.height) return Bad(ix, "Unable to specify both block id and block height.");
    return Ok(ix);
  })]);
}

function account(address) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      height = _ref.height,
      id = _ref.id;

  var opts = arguments.length > 2 ? arguments[2] : undefined;
  utilInvariant.invariant(!(id && height), "Method: account -- Cannot pass \"id\" and \"height\" simultaneously"); // Get account by ID

  if (id) return send([getAccount(address), atBlockId(id)], opts).then(decodeResponse); // Get account by height

  if (height) return send([getAccount(address), atBlockHeight(height)], opts).then(decodeResponse);
  return send([getAccount(address)], opts).then(decodeResponse);
}

function block() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$sealed = _ref.sealed,
      sealed = _ref$sealed === void 0 ? false : _ref$sealed,
      id = _ref.id,
      height = _ref.height;

  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  utilInvariant.invariant(!(sealed && id || sealed && height), "Method: block -- Cannot pass \"sealed\" with \"id\" or \"height\"");
  utilInvariant.invariant(!(id && height), "Method: block -- Cannot pass \"id\" and \"height\" simultaneously"); // Get block by ID

  if (id) return send([getBlock(), atBlockId(id)], opts).then(decodeResponse); // Get block by height

  if (height) return send([getBlock(), atBlockHeight(height)], opts).then(decodeResponse); // Get latest block

  return send([getBlock(sealed)], opts).then(decodeResponse);
}

function authorizations() {
  var ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return pipe(ax.map(function (authz) {
    return prepAccount(authz, {
      role: AUTHORIZER
    });
  }));
}
function authorization(addr, signingFunction, keyId, sequenceNum) {
  return {
    addr: addr,
    signingFunction: signingFunction,
    keyId: keyId,
    sequenceNum: sequenceNum
  };
}

function getEvents(eventType, start, end) {
  if (typeof start !== "undefined" || typeof end !== "undefined") {
    logger__namespace.log.deprecate({
      pkg: "FCL/SDK",
      subject: "Passing a start and end into getEvents",
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0005-deprecate-start-end-get-events-builder"
    });
  }

  return pipe([makeGetEvents, function (ix) {
    ix.events.eventType = eventType;
    ix.events.start = start;
    ix.events.end = end;
    return Ok(ix);
  }]);
}

function getEventsAtBlockHeightRange(eventType, start, end) {
  return pipe([makeGetEvents, function (ix) {
    ix.events.eventType = eventType;
    ix.events.start = start;
    ix.events.end = end;
    return Ok(ix);
  }]);
}

function getEventsAtBlockIds(eventType) {
  var blockIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return pipe([makeGetEvents, function (ix) {
    ix.events.eventType = eventType;
    ix.events.blockIds = blockIds;
    return Ok(ix);
  }]);
}

function getBlockHeader() {
  var isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return pipe([makeGetBlockHeader, function (ix) {
    ix.block.isSealed = isSealed;
    return Ok(ix);
  }]);
}

function getCollection() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  return pipe([makeGetCollection, function (ix) {
    ix.collection.id = id;
    return ix;
  }]);
}

function getTransactionStatus(transactionId) {
  return pipe([makeGetTransactionStatus, function (ix) {
    ix.transaction.id = transactionId;
    return Ok(ix);
  }]);
}

function getTransaction(transactionId) {
  return pipe([makeGetTransaction, function (ix) {
    ix.transaction.id = transactionId;
    return Ok(ix);
  }]);
}

function limit(computeLimit) {
  return function (ix) {
    ix.message.computeLimit = computeLimit;
    return ix;
  };
}

function args() {
  var ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return pipe(ax.map(makeArgument));
}
function arg(value, xform) {
  return {
    value: value,
    xform: xform
  };
}

function proposer(_x) {
  return _proposer.apply(this, arguments);
}

function _proposer() {
  _proposer = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(authz) {
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", prepAccount(authz, {
              role: PROPOSER
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _proposer.apply(this, arguments);
}

function payer(_x) {
  return _payer.apply(this, arguments);
}

function _payer() {
  _payer = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(authz) {
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", prepAccount(authz, {
              role: PAYER
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _payer.apply(this, arguments);
}

function ping() {
  return makePing;
}

function ref(refBlock) {
  return pipe([function (ix) {
    ix.message.refBlock = refBlock;
    return Ok(ix);
  }]);
}

function script() {
  return pipe([makeScript, put("ix.cadence", utilTemplate.template.apply(void 0, arguments))]);
}

var DEFAULT_SCRIPT_ACCOUNTS = [];
var DEFUALT_REF = null;
function transaction() {
  return pipe([makeTransaction, put("ix.cadence", utilTemplate.template.apply(void 0, arguments)), function (ix) {
    ix.message.refBlock = ix.message.refBlock || DEFUALT_REF;
    ix.authorizations = ix.authorizations || DEFAULT_SCRIPT_ACCOUNTS;
    return Ok(ix);
  }]);
}

function voucherIntercept(fn) {
  return put("ix.voucher-intercept", fn);
}

var resolveProposerSequenceNumber = function resolveProposerSequenceNumber(_ref) {
  var node = _ref.node;
  return /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(ix) {
      var sendFn, response$1, decoded;
      return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (isTransaction(ix)) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", Ok(ix));

            case 2:
              if (!ix.accounts[ix.proposer].sequenceNum) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return", Ok(ix));

            case 4:
              _context.next = 6;
              return config.config.first(["sdk.transport", "sdk.send"], transportHttp.send);

            case 6:
              sendFn = _context.sent;
              utilInvariant.invariant(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
              _context.t0 = sendFn;
              _context.next = 11;
              return build([getAccount(ix.accounts[ix.proposer].addr)]);

            case 11:
              _context.t1 = _context.sent;
              _context.t2 = {
                config: config.config,
                response: response,
                Buffer: rlp.Buffer,
                ix: ixModule
              };
              _context.t3 = {
                node: node
              };
              _context.next = 16;
              return (0, _context.t0)(_context.t1, _context.t2, _context.t3);

            case 16:
              response$1 = _context.sent;
              _context.next = 19;
              return decodeResponse(response$1);

            case 19:
              decoded = _context.sent;
              ix.accounts[ix.proposer].sequenceNum = decoded.keys[ix.accounts[ix.proposer].keyId].sequenceNumber;
              return _context.abrupt("return", Ok(ix));

            case 22:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }();
};

function mockAccountResponse(ix) {
  var numberOfKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  // prettier-ignore
  utilInvariant.invariant(ix.account, "mockAccountResponse(ix) -- ix.account is missing", ix); // prettier-ignore

  utilInvariant.invariant(ix.account.addr, "mockAccountResponse(ix) -- ix.account.addr is missing", ix);
  var address = ix.account.addr;
  return {
    account: {
      addr: address,
      keys: Array.from({
        length: numberOfKeys
      }, function (_, i) {
        return {
          index: i,
          sequenceNumber: 42
        };
      })
    }
  };
}
function mockGetBlockResponse(ix) {
  return {
    tag: "GET_BLOCK",
    block: {
      id: "32"
    }
  };
}

var identity = function identity(v) {
  return v;
};

function mockSend() {
  var fallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;
  return /*#__PURE__*/function () {
    var _execSend = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(ix) {
      return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return ix;

            case 2:
              ix = _context.sent;
              _context.t0 = true;
              _context.next = _context.t0 === isGetAccount(ix) ? 6 : _context.t0 === isGetBlock(ix) ? 7 : 8;
              break;

            case 6:
              return _context.abrupt("return", mockAccountResponse(ix));

            case 7:
              return _context.abrupt("return", mockGetBlockResponse());

            case 8:
              return _context.abrupt("return", fallback(ix));

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function execSend(_x) {
      return _execSend.apply(this, arguments);
    }

    return execSend;
  }();
}

var _excluded = ["tempId"];
var idof = function idof(acct) {
  return "".concat(utilAddress.withPrefix(acct.addr), "-").concat(acct.keyId);
};
function sig(opts) {
  return ["SIGNATURE", opts.addr, opts.keyId].join(".");
}
function authzFn() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (account) {
    var acct = _objectSpread__default["default"](_objectSpread__default["default"](_objectSpread__default["default"]({}, account), opts), {}, {
      signingFunction: opts.signingFunction || account.signingFunction || fallbackSigningFunction
    });

    return acct;

    function fallbackSigningFunction(signable) {
      return {
        addr: acct.addr,
        keyId: acct.keyId,
        signature: sig(acct)
      };
    }
  };
}
function authzResolve() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (account) {
    var tempId = opts.tempId,
        rest = _objectWithoutProperties__default["default"](opts, _excluded);

    return _objectSpread__default["default"](_objectSpread__default["default"]({}, account), {}, {
      tempId: tempId || "WITH_RESOLVE",
      resolve: authzFn(rest)
    });
  };
}
var ROLE = {
  proposer: false,
  authorizer: false,
  payer: false
};

function authzResolveMany() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (account) {
    var tempId = opts.tempId || "AUTHZ_RESOLVE_MANY";
    return _objectSpread__default["default"](_objectSpread__default["default"]({}, account), {}, {
      tempId: tempId,
      resolve: function resolve() {
        return [opts.proposer && authzFn(opts.proposer)({
          role: _objectSpread__default["default"](_objectSpread__default["default"]({}, ROLE), {}, {
            proposer: true
          })
        })].concat(_toConsumableArray__default["default"](opts.authorizations.map(authzFn).map(function (d) {
          return d({
            role: _objectSpread__default["default"](_objectSpread__default["default"]({}, ROLE), {}, {
              authorizer: true
            })
          });
        })), [opts.payer && authzFn(opts.payer)({
          role: _objectSpread__default["default"](_objectSpread__default["default"]({}, ROLE), {}, {
            payer: true
          })
        })]).filter(Boolean);
      }
    });
  };
}

var run = function run() {
  var fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return build([ref("123")].concat(_toConsumableArray__default["default"](fns))).then(resolve);
};

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  mockSend: mockSend,
  authzFn: authzFn,
  authzResolve: authzResolve,
  authzResolveMany: authzResolveMany,
  sig: sig,
  idof: idof,
  run: run
});

var VERSION = "1.1.2" ;

var params = function params(_params) {
  return logger__namespace.log.deprecate({
    pkg: "FCL/SDK",
    message: "The params builder has been removed from the Flow JS-SDK/FCL.",
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params",
    level: logger__namespace.LEVELS.error
  });
};
var param = function param(params) {
  return logger__namespace.log.deprecate({
    pkg: "FCL/SDK",
    message: "The param builder has been removed from the Flow JS-SDK/FCL.",
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params",
    level: logger__namespace.LEVELS.error
  });
};

Object.defineProperty(exports, 'config', {
  enumerable: true,
  get: function () { return config.config; }
});
Object.defineProperty(exports, 'cadence', {
  enumerable: true,
  get: function () { return utilTemplate.template; }
});
Object.defineProperty(exports, 'cdc', {
  enumerable: true,
  get: function () { return utilTemplate.template; }
});
exports.TestUtils = index;
exports.VERSION = VERSION;
exports.account = account;
exports.arg = arg;
exports.args = args;
exports.atBlockHeight = atBlockHeight;
exports.atBlockId = atBlockId;
exports.authorization = authorization;
exports.authorizations = authorizations;
exports.block = block;
exports.build = build;
exports.createSignableVoucher = createSignableVoucher;
exports.decode = decode;
exports.destroy = destroy;
exports.encodeMessageFromSignable = encodeMessageFromSignable;
exports.encodeTransactionEnvelope = encodeTransactionEnvelope;
exports.encodeTransactionPayload = encodeTransactionPayload;
exports.encodeTxIdFromVoucher = encodeTxIdFromVoucher;
exports.get = get;
exports.getAccount = getAccount;
exports.getBlock = getBlock;
exports.getBlockHeader = getBlockHeader;
exports.getCollection = getCollection;
exports.getEvents = getEvents;
exports.getEventsAtBlockHeightRange = getEventsAtBlockHeightRange;
exports.getEventsAtBlockIds = getEventsAtBlockIds;
exports.getTransaction = getTransaction;
exports.getTransactionStatus = getTransactionStatus;
exports.interaction = interaction;
exports.invariant = invariant;
exports.isBad = isBad;
exports.isGetAccount = isGetAccount;
exports.isGetBlock = isGetBlock;
exports.isGetBlockHeader = isGetBlockHeader;
exports.isGetCollection = isGetCollection;
exports.isGetEvents = isGetEvents;
exports.isGetTransaction = isGetTransaction;
exports.isGetTransactionStatus = isGetTransactionStatus;
exports.isOk = isOk;
exports.isPing = isPing;
exports.isScript = isScript;
exports.isTransaction = isTransaction;
exports.isUnknown = isUnknown;
exports.limit = limit;
exports.param = param;
exports.params = params;
exports.payer = payer;
exports.ping = ping;
exports.pipe = pipe;
exports.proposer = proposer;
exports.put = put;
exports.ref = ref;
exports.resolve = resolve;
exports.resolveAccounts = resolveAccounts;
exports.resolveArguments = resolveArguments;
exports.resolveCadence = resolveCadence;
exports.resolveFinalNormalization = resolveFinalNormalization;
exports.resolveProposerSequenceNumber = resolveProposerSequenceNumber;
exports.resolveRefBlockId = resolveRefBlockId;
exports.resolveSignatures = resolveSignatures;
exports.resolveValidators = resolveValidators;
exports.resolveVoucherIntercept = resolveVoucherIntercept;
exports.script = script;
exports.send = send;
exports.transaction = transaction;
exports.update = update;
exports.validator = validator;
exports.voucherIntercept = voucherIntercept;
exports.voucherToTxId = voucherToTxId;
exports.why = why;
//# sourceMappingURL=sdk.js.map

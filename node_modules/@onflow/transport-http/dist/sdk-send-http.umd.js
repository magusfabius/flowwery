(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["onflowTransport-http"] = {}));
})(this, (function (exports) { 'use strict';

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _typeof$1(obj) {
    "@babel/helpers - typeof";

    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof$1(obj);
  }

  var regeneratorRuntime$1 = {exports: {}};

  var _typeof = {exports: {}};

  (function (module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";

      return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
    }

    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_typeof);

  (function (module) {
    var _typeof$1 = _typeof.exports["default"];

    function _regeneratorRuntime() {
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

      module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports = {},
          Op = Object.prototype,
          hasOwn = Op.hasOwnProperty,
          $Symbol = "function" == typeof Symbol ? Symbol : {},
          iteratorSymbol = $Symbol.iterator || "@@iterator",
          asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
          toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value: value,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), obj[key];
      }

      try {
        define({}, "");
      } catch (err) {
        define = function define(obj, key, value) {
          return obj[key] = value;
        };
      }

      function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
            generator = Object.create(protoGenerator.prototype),
            context = new Context(tryLocsList || []);
        return generator._invoke = function (innerFn, self, context) {
          var state = "suspendedStart";
          return function (method, arg) {
            if ("executing" === state) throw new Error("Generator is already running");

            if ("completed" === state) {
              if ("throw" === method) throw arg;
              return doneResult();
            }

            for (context.method = method, context.arg = arg;;) {
              var delegate = context.delegate;

              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);

                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }

              if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
                if ("suspendedStart" === state) throw state = "completed", context.arg;
                context.dispatchException(context.arg);
              } else "return" === context.method && context.abrupt("return", context.arg);
              state = "executing";
              var record = tryCatch(innerFn, self, context);

              if ("normal" === record.type) {
                if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                return {
                  value: record.arg,
                  done: context.done
                };
              }

              "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
            }
          };
        }(innerFn, self, context), generator;
      }

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      exports.wrap = wrap;
      var ContinueSentinel = {};

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {}

      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf,
          NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if ("throw" !== record.type) {
            var result = record.arg,
                value = result.value;
            return value && "object" == _typeof$1(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function (unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function (error) {
              return invoke("throw", error, resolve, reject);
            });
          }

          reject(record.arg);
        }

        var previousPromise;

        this._invoke = function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
      }

      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (undefined === method) {
          if (context.delegate = null, "throw" === context.method) {
            if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
            context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }

      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
      }

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next) return iterable;

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              for (; ++i < iterable.length;) {
                if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              }

              return next.value = undefined, next.done = !0, next;
            };

            return next.next = next;
          }
        }

        return {
          next: doneResult
        };
      }

      function doneResult() {
        return {
          value: undefined,
          done: !0
        };
      }

      return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports.mark = function (genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports.awrap = function (arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
        return this;
      }), define(Gp, "toString", function () {
        return "[object Generator]";
      }), exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        return keys.reverse(), function next() {
          for (; keys.length;) {
            var key = keys.pop();
            if (key in object) return next.value = key, next.done = !1, next;
          }

          return next.done = !0, next;
        };
      }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
          }
        },
        stop: function stop() {
          this.done = !0;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type) throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) throw exception;
          var context = this;

          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i],
                record = entry.completion;
            if ("root" === entry.tryLoc) return handle("end");

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"),
                  hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              } else {
                if (!hasFinally) throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type) throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          }

          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
      }, exports;
    }

    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(regeneratorRuntime$1);

  var runtime = regeneratorRuntime$1.exports();
  var regenerator = runtime; // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if ((typeof globalThis === "undefined" ? "undefined" : _typeof$1(globalThis)) === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }

  function invariant(fact, msg) {
    if (!fact) {
      var _console;

      var error = new Error("INVARIANT ".concat(msg));
      error.stack = error.stack.split("\n").filter(function (d) {
        return !/at invariant/.test(d);
      }).join("\n");

      for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        rest[_key - 2] = arguments[_key];
      }

      (_console = console).error.apply(_console, ["\n\n---\n\n", error, "\n\n"].concat(rest, ["\n\n---\n\n"]));

      throw error;
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  var buffer = {};

  var base64Js = {};

  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  } // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications


  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function getLens(b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    } // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42


    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  } // base64 is 4/3 + up to two characters of the original data


  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;

    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 0xFF;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3
    // go through the array every three bytes, we'll deal with trailing stuff later

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    } // pad the end with zeros, but make sure to not forget the extra bytes


    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }

    return parts.join('');
  }

  var ieee754 = {};

  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

  ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;

    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;

    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }

    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };

  ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);

      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }

      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }

      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;

    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };

  (function (exports) {

    var base64 = base64Js;
    var ieee754$1 = ieee754;
    var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null;
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 0x7fffffff;
    exports.kMaxLength = K_MAX_LENGTH;
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Print warning and recommend using `buffer` v4.x which has an Object
     *               implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * We report that the browser does not support typed arrays if the are not subclassable
     * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
     * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
     * for __proto__ and has a buggy typed array implementation.
     */

    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
    }

    function typedArraySupport() {
      // Can typed array instances can be augmented?
      try {
        var arr = new Uint8Array(1);
        var proto = {
          foo: function foo() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }

    Object.defineProperty(Buffer.prototype, 'parent', {
      enumerable: true,
      get: function get() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer.prototype, 'offset', {
      enumerable: true,
      get: function get() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
      }
    });

    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      } // Return an augmented `Uint8Array` instance


      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */


    function Buffer(arg, encodingOrOffset, length) {
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }

        return allocUnsafe(arg);
      }

      return from(arg, encodingOrOffset, length);
    }

    Buffer.poolSize = 8192; // not used by this implementation

    function from(value, encodingOrOffset, length) {
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset);
      }

      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }

      if (value == null) {
        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof$1(value));
      }

      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }

      if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }

      if (typeof value === 'number') {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }

      var valueOf = value.valueOf && value.valueOf();

      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
      }

      var b = fromObject(value);
      if (b) return b;

      if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
      }

      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof$1(value));
    }
    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/


    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    // https://github.com/feross/buffer/pull/148


    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);

    function assertSize(size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }

    function alloc(size, fill, encoding) {
      assertSize(size);

      if (size <= 0) {
        return createBuffer(size);
      }

      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpreted as a start offset.
        return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }

      return createBuffer(size);
    }
    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/


    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding);
    };

    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */


    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size);
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */


    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size);
    };

    function fromString(string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }

      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual);
      }

      return buf;
    }

    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);

      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }

      return buf;
    }

    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }

      return fromArrayLike(arrayView);
    }

    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }

      var buf;

      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      } // Return an augmented `Uint8Array` instance


      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }

    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);

        if (buf.length === 0) {
          return buf;
        }

        obj.copy(buf, 0, 0, len);
        return buf;
      }

      if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }

        return fromArrayLike(obj);
      }

      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }

    function checked(length) {
      // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
      }

      return length | 0;
    }

    function SlowBuffer(length) {
      if (+length != length) {
        // eslint-disable-line eqeqeq
        length = 0;
      }

      return Buffer.alloc(+length);
    }

    Buffer.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
    };

    Buffer.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }

      if (a === b) return 0;
      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true;

        default:
          return false;
      }
    };

    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      if (list.length === 0) {
        return Buffer.alloc(0);
      }

      var i;

      if (length === undefined) {
        length = 0;

        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;

      for (i = 0; i < list.length; ++i) {
        var buf = list[i];

        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }

        pos += buf.length;
      }

      return buffer;
    };

    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }

      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }

      if (typeof string !== 'string') {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof$1(string));
      }

      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len;

          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length;

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2;

          case 'hex':
            return len >>> 1;

          case 'base64':
            return base64ToBytes(string).length;

          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
            }

            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }

    Buffer.byteLength = byteLength;

    function slowToString(encoding, start, end) {
      var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.
      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

      if (start === undefined || start < 0) {
        start = 0;
      } // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.


      if (start > this.length) {
        return '';
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return '';
      } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.


      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return '';
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end);

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end);

          case 'ascii':
            return asciiSlice(this, start, end);

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end);

          case 'base64':
            return base64Slice(this, start, end);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    // reliably in a browserify context because there could be multiple different
    // copies of the 'buffer' package in use. This method works even for Buffer
    // instances that were created from another copy of the `buffer` package.
    // See: https://github.com/feross/buffer/issues/154


    Buffer.prototype._isBuffer = true;

    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;

      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      }

      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }

      return this;
    };

    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;

      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      }

      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }

      return this;
    };

    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;

      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      }

      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }

      return this;
    };

    Buffer.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0) return '';
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };

    Buffer.prototype.toLocaleString = Buffer.prototype.toString;

    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
      if (this === b) return true;
      return Buffer.compare(this, b) === 0;
    };

    Buffer.prototype.inspect = function inspect() {
      var str = '';
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
      if (this.length > max) str += ' ... ';
      return '<Buffer ' + str + '>';
    };

    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }

    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }

      if (!Buffer.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof$1(target));
      }

      if (start === undefined) {
        start = 0;
      }

      if (end === undefined) {
        end = target ? target.length : 0;
      }

      if (thisStart === undefined) {
        thisStart = 0;
      }

      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }

      if (thisStart >= thisEnd) {
        return -1;
      }

      if (start >= end) {
        return 1;
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf


    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1; // Normalize byteOffset

      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }

      byteOffset = +byteOffset; // Coerce to Number.

      if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : buffer.length - 1;
      } // Normalize byteOffset: negative offsets start from the end of the buffer


      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

      if (byteOffset >= buffer.length) {
        if (dir) return -1;else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;else return -1;
      } // Normalize val


      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      } // Finally, search either indexOf (if dir is true) or lastIndexOf


      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1;
        }

        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]

        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }

        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }

      throw new TypeError('val must be string, number or Buffer');
    }

    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();

        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }

          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read(buf, i) {
        if (indexSize === 1) {
          return buf[i];
        } else {
          return buf.readUInt16BE(i * indexSize);
        }
      }

      var i;

      if (dir) {
        var foundIndex = -1;

        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

        for (i = byteOffset; i >= 0; i--) {
          var found = true;

          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }

          if (found) return i;
        }
      }

      return -1;
    }

    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };

    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };

    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;

      if (!length) {
        length = remaining;
      } else {
        length = Number(length);

        if (length > remaining) {
          length = remaining;
        }
      }

      var strLen = string.length;

      if (length > strLen / 2) {
        length = strLen / 2;
      }

      var i;

      for (i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }

      return i;
    }

    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }

    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }

    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }

    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }

    Buffer.prototype.write = function write(string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0; // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0; // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset >>> 0;

        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
      }

      if (!encoding) encoding = 'utf8';
      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length);

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length);

          case 'ascii':
          case 'latin1':
          case 'binary':
            return asciiWrite(this, string, offset, length);

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };

    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }

    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;

      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte = void 0,
              thirdByte = void 0,
              fourthByte = void 0,
              tempCodePoint = void 0;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }

              break;

            case 2:
              secondByte = buf[i + 1];

              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }

          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res);
    } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety


    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;

      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
      } // Decode in chunks to avoid "call stack size exceeded".


      var res = '';
      var i = 0;

      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }

      return res;
    }

    function asciiSlice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }

      return ret;
    }

    function latin1Slice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }

      return ret;
    }

    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = '';

      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }

      return out;
    }

    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)

      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }

      return res;
    }

    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;
      var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

      Object.setPrototypeOf(newBuf, Buffer.prototype);
      return newBuf;
    };
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */


    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
    }

    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val;
    };

    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;

      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val;
    };

    Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };

    Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };

    Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };

    Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
    };

    Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };

    Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      var first = this[offset];
      var last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
      var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      var first = this[offset];
      var last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
      var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });

    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];

      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return this[offset];
      return (0xff - this[offset] + 1) * -1;
    };

    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };

    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };

    Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      var first = this[offset];
      var last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24); // Overflow

      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
    });
    Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      var first = this[offset];
      var last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      var val = (first << 24) + // Overflow
      this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
    });

    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    };

    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    };

    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
    }

    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };

    Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
      return offset + 2;
    };

    Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
      return offset + 4;
    };

    Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
      return offset + 4;
    };

    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      var lo = Number(value & BigInt(0xffffffff));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }

    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      var lo = Number(value & BigInt(0xffffffff));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }

    Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
    });
    Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
    });

    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
      return offset + 2;
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
      return offset + 4;
    };

    Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
    });
    Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
    });

    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
      if (offset < 0) throw new RangeError('Index out of range');
    }

    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }

      ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };

    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }

      ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
      }

      if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
      if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

      if (end > this.length) end = this.length;

      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;

      if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }

      return len;
    }; // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])


    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }

        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string');
        }

        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }

        if (val.length === 1) {
          var code = val.charCodeAt(0);

          if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
            // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
          }
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      } else if (typeof val === 'boolean') {
        val = Number(val);
      } // Invalid ranges are not set to a default, so can range check early.


      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
      }

      if (end <= start) {
        return this;
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;

      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;

        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }

        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this;
    }; // CUSTOM ERRORS
    // =============
    // Simplified versions from Node, changed for Buffer-only usage


    var errors = {};

    function E(sym, getMessage, Base) {
      errors[sym] = /*#__PURE__*/function (_Base) {
        _inherits(NodeError, _Base);

        var _super = _createSuper(NodeError);

        function NodeError() {
          var _this;

          _classCallCheck(this, NodeError);

          _this = _super.call(this);
          Object.defineProperty(_assertThisInitialized(_this), 'message', {
            value: getMessage.apply(_assertThisInitialized(_this), arguments),
            writable: true,
            configurable: true
          }); // Add the error code to the name to include it in the stack trace.

          _this.name = "".concat(_this.name, " [").concat(sym, "]"); // Access the stack to generate the error message including the error code
          // from the name.

          _this.stack; // eslint-disable-line no-unused-expressions
          // Reset the name to the actual name.

          delete _this.name;
          return _this;
        }

        _createClass(NodeError, [{
          key: "code",
          get: function get() {
            return sym;
          },
          set: function set(value) {
            Object.defineProperty(this, 'code', {
              configurable: true,
              enumerable: true,
              value: value,
              writable: true
            });
          }
        }, {
          key: "toString",
          value: function toString() {
            return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
          }
        }]);

        return NodeError;
      }(Base);
    }

    E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
      if (name) {
        return "".concat(name, " is outside of buffer bounds");
      }

      return 'Attempt to access memory outside buffer bounds';
    }, RangeError);
    E('ERR_INVALID_ARG_TYPE', function (name, actual) {
      return "The \"".concat(name, "\" argument must be of type number. Received type ").concat(_typeof$1(actual));
    }, TypeError);
    E('ERR_OUT_OF_RANGE', function (str, range, input) {
      var msg = "The value of \"".concat(str, "\" is out of range.");
      var received = input;

      if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === 'bigint') {
        received = String(input);

        if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
          received = addNumericalSeparator(received);
        }

        received += 'n';
      }

      msg += " It must be ".concat(range, ". Received ").concat(received);
      return msg;
    }, RangeError);

    function addNumericalSeparator(val) {
      var res = '';
      var i = val.length;
      var start = val[0] === '-' ? 1 : 0;

      for (; i >= start + 4; i -= 3) {
        res = "_".concat(val.slice(i - 3, i)).concat(res);
      }

      return "".concat(val.slice(0, i)).concat(res);
    } // CHECK FUNCTIONS
    // ===============


    function checkBounds(buf, offset, byteLength) {
      validateNumber(offset, 'offset');

      if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1));
      }
    }

    function checkIntBI(value, min, max, buf, offset, byteLength) {
      if (value > max || value < min) {
        var n = typeof min === 'bigint' ? 'n' : '';
        var range;

        if (byteLength > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
          } else {
            range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
          }
        } else {
          range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
        }

        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
      }

      checkBounds(buf, offset, byteLength);
    }

    function validateNumber(value, name) {
      if (typeof value !== 'number') {
        throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
      }
    }

    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
      }

      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }

      throw new errors.ERR_OUT_OF_RANGE(type || 'offset', ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
    } // HELPER FUNCTIONS
    // ================


    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

    function base64clean(str) {
      // Node takes equal signs as end of the Base64 encoding
      str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

      str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

      if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

      while (str.length % 4 !== 0) {
        str = str + '=';
      }

      return str;
    }

    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i); // is surrogate component

        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } // valid lead


            leadSurrogate = codePoint;
            continue;
          } // 2 leads in a row


          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          } // valid surrogate pair


          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null; // encode utf8

        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
          throw new Error('Invalid code point');
        }
      }

      return bytes;
    }

    function asciiToBytes(str) {
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }

      return byteArray;
    }

    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray;
    }

    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }

    function blitBuffer(src, dst, offset, length) {
      var i;

      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }

      return i;
    } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    // the `instanceof` check but they should be treated as of that type.
    // See: https://github.com/feross/buffer/issues/166


    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }

    function numberIsNaN(obj) {
      // For IE11 support
      return obj !== obj; // eslint-disable-line no-self-compare
    } // Create lookup table for `toString('hex')`
    // See: https://github.com/feross/buffer/issues/219


    var hexSliceLookupTable = function () {
      var alphabet = '0123456789abcdef';
      var table = new Array(256);

      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;

        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }

      return table;
    }(); // Return not function with Error if BigInt not supported


    function defineBigIntMethod(fn) {
      return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
    }

    function BufferBigIntNotDefined() {
      throw new Error('BigInt not supported');
    }
  })(buffer);

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function F() {};

        return {
          s: F,
          n: function n() {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function e(_e) {
            throw _e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function s() {
        it = it.call(o);
      },
      n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function e(_e2) {
        didErr = true;
        err = _e2;
      },
      f: function f() {
        try {
          if (!normalCompletion && it["return"] != null) it["return"]();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var promise;
  var queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask // reuse resolved promise, and allocate it lazily
  : function (cb) {
    return (promise || (promise = Promise.resolve())).then(cb)["catch"](function (err) {
      return setTimeout(function () {
        throw err;
      }, 0);
    });
  };

  var mailbox = function mailbox() {
    var queue = [];
    var next;
    return {
      deliver: function deliver(msg) {
        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  queue.push(msg);

                  if (next) {
                    next(queue.shift());
                    next = undefined;
                  }

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      receive: function receive() {
        return new Promise(function innerReceive(resolve) {
          var msg = queue.shift();
          if (msg) return resolve(msg);
          next = resolve;
        });
      }
    };
  };

  var INIT = "INIT";
  var SUBSCRIBE = "SUBSCRIBE";
  var UNSUBSCRIBE = "UNSUBSCRIBE";
  var UPDATED$1 = "UPDATED";
  var EXIT = "EXIT";
  var TERMINATE = "TERMINATE";
  var root = (typeof self === "undefined" ? "undefined" : _typeof$1(self)) === "object" && self.self === self && self || (typeof global === "undefined" ? "undefined" : _typeof$1(global)) === "object" && global.global === global && global || (typeof window === "undefined" ? "undefined" : _typeof$1(window)) === "object" && window.window === window && window;
  root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
  var pid = 0;
  var DEFAULT_TIMEOUT = 5000;

  var _send = function send(addr, tag, data) {
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    return new Promise(function (reply, reject) {
      var expectReply = opts.expectReply || false;
      var timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;

      if (expectReply && timeout) {
        setTimeout(function () {
          return reject(new Error("Timeout: ".concat(timeout, "ms passed without a response.")));
        }, timeout);
      }

      var payload = {
        to: addr,
        from: opts.from,
        tag: tag,
        data: data,
        timeout: timeout,
        reply: reply,
        reject: reject
      };

      try {
        root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);
        if (!expectReply) reply(true);
      } catch (error) {
        console.error("FCL.Actor -- Could Not Deliver Message", payload, root.FCL_REGISTRY[addr], error);
      }
    });
  };

  var kill = function kill(addr) {
    delete root.FCL_REGISTRY[addr];
  };

  var fromHandlers = function fromHandlers() {
    var handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ctx) {
        var letter;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(typeof handlers[INIT] === "function")) {
                  _context.next = 3;
                  break;
                }

                _context.next = 3;
                return handlers[INIT](ctx);

              case 3:
                _context.next = 6;
                return ctx.receive();

              case 6:
                letter = _context.sent;
                _context.prev = 7;

                if (!(letter.tag === EXIT)) {
                  _context.next = 13;
                  break;
                }

                if (!(typeof handlers[TERMINATE] === "function")) {
                  _context.next = 12;
                  break;
                }

                _context.next = 12;
                return handlers[TERMINATE](ctx, letter, letter.data || {});

              case 12:
                return _context.abrupt("break", 25);

              case 13:
                _context.next = 15;
                return handlers[letter.tag](ctx, letter, letter.data || {});

              case 15:
                _context.next = 20;
                break;

              case 17:
                _context.prev = 17;
                _context.t0 = _context["catch"](7);
                console.error("".concat(ctx.self(), " Error"), letter, _context.t0);

              case 20:
                _context.prev = 20;
                return _context.abrupt("continue", 3);

              case 23:
                _context.next = 3;
                break;

              case 25:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[7, 17, 20, 23]]);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
  };

  var spawn = function spawn(fn) {
    var addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (addr == null) addr = ++pid;
    if (root.FCL_REGISTRY[addr] != null) return addr;
    root.FCL_REGISTRY[addr] = {
      addr: addr,
      mailbox: mailbox(),
      subs: new Set(),
      kvs: {},
      error: null
    };
    var ctx = {
      self: function self() {
        return addr;
      },
      receive: function receive() {
        return root.FCL_REGISTRY[addr].mailbox.receive();
      },
      send: function send(to, tag, data) {
        var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        opts.from = addr;
        return _send(to, tag, data, opts);
      },
      sendSelf: function sendSelf(tag, data, opts) {
        if (root.FCL_REGISTRY[addr]) _send(addr, tag, data, opts);
      },
      broadcast: function broadcast(tag, data) {
        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        opts.from = addr;

        var _iterator = _createForOfIteratorHelper(root.FCL_REGISTRY[addr].subs),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var to = _step.value;

            _send(to, tag, data, opts);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      subscribe: function subscribe(sub) {
        return sub != null && root.FCL_REGISTRY[addr].subs.add(sub);
      },
      unsubscribe: function unsubscribe(sub) {
        return sub != null && root.FCL_REGISTRY[addr].subs["delete"](sub);
      },
      subscriberCount: function subscriberCount() {
        return root.FCL_REGISTRY[addr].subs.size;
      },
      hasSubs: function hasSubs() {
        return !!root.FCL_REGISTRY[addr].subs.size;
      },
      put: function put(key, value) {
        if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;
      },
      get: function get(key, fallback) {
        var value = root.FCL_REGISTRY[addr].kvs[key];
        return value == null ? fallback : value;
      },
      "delete": function _delete(key) {
        delete root.FCL_REGISTRY[addr].kvs[key];
      },
      update: function update(key, fn) {
        if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);
      },
      keys: function keys() {
        return Object.keys(root.FCL_REGISTRY[addr].kvs);
      },
      all: function all() {
        return root.FCL_REGISTRY[addr].kvs;
      },
      where: function where(pattern) {
        return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce(function (acc, key) {
          return pattern.test(key) ? _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, key, root.FCL_REGISTRY[addr].kvs[key])) : acc;
        }, {});
      },
      merge: function merge() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Object.keys(data).forEach(function (key) {
          return root.FCL_REGISTRY[addr].kvs[key] = data[key];
        });
      },
      fatalError: function fatalError(error) {
        root.FCL_REGISTRY[addr].error = error;

        var _iterator2 = _createForOfIteratorHelper(root.FCL_REGISTRY[addr].subs),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var to = _step2.value;

            _send(to, UPDATED$1);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    };
    if (_typeof$1(fn) === "object") fn = fromHandlers(fn);
    queueMicrotask_1( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return fn(ctx);

            case 2:
              kill(addr);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    return addr;
  }; // Returns an unsubscribe function
  // A SUBSCRIBE handler will need to be created to handle the subscription event
  //
  //  [SUBSCRIBE]: (ctx, letter) => {
  //    ctx.subscribe(letter.from)
  //    ctx.send(letter.from, UPDATED, ctx.all())
  //  }
  //


  function subscriber(address, spawnFn, callback) {
    spawnFn(address);
    var EXIT = "@EXIT";
    var self = spawn( /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ctx) {
        var letter, error;
        return regenerator.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                ctx.send(address, SUBSCRIBE);

              case 1:
                _context3.next = 4;
                return ctx.receive();

              case 4:
                letter = _context3.sent;
                error = root.FCL_REGISTRY[address].error;

                if (!(letter.tag === EXIT)) {
                  _context3.next = 9;
                  break;
                }

                ctx.send(address, UNSUBSCRIBE);
                return _context3.abrupt("return");

              case 9:
                if (!error) {
                  _context3.next = 13;
                  break;
                }

                callback(null, error);
                ctx.send(address, UNSUBSCRIBE);
                return _context3.abrupt("return");

              case 13:
                callback(letter.data, null);
                _context3.next = 1;
                break;

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function (_x2) {
        return _ref3.apply(this, arguments);
      };
    }());
    return function () {
      return _send(self, EXIT);
    };
  } // Returns a promise that returns a result

  var _HANDLERS;

  var NAME = "config";
  var PUT = "PUT_CONFIG";
  var GET = "GET_CONFIG";
  var GET_ALL = "GET_ALL_CONFIG";
  var UPDATE = "UPDATE_CONFIG";
  var DELETE = "DELETE_CONFIG";
  var CLEAR = "CLEAR_CONFIG";
  var WHERE = "WHERE_CONFIG";
  var UPDATED = "CONFIG/UPDATED";

  var identity = function identity(v) {
    return v;
  };

  var HANDLERS = (_HANDLERS = {}, _defineProperty(_HANDLERS, PUT, function (ctx, _letter, _ref) {
    var key = _ref.key,
        value = _ref.value;
    if (key == null) throw new Error("Missing 'key' for config/put.");
    ctx.put(key, value);
    ctx.broadcast(UPDATED, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS, GET, function (ctx, letter, _ref2) {
    var key = _ref2.key,
        fallback = _ref2.fallback;
    if (key == null) throw new Error("Missing 'key' for config/get");
    letter.reply(ctx.get(key, fallback));
  }), _defineProperty(_HANDLERS, GET_ALL, function (ctx, letter) {
    letter.reply(_objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS, UPDATE, function (ctx, letter, _ref3) {
    var key = _ref3.key,
        fn = _ref3.fn;
    if (key == null) throw new Error("Missing 'key' for config/update");
    ctx.update(key, fn || identity);
    ctx.broadcast(UPDATED, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS, DELETE, function (ctx, letter, _ref4) {
    var key = _ref4.key;
    if (key == null) throw new Error("Missing 'key' for config/delete");
    ctx["delete"](key);
    ctx.broadcast(UPDATED, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS, CLEAR, function (ctx, letter) {
    var keys = Object.keys(ctx.all());

    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
      var key = _keys[_i];
      ctx["delete"](key);
    }

    ctx.broadcast(UPDATED, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS, WHERE, function (ctx, letter, _ref5) {
    var pattern = _ref5.pattern;
    if (pattern == null) throw new Error("Missing 'pattern' for config/where");
    letter.reply(ctx.where(pattern));
  }), _defineProperty(_HANDLERS, SUBSCRIBE, function (ctx, letter) {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS, UNSUBSCRIBE, function (ctx, letter) {
    ctx.unsubscribe(letter.from);
  }), _HANDLERS);
  spawn(HANDLERS, NAME);

  function put(key, value) {
    _send(NAME, PUT, {
      key: key,
      value: value
    });
    return config();
  }

  function get(key, fallback) {
    return _send(NAME, GET, {
      key: key,
      fallback: fallback
    }, {
      expectReply: true,
      timeout: 10
    });
  }

  function first() {
    return _first.apply(this, arguments);
  }

  function _first() {
    _first = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
      var wants,
          fallback,
          _wants,
          head,
          rest,
          ret,
          _args2 = arguments;

      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              wants = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : [];
              fallback = _args2.length > 1 ? _args2[1] : undefined;

              if (wants.length) {
                _context2.next = 4;
                break;
              }

              return _context2.abrupt("return", fallback);

            case 4:
              _wants = _toArray(wants), head = _wants[0], rest = _wants.slice(1);
              _context2.next = 7;
              return get(head);

            case 7:
              ret = _context2.sent;

              if (!(ret == null)) {
                _context2.next = 10;
                break;
              }

              return _context2.abrupt("return", first(rest, fallback));

            case 10:
              return _context2.abrupt("return", ret);

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _first.apply(this, arguments);
  }

  function all() {
    return _send(NAME, GET_ALL, null, {
      expectReply: true,
      timeout: 10
    });
  }

  function update(key) {
    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
    _send(NAME, UPDATE, {
      key: key,
      fn: fn
    });
    return config();
  }

  function _delete(key) {
    _send(NAME, DELETE, {
      key: key
    });
    return config();
  }

  function where(pattern) {
    return _send(NAME, WHERE, {
      pattern: pattern
    }, {
      expectReply: true,
      timeout: 10
    });
  }

  function subscribe(callback) {
    return subscriber(NAME, function () {
      return spawn(HANDLERS, NAME);
    }, callback);
  }

  function clearConfig() {
    return _send(NAME, CLEAR);
  }

  function config(values) {
    if (values != null && _typeof$1(values) === "object") {
      Object.keys(values).map(function (d) {
        return put(d, values[d]);
      });
    }

    return {
      put: put,
      get: get,
      all: all,
      first: first,
      update: update,
      "delete": _delete,
      where: where,
      subscribe: subscribe,
      overload: overload
    };
  }

  config.put = put;
  config.get = get;
  config.all = all;
  config.first = first;
  config.update = update;
  config["delete"] = _delete;
  config.where = where;
  config.subscribe = subscribe;
  config.overload = overload;

  var noop = function noop(v) {
    return v;
  };

  function overload() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
    return new Promise( /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(resolve, reject) {
        var oldConfig, result;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return all();

              case 2:
                oldConfig = _context.sent;
                _context.prev = 3;
                config(opts);
                _context.t0 = callback;
                _context.next = 8;
                return all();

              case 8:
                _context.t1 = _context.sent;
                _context.next = 11;
                return (0, _context.t0)(_context.t1);

              case 11:
                result = _context.sent;
                _context.next = 14;
                return clearConfig();

              case 14:
                _context.next = 16;
                return config(oldConfig);

              case 16:
                resolve(result);
                _context.next = 26;
                break;

              case 19:
                _context.prev = 19;
                _context.t2 = _context["catch"](3);
                _context.next = 23;
                return clearConfig();

              case 23:
                _context.next = 25;
                return config(oldConfig);

              case 25:
                reject(_context.t2);

              case 26:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[3, 19]]);
      }));

      return function (_x, _x2) {
        return _ref6.apply(this, arguments);
      };
    }());
  }

  var LEVELS = Object.freeze({
    debug: 5,
    info: 4,
    log: 3,
    warn: 2,
    error: 1
  });

  var buildLoggerMessageArgs = function buildLoggerMessageArgs(_ref) {
    var title = _ref.title,
        message = _ref.message;
    return ["\n    %c".concat(title, "\n    ============================\n\n    ").concat(message, "\n\n    ============================\n    ").replace(/\n[^\S\r\n]+/g, "\n").trim(),, "font-weight:bold;font-family:monospace;"];
  };

  var log = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref2) {
      var _console, _console2, _console3, _console4, _console5;

      var title, message, level, _ref2$always, always, configLoggerLevel, loggerMessageArgs;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              title = _ref2.title, message = _ref2.message, level = _ref2.level, _ref2$always = _ref2.always, always = _ref2$always === void 0 ? false : _ref2$always;
              _context.next = 3;
              return config.get("logger.level", LEVELS.warn);

            case 3:
              configLoggerLevel = _context.sent;

              if (!(!always && configLoggerLevel < level)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return");

            case 6:
              loggerMessageArgs = buildLoggerMessageArgs({
                title: title,
                message: message
              });
              _context.t0 = level;
              _context.next = _context.t0 === LEVELS.debug ? 10 : _context.t0 === LEVELS.info ? 12 : _context.t0 === LEVELS.warn ? 14 : _context.t0 === LEVELS.error ? 16 : 18;
              break;

            case 10:
              (_console = console).debug.apply(_console, _toConsumableArray(loggerMessageArgs));

              return _context.abrupt("break", 19);

            case 12:
              (_console2 = console).info.apply(_console2, _toConsumableArray(loggerMessageArgs));

              return _context.abrupt("break", 19);

            case 14:
              (_console3 = console).warn.apply(_console3, _toConsumableArray(loggerMessageArgs));

              return _context.abrupt("break", 19);

            case 16:
              (_console4 = console).error.apply(_console4, _toConsumableArray(loggerMessageArgs));

              return _context.abrupt("break", 19);

            case 18:
              (_console5 = console).log.apply(_console5, _toConsumableArray(loggerMessageArgs));

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function log(_x) {
      return _ref3.apply(this, arguments);
    };
  }();

  log.deprecate = function (_ref4) {
    var pkg = _ref4.pkg,
        subject = _ref4.subject,
        transition = _ref4.transition,
        _ref4$level = _ref4.level,
        level = _ref4$level === void 0 ? LEVELS.warn : _ref4$level,
        _ref4$message = _ref4.message,
        message = _ref4$message === void 0 ? "" : _ref4$message,
        _ref4$callback = _ref4.callback,
        callback = _ref4$callback === void 0 ? null : _ref4$callback;

    var capitalizeFirstLetter = function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    };

    var logMessage = function logMessage() {
      return log({
        title: "".concat(pkg ? pkg + " " : "", "Deprecation Notice"),
        message: "\n      ".concat(subject ? "".concat(capitalizeFirstLetter(subject), " is deprecated and will cease to work in future releases").concat(pkg ? " of " + pkg : "", ".") : "").concat(message ? "\n" + message : "").concat(transition ? "\nYou can learn more (including a guide on common transition paths) here: ".concat(transition) : "", "\n    ").trim(),
        level: level
      });
    };

    if (typeof callback === "function") {
      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
        var _args2 = arguments;
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return logMessage();

              case 2:
                _context2.next = 4;
                return callback.apply(void 0, _args2);

              case 4:
                return _context2.abrupt("return", _context2.sent);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
    }

    return logMessage();
  };

  var browser = {exports: {}};

  (function (module, exports) {

    var getGlobal = function getGlobal() {
      // the only reliable means to get the global object is
      // `Function('return this')()`
      // However, this causes CSP violations in Chrome apps.
      if (typeof self !== 'undefined') {
        return self;
      }

      if (typeof window !== 'undefined') {
        return window;
      }

      if (typeof global !== 'undefined') {
        return global;
      }

      throw new Error('unable to locate global object');
    };

    var global = getGlobal();
    module.exports = exports = global.fetch; // Needed for TypeScript and Webpack.

    if (global.fetch) {
      exports["default"] = global.fetch.bind(global);
    }

    exports.Headers = global.Headers;
    exports.Request = global.Request;
    exports.Response = global.Response;
  })(browser, browser.exports);

  var fetchTransport = browser.exports;

  var HTTPRequestError = /*#__PURE__*/function (_Error) {
    _inherits(HTTPRequestError, _Error);

    var _super = _createSuper(HTTPRequestError);

    function HTTPRequestError(_ref) {
      var _this;

      var error = _ref.error,
          hostname = _ref.hostname,
          path = _ref.path,
          method = _ref.method,
          requestBody = _ref.requestBody,
          responseBody = _ref.responseBody,
          responseStatusText = _ref.responseStatusText,
          statusCode = _ref.statusCode;

      _classCallCheck(this, HTTPRequestError);

      var msg = "\n      HTTP Request Error: An error occurred when interacting with the Access API.\n      ".concat(error ? "error=".concat(error) : "", "\n      ").concat(hostname ? "hostname=".concat(hostname) : "", "\n      ").concat(path ? "path=".concat(path) : "", "\n      ").concat(method ? "method=".concat(method) : "", "\n      ").concat(requestBody ? "requestBody=".concat(requestBody) : "", "\n      ").concat(responseBody ? "responseBody=".concat(responseBody) : "", "\n      ").concat(responseStatusText ? "responseStatusText=".concat(responseStatusText) : "", "\n      ").concat(statusCode ? "statusCode=".concat(statusCode) : "", "\n    ");
      _this = _super.call(this, msg);
      _this.name = "HTTP Request Error";
      _this.statusCode = statusCode;
      _this.errorMessage = error;
      return _this;
    }

    return _createClass(HTTPRequestError);
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /**
   * Creates an HTTP Request to be sent to a REST Access API via Fetch API.
   *
   * @param {Object} options - Options for the HTTP Request
   * @param {String} options.hostname - Access API Hostname
   * @param {String} options.path - Path to the resource on the Access API
   * @param {String} options.method - HTTP Method
   * @param {Object} options.body - HTTP Request Body
   * @param {Object | Headers} [options.headers] - HTTP Request Headers
   *
   * @returns JSON object response from Access API.
   */


  function httpRequest(_x) {
    return _httpRequest.apply(this, arguments);
  }

  function _httpRequest() {
    _httpRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(_ref2) {
      var hostname, path, method, body, headers, _ref2$retryLimit, retryLimit, _ref2$retryIntervalMs, retryIntervalMs, bodyJSON, makeRequest, requestLoop, _requestLoop;

      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _requestLoop = function _requestLoop3() {
                _requestLoop = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
                  var retryAttempt,
                      resp,
                      retryStatusCodes,
                      _args3 = arguments;
                  return regenerator.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          retryAttempt = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 0;
                          _context3.prev = 1;
                          _context3.next = 4;
                          return makeRequest();

                        case 4:
                          resp = _context3.sent;
                          return _context3.abrupt("return", resp);

                        case 8:
                          _context3.prev = 8;
                          _context3.t0 = _context3["catch"](1);
                          retryStatusCodes = [408, 429, 500, 502, 503, 504];

                          if (!retryStatusCodes.includes(_context3.t0.statusCode)) {
                            _context3.next = 17;
                            break;
                          }

                          _context3.next = 14;
                          return new Promise(function (resolve, reject) {
                            if (retryAttempt < retryLimit) {
                              console.warn("Access node unavailable, retrying in ".concat(retryIntervalMs, " ms..."));
                              setTimeout(function () {
                                resolve(requestLoop(retryAttempt + 1));
                              }, retryIntervalMs);
                            } else {
                              reject(_context3.t0);
                            }
                          });

                        case 14:
                          return _context3.abrupt("return", _context3.sent);

                        case 17:
                          throw _context3.t0;

                        case 18:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3, null, [[1, 8]]);
                }));
                return _requestLoop.apply(this, arguments);
              };

              requestLoop = function _requestLoop2() {
                return _requestLoop.apply(this, arguments);
              };

              makeRequest = function _makeRequest() {
                return fetchTransport("".concat(hostname).concat(path), {
                  method: method,
                  body: bodyJSON,
                  headers: headers
                }).then( /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(res) {
                    var responseText, response;
                    return regenerator.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (!res.ok) {
                              _context.next = 2;
                              break;
                            }

                            return _context.abrupt("return", res.json());

                          case 2:
                            if (!res.body) {
                              _context.next = 8;
                              break;
                            }

                            _context.next = 5;
                            return res.text();

                          case 5:
                            _context.t0 = _context.sent;
                            _context.next = 9;
                            break;

                          case 8:
                            _context.t0 = null;

                          case 9:
                            responseText = _context.t0;
                            response = safeParseJSON(responseText);
                            throw new HTTPRequestError({
                              error: response === null || response === void 0 ? void 0 : response.message,
                              hostname: hostname,
                              path: path,
                              method: method,
                              requestBody: bodyJSON,
                              responseBody: responseText,
                              responseStatusText: res.statusText,
                              statusCode: res.status
                            });

                          case 12:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x2) {
                    return _ref3.apply(this, arguments);
                  };
                }())["catch"]( /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(e) {
                    return regenerator.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!(e instanceof HTTPRequestError)) {
                              _context2.next = 2;
                              break;
                            }

                            throw e;

                          case 2:
                            _context2.next = 4;
                            return log({
                              title: "Access Node Error",
                              message: "The provided access node ".concat(hostname, " does not appear to be a valid REST/HTTP access node.\nPlease verify that you are not unintentionally using a GRPC access node.\nSee more here: https://docs.onflow.org/fcl/reference/sdk-guidelines/#connect"),
                              level: LEVELS.error
                            });

                          case 4:
                            throw new HTTPRequestError({
                              error: e === null || e === void 0 ? void 0 : e.message,
                              hostname: hostname,
                              path: path,
                              method: method,
                              requestBody: bodyJSON
                            });

                          case 5:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x3) {
                    return _ref4.apply(this, arguments);
                  };
                }());
              };

              hostname = _ref2.hostname, path = _ref2.path, method = _ref2.method, body = _ref2.body, headers = _ref2.headers, _ref2$retryLimit = _ref2.retryLimit, retryLimit = _ref2$retryLimit === void 0 ? 5 : _ref2$retryLimit, _ref2$retryIntervalMs = _ref2.retryIntervalMs, retryIntervalMs = _ref2$retryIntervalMs === void 0 ? 1000 : _ref2$retryIntervalMs;
              bodyJSON = body ? JSON.stringify(body) : null;
              _context4.next = 7;
              return requestLoop();

            case 7:
              return _context4.abrupt("return", _context4.sent);

            case 8:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _httpRequest.apply(this, arguments);
  }

  function safeParseJSON(data) {
    try {
      return JSON.parse(data);
    } catch (_unused) {
      return null;
    }
  }

  function sendExecuteScriptAtBlockIDRequest(_x, _x2, _x3) {
    return _sendExecuteScriptAtBlockIDRequest.apply(this, arguments);
  }

  function _sendExecuteScriptAtBlockIDRequest() {
    _sendExecuteScriptAtBlockIDRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/scripts?block_id=".concat(ix.block.id),
                method: "POST",
                body: {
                  script: context.Buffer.from(ix.message.cadence).toString("base64"),
                  arguments: ix.message.arguments.map(function (arg) {
                    return context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64");
                  })
                }
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse$4(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendExecuteScriptAtBlockIDRequest.apply(this, arguments);
  }

  function sendExecuteScriptAtBlockHeightRequest(_x4, _x5, _x6) {
    return _sendExecuteScriptAtBlockHeightRequest.apply(this, arguments);
  }

  function _sendExecuteScriptAtBlockHeightRequest() {
    _sendExecuteScriptAtBlockHeightRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/scripts?block_height=".concat(ix.block.height),
                method: "POST",
                body: {
                  script: context.Buffer.from(ix.message.cadence).toString("base64"),
                  arguments: ix.message.arguments.map(function (arg) {
                    return context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64");
                  })
                }
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse$4(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendExecuteScriptAtBlockHeightRequest.apply(this, arguments);
  }

  function sendExecuteScriptAtLatestBlockRequest(_x7, _x8, _x9) {
    return _sendExecuteScriptAtLatestBlockRequest.apply(this, arguments);
  }

  function _sendExecuteScriptAtLatestBlockRequest() {
    _sendExecuteScriptAtLatestBlockRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context3.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/scripts?block_height=sealed",
                method: "POST",
                body: {
                  script: context.Buffer.from(ix.message.cadence).toString("base64"),
                  arguments: ix.message.arguments.map(function (arg) {
                    return context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64");
                  })
                }
              });

            case 3:
              res = _context3.sent;
              return _context3.abrupt("return", constructResponse$4(ix, context, res));

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendExecuteScriptAtLatestBlockRequest.apply(this, arguments);
  }

  function constructResponse$4(ix, context, res) {
    var ret = context.response();
    ret.tag = ix.tag;
    ret.encodedData = JSON.parse(context.Buffer.from(res, "base64").toString());
    return ret;
  }

  function sendExecuteScript(_x10) {
    return _sendExecuteScript.apply(this, arguments);
  }

  function _sendExecuteScript() {
    _sendExecuteScript = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ix) {
      var context,
          opts,
          _args4 = arguments;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              context = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
              opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
              invariant(opts.node, "SDK Send Execute Script Error: opts.node must be defined.");
              invariant(context.response, "SDK Send Execute Script Error: context.response must be defined.");
              invariant(context.Buffer, "SDK Send Execute Script Error: context.Buffer must be defined.");
              _context4.next = 7;
              return ix;

            case 7:
              ix = _context4.sent;

              if (!ix.block.id) {
                _context4.next = 14;
                break;
              }

              _context4.next = 11;
              return sendExecuteScriptAtBlockIDRequest(ix, context, opts);

            case 11:
              return _context4.abrupt("return", _context4.sent);

            case 14:
              if (!ix.block.height) {
                _context4.next = 20;
                break;
              }

              _context4.next = 17;
              return sendExecuteScriptAtBlockHeightRequest(ix, context, opts);

            case 17:
              return _context4.abrupt("return", _context4.sent);

            case 20:
              _context4.next = 22;
              return sendExecuteScriptAtLatestBlockRequest(ix, context, opts);

            case 22:
              return _context4.abrupt("return", _context4.sent);

            case 23:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _sendExecuteScript.apply(this, arguments);
  }

  var HashAlgorithmIDs = {
    SHA2_256: 1,
    SHA2_384: 2,
    SHA3_256: 3,
    SHA3_384: 4,
    KMAC128_BLS_BLS12_381: 5
  };
  var SignatureAlgorithmIDs = {
    ECDSA_P256: 1,
    ECDSA_secp256k1: 2,
    BLS_BLS12_381: 3
  };

  function sendGetAccountAtBlockHeightRequest(_x, _x2, _x3) {
    return _sendGetAccountAtBlockHeightRequest.apply(this, arguments);
  }

  function _sendGetAccountAtBlockHeightRequest() {
    _sendGetAccountAtBlockHeightRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/accounts/".concat(ix.account.addr, "?block_height=").concat(ix.block.height, "&expand=contracts,keys"),
                method: "GET",
                body: null
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse$3(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetAccountAtBlockHeightRequest.apply(this, arguments);
  }

  function sendGetAccountAtLatestBlockRequest(_x4, _x5, _x6) {
    return _sendGetAccountAtLatestBlockRequest.apply(this, arguments);
  }

  function _sendGetAccountAtLatestBlockRequest() {
    _sendGetAccountAtLatestBlockRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/accounts/".concat(ix.account.addr, "?block_height=sealed&expand=contracts,keys"),
                method: "GET",
                body: null
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse$3(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendGetAccountAtLatestBlockRequest.apply(this, arguments);
  }

  function constructResponse$3(ix, context, res) {
    var _res$keys$map, _res$keys;

    var ret = context.response();
    ret.tag = ix.tag;

    var unwrapContracts = function unwrapContracts(contracts) {
      var c = {};
      if (!contracts) return c;

      for (var _i = 0, _Object$keys = Object.keys(contracts); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        c[key] = context.Buffer.from(contracts[key], "base64").toString();
      }

      return c;
    };

    ret.account = {
      address: res.address,
      balance: Number(res.balance),
      code: "",
      contracts: unwrapContracts(res.contracts),
      keys: (_res$keys$map = (_res$keys = res.keys) === null || _res$keys === void 0 ? void 0 : _res$keys.map(function (key) {
        return {
          index: Number(key.index),
          publicKey: key.public_key.replace(/^0x/, ""),
          signAlgo: SignatureAlgorithmIDs[key.signing_algorithm],
          signAlgoString: key.signing_algorithm,
          hashAlgo: HashAlgorithmIDs[key.hashing_algorithm],
          hashAlgoString: key.hashing_algorithm,
          sequenceNumber: Number(key.sequence_number),
          weight: Number(key.weight),
          revoked: key.revoked
        };
      })) !== null && _res$keys$map !== void 0 ? _res$keys$map : []
    };
    return ret;
  }

  function sendGetAccount(_x7) {
    return _sendGetAccount.apply(this, arguments);
  }

  function _sendGetAccount() {
    _sendGetAccount = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix) {
      var context,
          opts,
          _args3 = arguments;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              context = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
              opts = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
              invariant(opts.node, "SDK Send Get Account Error: opts.node must be defined.");
              invariant(context.response, "SDK Send Get Account Error: context.response must be defined.");
              invariant(context.Buffer, "SDK Send Get Account Error: context.Buffer must be defined.");
              _context3.next = 7;
              return ix;

            case 7:
              ix = _context3.sent;

              if (!(ix.block.height !== null)) {
                _context3.next = 14;
                break;
              }

              _context3.next = 11;
              return sendGetAccountAtBlockHeightRequest(ix, context, opts);

            case 11:
              return _context3.abrupt("return", _context3.sent);

            case 14:
              _context3.next = 16;
              return sendGetAccountAtLatestBlockRequest(ix, context, opts);

            case 16:
              return _context3.abrupt("return", _context3.sent);

            case 17:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendGetAccount.apply(this, arguments);
  }

  function sendGetBlockHeaderByIDRequest(_x, _x2, _x3) {
    return _sendGetBlockHeaderByIDRequest.apply(this, arguments);
  }

  function _sendGetBlockHeaderByIDRequest() {
    _sendGetBlockHeaderByIDRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks/".concat(ix.block.id),
                method: "GET",
                body: null
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse$2(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetBlockHeaderByIDRequest.apply(this, arguments);
  }

  function sendGetBlockHeaderByHeightRequest(_x4, _x5, _x6) {
    return _sendGetBlockHeaderByHeightRequest.apply(this, arguments);
  }

  function _sendGetBlockHeaderByHeightRequest() {
    _sendGetBlockHeaderByHeightRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=".concat(ix.block.height),
                method: "GET",
                body: null
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse$2(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendGetBlockHeaderByHeightRequest.apply(this, arguments);
  }

  function sendGetLatestBlockHeaderRequest(_x7, _x8, _x9) {
    return _sendGetLatestBlockHeaderRequest.apply(this, arguments);
  }

  function _sendGetLatestBlockHeaderRequest() {
    _sendGetLatestBlockHeaderRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix, context, opts) {
      var _ix$block;

      var httpRequest$1, height, res;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              height = (_ix$block = ix.block) !== null && _ix$block !== void 0 && _ix$block.isSealed ? "sealed" : "finalized";
              _context3.next = 4;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=".concat(height),
                method: "GET",
                body: null
              });

            case 4:
              res = _context3.sent;
              return _context3.abrupt("return", constructResponse$2(ix, context, res));

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendGetLatestBlockHeaderRequest.apply(this, arguments);
  }

  function constructResponse$2(ix, context, res) {
    var block = res.length ? res[0] : null;
    var ret = context.response();
    ret.tag = ix.tag;
    ret.blockHeader = {
      id: block.header.id,
      parentId: block.header.parent_id,
      height: Number(block.header.height),
      timestamp: block.header.timestamp
    };
    return ret;
  }

  function sendGetBlockHeader(_x10) {
    return _sendGetBlockHeader.apply(this, arguments);
  }

  function _sendGetBlockHeader() {
    _sendGetBlockHeader = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ix) {
      var context,
          opts,
          interactionHasBlockID,
          interactionHasBlockHeight,
          _args4 = arguments;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              context = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
              opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
              invariant(opts.node, "SDK Send Get Block Header Error: opts.node must be defined.");
              invariant(context.response, "SDK Send Get Block Header Error: context.response must be defined.");
              _context4.next = 6;
              return ix;

            case 6:
              ix = _context4.sent;
              interactionHasBlockID = ix.block.id !== null;
              interactionHasBlockHeight = ix.block.height !== null;

              if (!interactionHasBlockID) {
                _context4.next = 15;
                break;
              }

              _context4.next = 12;
              return sendGetBlockHeaderByIDRequest(ix, context, opts);

            case 12:
              return _context4.abrupt("return", _context4.sent);

            case 15:
              if (!interactionHasBlockHeight) {
                _context4.next = 21;
                break;
              }

              _context4.next = 18;
              return sendGetBlockHeaderByHeightRequest(ix, context, opts);

            case 18:
              return _context4.abrupt("return", _context4.sent);

            case 21:
              _context4.next = 23;
              return sendGetLatestBlockHeaderRequest(ix, context, opts);

            case 23:
              return _context4.abrupt("return", _context4.sent);

            case 24:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _sendGetBlockHeader.apply(this, arguments);
  }

  function sendGetBlockByIDRequest(_x, _x2, _x3) {
    return _sendGetBlockByIDRequest.apply(this, arguments);
  }

  function _sendGetBlockByIDRequest() {
    _sendGetBlockByIDRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks/".concat(ix.block.id, "?expand=payload"),
                method: "GET",
                body: null
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse$1(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetBlockByIDRequest.apply(this, arguments);
  }

  function sendGetBlockByHeightRequest(_x4, _x5, _x6) {
    return _sendGetBlockByHeightRequest.apply(this, arguments);
  }

  function _sendGetBlockByHeightRequest() {
    _sendGetBlockByHeightRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=".concat(ix.block.height, "&expand=payload"),
                method: "GET",
                body: null
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse$1(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendGetBlockByHeightRequest.apply(this, arguments);
  }

  function sendGetBlockRequest(_x7, _x8, _x9) {
    return _sendGetBlockRequest.apply(this, arguments);
  }

  function _sendGetBlockRequest() {
    _sendGetBlockRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix, context, opts) {
      var _ix$block;

      var httpRequest$1, height, res;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              height = (_ix$block = ix.block) !== null && _ix$block !== void 0 && _ix$block.isSealed ? "sealed" : "final";
              _context3.next = 4;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=".concat(height, "&expand=payload"),
                method: "GET",
                body: null
              });

            case 4:
              res = _context3.sent;
              return _context3.abrupt("return", constructResponse$1(ix, context, res));

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendGetBlockRequest.apply(this, arguments);
  }

  function constructResponse$1(ix, context, res) {
    var block = res.length ? res[0] : null;
    var ret = context.response();
    ret.tag = ix.tag;
    ret.block = {
      id: block.header.id,
      parentId: block.header.parent_id,
      height: Number(block.header.height),
      timestamp: block.header.timestamp,
      collectionGuarantees: block.payload.collection_guarantees.map(function (collectionGuarantee) {
        return {
          collectionId: collectionGuarantee.collection_id,
          signerIds: collectionGuarantee.signer_ids
        };
      }),
      blockSeals: block.payload.block_seals.map(function (blockSeal) {
        return {
          blockId: blockSeal.block_id,
          executionReceiptId: blockSeal.result_id
        };
      })
    };
    return ret;
  }

  function sendGetBlock(_x10) {
    return _sendGetBlock.apply(this, arguments);
  }

  function _sendGetBlock() {
    _sendGetBlock = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ix) {
      var context,
          opts,
          interactionHasBlockID,
          interactionHasBlockHeight,
          _args4 = arguments;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              context = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
              opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
              invariant(opts.node, "SDK Send Get Block Error: opts.node must be defined.");
              invariant(context.response, "SDK Send Get Block Error: context.response must be defined.");
              _context4.next = 6;
              return ix;

            case 6:
              ix = _context4.sent;
              interactionHasBlockID = ix.block.id !== null;
              interactionHasBlockHeight = ix.block.height !== null;

              if (!interactionHasBlockID) {
                _context4.next = 15;
                break;
              }

              _context4.next = 12;
              return sendGetBlockByIDRequest(ix, context, opts);

            case 12:
              return _context4.abrupt("return", _context4.sent);

            case 15:
              if (!interactionHasBlockHeight) {
                _context4.next = 21;
                break;
              }

              _context4.next = 18;
              return sendGetBlockByHeightRequest(ix, context, opts);

            case 18:
              return _context4.abrupt("return", _context4.sent);

            case 21:
              _context4.next = 23;
              return sendGetBlockRequest(ix, context, opts);

            case 23:
              return _context4.abrupt("return", _context4.sent);

            case 24:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _sendGetBlock.apply(this, arguments);
  }

  function sendGetCollection(_x) {
    return _sendGetCollection.apply(this, arguments);
  }

  function _sendGetCollection() {
    _sendGetCollection = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          res,
          ret,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant(opts.node, "SDK Send Get Collection Error: opts.node must be defined.");
              invariant(context.response, "SDK Send Get Collection Error: context.response must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 7;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/collections/".concat(ix.collection.id, "?expand=transactions"),
                method: "GET",
                body: null
              });

            case 7:
              res = _context.sent;
              ret = context.response();
              ret.tag = ix.tag;
              ret.collection = {
                id: res.id,
                transactionIds: res.transactions.map(function (transaction) {
                  return transaction.id;
                })
              };
              return _context.abrupt("return", ret);

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetCollection.apply(this, arguments);
  }

  function sendGetEventsForHeightRangeRequest(_x, _x2, _x3) {
    return _sendGetEventsForHeightRangeRequest.apply(this, arguments);
  }

  function _sendGetEventsForHeightRangeRequest() {
    _sendGetEventsForHeightRangeRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/events?type=".concat(ix.events.eventType, "&start_height=").concat(ix.events.start, "&end_height=").concat(ix.events.end),
                method: "GET",
                body: null
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetEventsForHeightRangeRequest.apply(this, arguments);
  }

  function sendGetEventsForBlockIDsRequest(_x4, _x5, _x6) {
    return _sendGetEventsForBlockIDsRequest.apply(this, arguments);
  }

  function _sendGetEventsForBlockIDsRequest() {
    _sendGetEventsForBlockIDsRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/events?type=".concat(ix.events.eventType, "&block_ids=").concat(ix.events.blockIds.join(",")),
                method: "GET",
                body: null
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendGetEventsForBlockIDsRequest.apply(this, arguments);
  }

  function constructResponse(ix, context, res) {
    var ret = context.response();
    ret.tag = ix.tag;
    ret.events = [];
    res.forEach(function (block) {
      return block.events ? block.events.forEach(function (event) {
        return ret.events.push({
          blockId: block.block_id,
          blockHeight: Number(block.block_height),
          blockTimestamp: block.block_timestamp,
          type: event.type,
          transactionId: event.transaction_id,
          transactionIndex: Number(event.transaction_index),
          eventIndex: Number(event.event_index),
          payload: JSON.parse(context.Buffer.from(event.payload, "base64").toString())
        });
      }) : null;
    });
    return ret;
  }

  function sendGetEvents(_x7) {
    return _sendGetEvents.apply(this, arguments);
  }

  function _sendGetEvents() {
    _sendGetEvents = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix) {
      var context,
          opts,
          interactionContainsBlockHeightRange,
          interactionContainsBlockIDsList,
          _args3 = arguments;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              context = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
              opts = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
              invariant(opts.node, "SDK Send Get Events Error: opts.node must be defined.");
              invariant(context.response, "SDK Send Get Events Error: context.response must be defined.");
              invariant(context.Buffer, "SDK Send Get Events Error: context.Buffer must be defined.");
              _context3.next = 7;
              return ix;

            case 7:
              ix = _context3.sent;
              interactionContainsBlockHeightRange = ix.events.start !== null;
              interactionContainsBlockIDsList = Array.isArray(ix.events.blockIds) && ix.events.blockIds.length > 0;
              invariant(interactionContainsBlockHeightRange || interactionContainsBlockIDsList, "SendGetEventsError: Unable to determine which get events request to send. Either a block height range, or block IDs must be specified.");

              if (!interactionContainsBlockHeightRange) {
                _context3.next = 17;
                break;
              }

              _context3.next = 14;
              return sendGetEventsForHeightRangeRequest(ix, context, opts);

            case 14:
              return _context3.abrupt("return", _context3.sent);

            case 17:
              _context3.next = 19;
              return sendGetEventsForBlockIDsRequest(ix, context, opts);

            case 19:
              return _context3.abrupt("return", _context3.sent);

            case 20:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendGetEvents.apply(this, arguments);
  }

  function sendGetTransaction(_x) {
    return _sendGetTransaction.apply(this, arguments);
  }

  function _sendGetTransaction() {
    _sendGetTransaction = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          res,
          unwrapKey,
          unwrapSignature,
          unwrapArg,
          ret,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant(opts.node, "SDK Send Get Transaction Error: opts.node must be defined.");
              invariant(context.response, "SDK Send Get Transaction Error: context.response must be defined.");
              invariant(context.Buffer, "SDK Send Get Transaction Error: context.Buffer must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 8;
              return ix;

            case 8:
              ix = _context.sent;
              _context.next = 11;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/transactions/".concat(ix.transaction.id),
                method: "GET",
                body: null
              });

            case 11:
              res = _context.sent;

              unwrapKey = function unwrapKey(key) {
                return {
                  address: key.address,
                  keyId: Number(key.key_id),
                  sequenceNumber: Number(key.sequence_number)
                };
              };

              unwrapSignature = function unwrapSignature(sig) {
                return {
                  address: sig.address,
                  keyId: Number(sig.key_index),
                  signature: sig.signature
                };
              };

              unwrapArg = function unwrapArg(arg) {
                return JSON.parse(context.Buffer.from(arg, "base64").toString());
              };

              ret = context.response();
              ret.tag = ix.tag;
              ret.transaction = {
                script: context.Buffer.from(res.script, "base64").toString(),
                args: _toConsumableArray(res.arguments.map(unwrapArg)),
                referenceBlockId: res.reference_block_id,
                gasLimit: Number(res.gas_limit),
                payer: res.payer,
                proposalKey: res.proposal_key ? unwrapKey(res.proposal_key) : res.proposal_key,
                authorizers: res.authorizers,
                payloadSignatures: _toConsumableArray(res.payload_signatures.map(unwrapSignature)),
                envelopeSignatures: _toConsumableArray(res.envelope_signatures.map(unwrapSignature))
              };
              return _context.abrupt("return", ret);

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetTransaction.apply(this, arguments);
  }

  var STATUS_MAP = {
    UNKNOWN: 0,
    PENDING: 1,
    FINALIZED: 2,
    EXECUTED: 3,
    SEALED: 4,
    EXPIRED: 5
  };
  function sendGetTransactionStatus(_x) {
    return _sendGetTransactionStatus.apply(this, arguments);
  }

  function _sendGetTransactionStatus() {
    _sendGetTransactionStatus = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          res,
          ret,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant(opts.node, "SDK Send Get Transaction Status Error: opts.node must be defined.");
              invariant(context.response, "SDK Send Get Transaction Status Error: context.response must be defined.");
              invariant(context.Buffer, "SDK Send Get Transaction Status Error: context.Buffer must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 8;
              return ix;

            case 8:
              ix = _context.sent;
              _context.next = 11;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/transaction_results/".concat(ix.transaction.id),
                method: "GET",
                body: null
              });

            case 11:
              res = _context.sent;
              ret = context.response();
              ret.tag = ix.tag;
              ret.transactionStatus = {
                blockId: res.block_id,
                status: STATUS_MAP[res.status.toUpperCase()] || "",
                statusString: res.status.toUpperCase(),
                statusCode: res.status_code,
                errorMessage: res.error_message,
                events: res.events.map(function (event) {
                  return {
                    type: event.type,
                    transactionId: event.transaction_id,
                    transactionIndex: Number(event.transaction_index),
                    eventIndex: Number(event.event_index),
                    payload: JSON.parse(context.Buffer.from(event.payload, "base64").toString())
                  };
                })
              };
              return _context.abrupt("return", ret);

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetTransactionStatus.apply(this, arguments);
  }

  function sendPing(_x) {
    return _sendPing.apply(this, arguments);
  }

  function _sendPing() {
    _sendPing = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          ret,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant(opts.node, "SDK Send Ping Error: opts.node must be defined.");
              invariant(context.response, "SDK Send Ping Error: context.response must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 7;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=sealed",
                method: "GET",
                body: null
              });

            case 7:
              ret = context.response();
              ret.tag = ix.tag;
              return _context.abrupt("return", ret);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendPing.apply(this, arguments);
  }

  function sansPrefix(address) {
    if (address == null) return null;
    return address.replace(/^0x/, "").replace(/^Fx/, "");
  }

  var idof = function idof(acct) {
    return "".concat(withPrefix(acct.addr), "-").concat(acct.keyId);
  };

  function sendTransaction(_x) {
    return _sendTransaction.apply(this, arguments);
  }

  function _sendTransaction() {
    _sendTransaction = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          payloadSignatures,
          _i,
          _Object$values,
          acct,
          envelopeSignatures,
          _i2,
          _Object$values2,
          _acct,
          id,
          t1,
          res,
          t2,
          ret,
          _args = arguments;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant(opts.node, "SDK Send Transaction Error: opts.node must be defined.");
              invariant(context.response, "SDK Send Transaction Error: context.response must be defined.");
              invariant(context.Buffer, "SDK Send Transaction Error: context.Buffer must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 8;
              return ix;

            case 8:
              ix = _context.sent;
              // Apply Non Payer Signatures to Payload Signatures
              payloadSignatures = [];
              _i = 0, _Object$values = Object.values(ix.accounts);

            case 11:
              if (!(_i < _Object$values.length)) {
                _context.next = 24;
                break;
              }

              acct = _Object$values[_i];
              _context.prev = 13;

              if (!acct.role.payer && acct.signature != null) {
                payloadSignatures.push({
                  address: sansPrefix(acct.addr),
                  key_index: String(acct.keyId),
                  signature: context.Buffer.from(acct.signature, "hex").toString("base64")
                });
              }

              _context.next = 21;
              break;

            case 17:
              _context.prev = 17;
              _context.t0 = _context["catch"](13);
              console.error("SDK HTTP Send Error: Trouble applying payload signature", {
                acct: acct,
                ix: ix
              });
              throw _context.t0;

            case 21:
              _i++;
              _context.next = 11;
              break;

            case 24:
              // Apply Payer Signatures to Envelope Signatures
              envelopeSignatures = {};
              _i2 = 0, _Object$values2 = Object.values(ix.accounts);

            case 26:
              if (!(_i2 < _Object$values2.length)) {
                _context.next = 39;
                break;
              }

              _acct = _Object$values2[_i2];
              _context.prev = 28;

              if (_acct.role.payer && _acct.signature != null) {
                id = _acct.tempId || idof(_acct);
                envelopeSignatures[id] = envelopeSignatures[id] || {
                  address: sansPrefix(_acct.addr),
                  key_index: String(_acct.keyId),
                  signature: context.Buffer.from(_acct.signature, "hex").toString("base64")
                };
              }

              _context.next = 36;
              break;

            case 32:
              _context.prev = 32;
              _context.t1 = _context["catch"](28);
              console.error("SDK HTTP Send Error: Trouble applying envelope signature", {
                acct: _acct,
                ix: ix
              });
              throw _context.t1;

            case 36:
              _i2++;
              _context.next = 26;
              break;

            case 39:
              envelopeSignatures = Object.values(envelopeSignatures);
              t1 = Date.now();
              _context.next = 43;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/transactions",
                method: "POST",
                body: {
                  script: context.Buffer.from(ix.message.cadence).toString("base64"),
                  arguments: _toConsumableArray(ix.message.arguments.map(function (arg) {
                    return context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64");
                  })),
                  reference_block_id: ix.message.refBlock ? ix.message.refBlock : null,
                  gas_limit: String(ix.message.computeLimit),
                  payer: sansPrefix(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
                  proposal_key: {
                    address: sansPrefix(ix.accounts[ix.proposer].addr),
                    key_index: String(ix.accounts[ix.proposer].keyId),
                    sequence_number: String(ix.accounts[ix.proposer].sequenceNum)
                  },
                  authorizers: ix.authorizations.map(function (tempId) {
                    return ix.accounts[tempId].addr;
                  }).reduce(function (prev, current) {
                    return prev.find(function (item) {
                      return item === current;
                    }) ? prev : [].concat(_toConsumableArray(prev), [current]);
                  }, []).map(sansPrefix),
                  payload_signatures: payloadSignatures,
                  envelope_signatures: envelopeSignatures
                }
              });

            case 43:
              res = _context.sent;
              t2 = Date.now();
              ret = context.response();
              ret.tag = ix.tag;
              ret.transactionId = res.id;

              if (typeof window !== "undefined") {
                window.dispatchEvent(new CustomEvent("FLOW::TX", {
                  detail: {
                    txId: ret.transactionId,
                    delta: t2 - t1
                  }
                }));
              }

              return _context.abrupt("return", ret);

            case 50:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[13, 17], [28, 32]]);
    }));
    return _sendTransaction.apply(this, arguments);
  }

  var send = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant(opts.node, "SDK Send Error: Either opts.node or \"accessNode.api\" in config must be defined.");
              invariant(context.ix, "SDK Send Error: context.ix must be defined.");
              _context.next = 6;
              return ix;

            case 6:
              ix = _context.sent;
              _context.t0 = true;
              _context.next = _context.t0 === context.ix.isTransaction(ix) ? 10 : _context.t0 === context.ix.isGetTransactionStatus(ix) ? 11 : _context.t0 === context.ix.isGetTransaction(ix) ? 12 : _context.t0 === context.ix.isScript(ix) ? 13 : _context.t0 === context.ix.isGetAccount(ix) ? 14 : _context.t0 === context.ix.isGetEvents(ix) ? 15 : _context.t0 === context.ix.isGetBlock(ix) ? 16 : _context.t0 === context.ix.isGetBlockHeader(ix) ? 17 : _context.t0 === context.ix.isGetCollection(ix) ? 18 : _context.t0 === context.ix.isPing(ix) ? 19 : 20;
              break;

            case 10:
              return _context.abrupt("return", opts.sendTransaction ? opts.sendTransaction(ix, context, opts) : sendTransaction(ix, context, opts));

            case 11:
              return _context.abrupt("return", opts.sendGetTransactionStatus ? opts.sendGetTransactionStatus(ix, context, opts) : sendGetTransactionStatus(ix, context, opts));

            case 12:
              return _context.abrupt("return", opts.sendGetTransaction ? opts.sendGetTransaction(ix, context, opts) : sendGetTransaction(ix, context, opts));

            case 13:
              return _context.abrupt("return", opts.sendExecuteScript ? opts.sendExecuteScript(ix, context, opts) : sendExecuteScript(ix, context, opts));

            case 14:
              return _context.abrupt("return", opts.sendGetAccount ? opts.sendGetAccount(ix, context, opts) : sendGetAccount(ix, context, opts));

            case 15:
              return _context.abrupt("return", opts.sendGetEvents ? opts.sendGetEvents(ix, context, opts) : sendGetEvents(ix, context, opts));

            case 16:
              return _context.abrupt("return", opts.sendGetBlock ? opts.sendGetBlock(ix, context, opts) : sendGetBlock(ix, context, opts));

            case 17:
              return _context.abrupt("return", opts.sendGetBlockHeader ? opts.sendGetBlockHeader(ix, context, opts) : sendGetBlockHeader(ix, context, opts));

            case 18:
              return _context.abrupt("return", opts.sendGetCollection ? opts.sendGetCollection(ix, context, opts) : sendGetCollection(ix, context, opts));

            case 19:
              return _context.abrupt("return", opts.sendPing ? opts.sendPing(ix, context, opts) : sendPing(ix, context, opts));

            case 20:
              return _context.abrupt("return", ix);

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function send(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  exports.send = send;
  exports.sendExecuteScript = sendExecuteScript;
  exports.sendGetAccount = sendGetAccount;
  exports.sendGetBlock = sendGetBlock;
  exports.sendGetBlockHeader = sendGetBlockHeader;
  exports.sendGetCollection = sendGetCollection;
  exports.sendGetEvents = sendGetEvents;
  exports.sendGetTransaction = sendGetTransaction;
  exports.sendGetTransactionStatus = sendGetTransactionStatus;
  exports.sendPing = sendPing;
  exports.sendTransaction = sendTransaction;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=sdk-send-http.umd.js.map

import _defineProperty from '@babel/runtime/helpers/defineProperty';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _createForOfIteratorHelper from '@babel/runtime/helpers/createForOfIteratorHelper';
import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import _typeof from '@babel/runtime/helpers/typeof';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import queueMicrotask from 'queue-microtask';

var mailbox = function mailbox() {
  var queue = [];
  var next;
  return {
    deliver: function deliver(msg) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                queue.push(msg);

                if (next) {
                  next(queue.shift());
                  next = undefined;
                }

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    receive: function receive() {
      return new Promise(function innerReceive(resolve) {
        var msg = queue.shift();
        if (msg) return resolve(msg);
        next = resolve;
      });
    }
  };
};

var INIT = "INIT";
var SUBSCRIBE = "SUBSCRIBE";
var UNSUBSCRIBE = "UNSUBSCRIBE";
var UPDATED = "UPDATED";
var SNAPSHOT = "SNAPSHOT";
var EXIT = "EXIT";
var TERMINATE = "TERMINATE";
var root = (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && self.self === self && self || (typeof global === "undefined" ? "undefined" : _typeof(global)) === "object" && global.global === global && global || (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && window.window === window && window;
root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
var pid = 0;
var DEFAULT_TIMEOUT = 5000;

var _send = function send(addr, tag, data) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return new Promise(function (reply, reject) {
    var expectReply = opts.expectReply || false;
    var timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;

    if (expectReply && timeout) {
      setTimeout(function () {
        return reject(new Error("Timeout: ".concat(timeout, "ms passed without a response.")));
      }, timeout);
    }

    var payload = {
      to: addr,
      from: opts.from,
      tag: tag,
      data: data,
      timeout: timeout,
      reply: reply,
      reject: reject
    };

    try {
      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);
      if (!expectReply) reply(true);
    } catch (error) {
      console.error("FCL.Actor -- Could Not Deliver Message", payload, root.FCL_REGISTRY[addr], error);
    }
  });
};
var kill = function kill(addr) {
  delete root.FCL_REGISTRY[addr];
};

var fromHandlers = function fromHandlers() {
  var handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ctx) {
      var letter;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(typeof handlers[INIT] === "function")) {
                _context.next = 3;
                break;
              }

              _context.next = 3;
              return handlers[INIT](ctx);

            case 3:

              _context.next = 6;
              return ctx.receive();

            case 6:
              letter = _context.sent;
              _context.prev = 7;

              if (!(letter.tag === EXIT)) {
                _context.next = 13;
                break;
              }

              if (!(typeof handlers[TERMINATE] === "function")) {
                _context.next = 12;
                break;
              }

              _context.next = 12;
              return handlers[TERMINATE](ctx, letter, letter.data || {});

            case 12:
              return _context.abrupt("break", 25);

            case 13:
              _context.next = 15;
              return handlers[letter.tag](ctx, letter, letter.data || {});

            case 15:
              _context.next = 20;
              break;

            case 17:
              _context.prev = 17;
              _context.t0 = _context["catch"](7);
              console.error("".concat(ctx.self(), " Error"), letter, _context.t0);

            case 20:
              _context.prev = 20;
              return _context.abrupt("continue", 3);

            case 23:
              _context.next = 3;
              break;

            case 25:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[7, 17, 20, 23]]);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

var spawn = function spawn(fn) {
  var addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (addr == null) addr = ++pid;
  if (root.FCL_REGISTRY[addr] != null) return addr;
  root.FCL_REGISTRY[addr] = {
    addr: addr,
    mailbox: mailbox(),
    subs: new Set(),
    kvs: {},
    error: null
  };
  var ctx = {
    self: function self() {
      return addr;
    },
    receive: function receive() {
      return root.FCL_REGISTRY[addr].mailbox.receive();
    },
    send: function send(to, tag, data) {
      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      opts.from = addr;
      return _send(to, tag, data, opts);
    },
    sendSelf: function sendSelf(tag, data, opts) {
      if (root.FCL_REGISTRY[addr]) _send(addr, tag, data, opts);
    },
    broadcast: function broadcast(tag, data) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      opts.from = addr;

      var _iterator = _createForOfIteratorHelper(root.FCL_REGISTRY[addr].subs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var to = _step.value;

          _send(to, tag, data, opts);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    subscribe: function subscribe(sub) {
      return sub != null && root.FCL_REGISTRY[addr].subs.add(sub);
    },
    unsubscribe: function unsubscribe(sub) {
      return sub != null && root.FCL_REGISTRY[addr].subs["delete"](sub);
    },
    subscriberCount: function subscriberCount() {
      return root.FCL_REGISTRY[addr].subs.size;
    },
    hasSubs: function hasSubs() {
      return !!root.FCL_REGISTRY[addr].subs.size;
    },
    put: function put(key, value) {
      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;
    },
    get: function get(key, fallback) {
      var value = root.FCL_REGISTRY[addr].kvs[key];
      return value == null ? fallback : value;
    },
    "delete": function _delete(key) {
      delete root.FCL_REGISTRY[addr].kvs[key];
    },
    update: function update(key, fn) {
      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);
    },
    keys: function keys() {
      return Object.keys(root.FCL_REGISTRY[addr].kvs);
    },
    all: function all() {
      return root.FCL_REGISTRY[addr].kvs;
    },
    where: function where(pattern) {
      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce(function (acc, key) {
        return pattern.test(key) ? _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, root.FCL_REGISTRY[addr].kvs[key])) : acc;
      }, {});
    },
    merge: function merge() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object.keys(data).forEach(function (key) {
        return root.FCL_REGISTRY[addr].kvs[key] = data[key];
      });
    },
    fatalError: function fatalError(error) {
      root.FCL_REGISTRY[addr].error = error;

      var _iterator2 = _createForOfIteratorHelper(root.FCL_REGISTRY[addr].subs),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var to = _step2.value;

          _send(to, UPDATED);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  };
  if (_typeof(fn) === "object") fn = fromHandlers(fn);
  queueMicrotask( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return fn(ctx);

          case 2:
            kill(addr);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  })));
  return addr;
}; // Returns an unsubscribe function
// A SUBSCRIBE handler will need to be created to handle the subscription event
//
//  [SUBSCRIBE]: (ctx, letter) => {
//    ctx.subscribe(letter.from)
//    ctx.send(letter.from, UPDATED, ctx.all())
//  }
//

function subscriber(address, spawnFn, callback) {
  spawnFn(address);
  var EXIT = "@EXIT";
  var self = spawn( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(ctx) {
      var letter, error;
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              ctx.send(address, SUBSCRIBE);

            case 1:

              _context3.next = 4;
              return ctx.receive();

            case 4:
              letter = _context3.sent;
              error = root.FCL_REGISTRY[address].error;

              if (!(letter.tag === EXIT)) {
                _context3.next = 9;
                break;
              }

              ctx.send(address, UNSUBSCRIBE);
              return _context3.abrupt("return");

            case 9:
              if (!error) {
                _context3.next = 13;
                break;
              }

              callback(null, error);
              ctx.send(address, UNSUBSCRIBE);
              return _context3.abrupt("return");

            case 13:
              callback(letter.data, null);
              _context3.next = 1;
              break;

            case 16:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x2) {
      return _ref3.apply(this, arguments);
    };
  }());
  return function () {
    return _send(self, EXIT);
  };
} // Returns a promise that returns a result
// A SNAPSHOT handler will need to be created to handle the snapshot event
//
//  [SNAPSHOT]: (ctx, letter) => {
//    letter.reply(ctx.all())
//  }
//

function snapshoter(address, spawnFn) {
  spawnFn(address);
  return _send(address, SNAPSHOT, null, {
    expectReply: true,
    timeout: 0
  });
}

export { EXIT, INIT, SNAPSHOT, SUBSCRIBE, TERMINATE, UNSUBSCRIBE, UPDATED, kill, _send as send, snapshoter, spawn, subscriber };
//# sourceMappingURL=actor.module.js.map
